{"pageProps":{"questions":[{"id":"39s0PZL1m03n4jyydqEk","question_id":86,"question_text":"A developer is building a web and mobile application for two types of users: regular users and guest users. Regular users are required to log in, but guest users do not log in. Users should see only their data, regardless of whether they authenticate. Users need AWS credentials before they can access AWS resources.\n\nWhat is the MOST secure solution that the developer can implement to allow access for guest users?","question_images":[],"isMC":true,"url":"https://www.examtopics.com/discussions/amazon/view/88231-exam-aws-certified-developer-associate-topic-1-question-176/","unix_timestamp":1669042800,"discussion":[{"poster":"rcaliandro","comment_id":"938089","upvote_count":"1","content":"Selected Answer: A\nA is correct it is possible to use Amazon Cognito user and identity pool for configure a guest users and define the permissions to the unauthenticate users","timestamp":"1688042220.0"},{"comment_id":"819359","timestamp":"1677166800.0","upvote_count":"1","content":"Selected Answer: A\nThe most secure solution that the developer can implement to allow access for guest users is to use an Amazon Cognito credentials provider to issue temporary credentials that are linked to an unauthenticated role that has access to the required resources.\n\nUsing Amazon Cognito, the developer can create a user pool and an identity pool. The user pool allows for user authentication and management, while the identity pool provides temporary AWS credentials that grant access to AWS resources. By configuring the identity pool to allow unauthenticated users, guest users can obtain temporary AWS credentials without the need for authentication. The developer can also define fine-grained access control policies to ensure that users see only their data.\n\nOption B is not a recommended solution as it would require hardcoding of IAM credentials, which is not secure. Option C and D do not provide a solution for user authentication and management, which is a requirement for the application. Therefore, option A is the best solution to meet the requirements while also providing a secure and scalable architecture.","poster":"MMaquis"},{"poster":"pancman","timestamp":"1676913180.0","upvote_count":"1","comment_id":"815583","content":"Easy A. Access to AWS resources is Cognito identity pools with federation"},{"comment_id":"777675","upvote_count":"1","poster":"ishpal","content":"Selected Answer: A\naaaaaaaaaaaa","timestamp":"1673874900.0"},{"content":"Sounds like our in-house experts given up completely since about page 15 or so ^_^","comment_id":"763173","timestamp":"1672573500.0","upvote_count":"2","poster":"tieyua"},{"poster":"nharaz","content":"Selected Answer: A\nAmazon Cognito identity pools provide temporary AWS credentials for users who are guests (unauthenticated) and for users who have been authenticated and received a token. An identity pool is a store of user identity data specific to your account.","upvote_count":"1","comment_id":"761783","timestamp":"1672389960.0"},{"comment_id":"729969","upvote_count":"1","timestamp":"1669700460.0","content":"Selected Answer: A\naaaaaaaa","poster":"michaldavid"},{"comment_id":"726460","upvote_count":"1","content":"Selected Answer: A\nhttps://docs.aws.amazon.com/cognito/latest/developerguide/identity-pools.html","timestamp":"1669360080.0","poster":"k1kavi1"},{"poster":"CloudHandsOn","upvote_count":"1","comment_id":"725834","content":"A.\nperfect job for Cognito","timestamp":"1669293540.0"},{"poster":"saysamsuf","timestamp":"1669074420.0","upvote_count":"3","content":"Selected Answer: A\nA seems about right. I stand to be corrected.","comment_id":"723992"}],"answer_description":"","answers_community":["A (100%)"],"exam_id":25,"timestamp":"2022-11-21 16:00:00","answer_images":[],"choices":{"D":"Generate temporary credentials. Store the temporary credentials in AWS Secrets Manager. Use the temporary credentials to access the required resources.","B":"Set up an IAM user that has permissions to the required resources. Hardcode the IAM credentials in the web and mobile application.","C":"Generate temporary keys that are stored in AWS Key Management Service (AWS KMS). Use the temporary keys to access the required resources.","A":"Use an Amazon Cognito credentials provider to issue temporary credentials that are linked to an unauthenticated role that has access to the required resources."},"topic":"1","answer_ET":"A","answer":"A"},{"id":"rfKoi2Vf4SnhQKCd7b0E","question_id":87,"question_text":"A developer is using AWS Elastic Beanstalk to create a deployment for a web application that supports ecommerce. According to a company requirement. Amazon EC2 instances that host one version of the application must be retired when the deployment of a new version is complete.\n\nWhich deployment methods can the developer use to meet this requirement? (Choose two.)","question_images":[],"isMC":true,"url":"https://www.examtopics.com/discussions/amazon/view/88232-exam-aws-certified-developer-associate-topic-1-question-177/","unix_timestamp":1669042920,"discussion":[{"timestamp":"1688042400.0","content":"Selected Answer: DE\nD and E are correct because Immutable and Blu/Green are similar and we have the possibility to terminate all the old instances only when we are sure that the application is well working in the prod enviroment","comment_id":"938095","poster":"rcaliandro","upvote_count":"1"},{"upvote_count":"1","poster":"GD_ZH","timestamp":"1677015540.0","content":"Must be D and E. It mentions EC2 host one version of the application must be retired, so C is not correct.","comment_id":"817201"},{"timestamp":"1674154680.0","upvote_count":"1","content":"D and E","comment_id":"781501","poster":"sichilam"},{"comment_id":"772784","timestamp":"1673460600.0","content":"Selected Answer: DE\nD and E","upvote_count":"1","poster":"ayoubmk"},{"comment_id":"734058","upvote_count":"4","content":"C is also fine as it doesn't break the requirement - maybe the eCommerce website has near 0 traffic.","comments":[],"timestamp":"1670014020.0","poster":"gpit"},{"content":"Selected Answer: DE\nD and E","upvote_count":"1","timestamp":"1669700580.0","poster":"michaldavid","comment_id":"729972"},{"comment_id":"726463","poster":"k1kavi1","content":"Selected Answer: DE\nImmutable and Blue/Green code deployed to new instances.\nhttps://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features.deploy-existing-version.html","upvote_count":"2","timestamp":"1669360500.0"},{"timestamp":"1669042920.0","content":"Selected Answer: DE\nDE, must have 2 at the same time during transition","poster":"dark_cherrymon","upvote_count":"2","comment_id":"723667"}],"answer_description":"","answers_community":["DE (100%)"],"exam_id":25,"timestamp":"2022-11-21 16:02:00","choices":{"A":"All-al-once deployment","C":"Rolling deployment without an additional batch","E":"Immutable deployment","B":"In-place deployment","D":"Blue/green deployment"},"answer_images":[],"topic":"1","answer_ET":"DE","answer":"DE"},{"id":"Yuc2J3fyhRDEUeogbICE","choices":{"D":"Add an attribute with the expiration time; name the attribute ItemExpiration.","A":"Write a script that deletes old records; schedule the script as a cron job on an Amazon EC2 instance.","C":"Each day, create a new table to hold session data; delete the previous day’s table.","B":"Add an attribute with the expiration time; enable the Time To Live feature based on that attribute."},"answers_community":["B (100%)"],"question_text":"A company caches session information for a web application in an Amazon DynamoDB table. The company wants an automated way to delete old items from the table.\n\nWhat is the simplest way to do this?","question_images":[],"timestamp":"2022-11-21 16:02:00","isMC":true,"question_id":88,"unix_timestamp":1669042920,"topic":"1","answer_images":[],"answer_ET":"B","answer":"B","discussion":[{"timestamp":"1688042520.0","upvote_count":"2","content":"Selected Answer: B\nB is correct, there is in DynamoDB the possibility to have a timestamp column and set that column as TTL. This means that as soon as the timestamp expire, the row will be automatically deleted in 48 hours","comment_id":"938100","poster":"rcaliandro"},{"timestamp":"1673874960.0","upvote_count":"2","poster":"ishpal","comment_id":"777677","content":"Selected Answer: B\nBbbbbbbbbbbbbbbbbbbbb"},{"poster":"michaldavid","upvote_count":"2","comment_id":"729976","timestamp":"1669700700.0","content":"Selected Answer: B\nbbbbbbbbb"},{"poster":"k1kavi1","comment_id":"726465","content":"Selected Answer: B\nhttps://docs.aws.amazon.com/amazondynamodb/latest/developerguide/howitworks-ttl.html","timestamp":"1669360740.0","upvote_count":"1"}],"answer_description":"","exam_id":25,"url":"https://www.examtopics.com/discussions/amazon/view/88234-exam-aws-certified-developer-associate-topic-1-question-178/"},{"id":"O5iEj7GJeEIzQUY1N8DX","discussion":[{"comment_id":"938119","timestamp":"1688043060.0","poster":"rcaliandro","content":"Selected Answer: D\nD is correct. A won't work because we have to set the percentage and also the domain of API's is the same. Instead, we can plan a canary deploymnet with shifted traffic in the settings","upvote_count":"1"},{"poster":"shahs10","comment_id":"860403","timestamp":"1680561480.0","content":"Selected Answer: A\nWhy not A?","upvote_count":"1"},{"upvote_count":"1","poster":"GARGMOH","timestamp":"1677745860.0","content":"Selected Answer: D\nCANARY DEPLOYMENT HELPS TO SHIFT THE TRAFFIC BASED ON PERCENTAGE.","comment_id":"826653"},{"timestamp":"1669700760.0","poster":"michaldavid","upvote_count":"2","comment_id":"729978","content":"Selected Answer: D\ndddddddd"},{"poster":"k1kavi1","content":"Selected Answer: D\nhttps://docs.aws.amazon.com/apigateway/latest/developerguide/canary-release.html","upvote_count":"1","comment_id":"726466","timestamp":"1669360920.0"},{"upvote_count":"1","timestamp":"1669042980.0","content":"Selected Answer: D\nD \n\nhttps://www.examtopics.com/discussions/amazon/view/51596-exam-aws-certified-developer-associate-topic-1-question-355/","comment_id":"723672","poster":"dark_cherrymon"}],"question_images":[],"answer_images":[],"answer_description":"","question_id":89,"topic":"1","unix_timestamp":1669042980,"answer_ET":"D","url":"https://www.examtopics.com/discussions/amazon/view/88235-exam-aws-certified-developer-associate-topic-1-question-179/","answers_community":["D (86%)","14%"],"exam_id":25,"choices":{"C":"Implement an Amazon CloudWatch alarm to trigger a rollback if the observed HTTP 500 status code rate exceeds a predetermined threshold.","A":"Create a new API in API Gateway. Direct a portion of the traffic to the new API using an Amazon Route 53 weighted routing policy.","B":"Validate the new API version and promote it to production during the window of lowest expected utilization.","D":"Use the canary release deployment option in API Gateway. Direct a percentage of the API traffic using the canarySettings setting."},"timestamp":"2022-11-21 16:03:00","isMC":true,"question_text":"A company's new mobile app uses Amazon API Gateway. As the development team completes a new release of its APIs, a developer must safely and transparently roll out the API change.\n\nWhat is the SIMPLEST solution for the developer to use for rolling out the new API version to a limited number of users through API Gateway?","answer":"D"},{"id":"mmHLVkfFdJvZxp0Phtvz","choices":{"D":"Partition key on the office identifier","B":"Partition key on the employee name and sort key on the office identifier","A":"Partition key on the office identifier and sort key on the employee name","C":"Partition key on the employee name"},"question_id":90,"isMC":true,"answer_description":"","answers_community":["A (66%)","B (31%)","3%"],"question_images":[],"answer":"A","url":"https://www.examtopics.com/discussions/amazon/view/79714-exam-aws-certified-developer-associate-topic-1-question-18/","answer_images":[],"answer_ET":"A","discussion":[{"comment_id":"662407","upvote_count":"11","poster":"quirio1983","content":"Selected Answer: A\nIt´s A","timestamp":"1662550140.0"},{"content":"Selected Answer: B\nB because the partition key must have high caridinality to avoid hot partitions","comment_id":"684685","comments":[{"comment_id":"1310468","upvote_count":"1","poster":"JonasKahnwald","timestamp":"1731395520.0","content":"That doesn't meet the requirements."}],"timestamp":"1664698560.0","upvote_count":"9","poster":"andregri"},{"comment_id":"1326867","upvote_count":"2","timestamp":"1734268920.0","poster":"sumanshu","content":"Selected Answer: A\nA) Correct - The partition key on the office identifier ensures that all employees for a particular office are grouped together in the same partition, which allows for efficient queries based on office.\nThe sort key on the employee name enables sorting employees alphabetically within each office partition, which is exactly the desired functionality.","comments":[{"upvote_count":"2","content":"B) Eliminated: Using employee name as the partition key means that items (employees) will be distributed across multiple partitions based on the employee name, which is not ideal for the most frequent query.","comments":[{"poster":"sumanshu","upvote_count":"2","comments":[{"upvote_count":"2","timestamp":"1734268980.0","comment_id":"1326870","content":"D) Eliminated: Using the office identifier as the partition key means that all employees in the same office will be stored in the same partition, which is efficient for filtering by office.\nHowever, this design does not allow for sorting by employee name within each office. Sorting would require a separate operation, adding unnecessary complexity and performance overhead.","poster":"sumanshu"}],"timestamp":"1734268980.0","content":"C) Eliminated: This design only uses the employee name as the partition key, which would not allow for efficient querying of employees by office.","comment_id":"1326869"}],"comment_id":"1326868","timestamp":"1734268920.0","poster":"sumanshu"}]},{"comment_id":"1310467","content":"Selected Answer: A\nPartition Key on Office Identifier: This ensures that all employees from the same office are stored together, which is efficient for querying by office.\n\nSort Key on Employee Name: This allows you to retrieve employees in alphabetical order within each office, which matches the query requirements.","timestamp":"1731395460.0","poster":"JonasKahnwald","upvote_count":"2"},{"timestamp":"1730099640.0","poster":"thucta96dn","upvote_count":"1","comment_id":"1303858","content":"Selected Answer: B\npartition key should be employee name","comments":[]},{"poster":"trainee46","comment_id":"1288030","content":"Selected Answer: A\nDefinately A. \nIf the name were the partition key, but we need an alphabetical range, e.g. all names starting with C-G, the it would be completeley impossbile to write a queasonable query for that the does not a full scan. \nIf the office name is the partition key, then we can query for the speciifc office and sort by last name, thus easily selecting a range of last names such as in my example.\n\nGeneral rule: The partition key must be known when writing querying the database. Thi isa certianly true for the offices, but in the sketched scenario not for the names.","timestamp":"1727078580.0","upvote_count":"1"},{"timestamp":"1707106920.0","comment_id":"1140668","upvote_count":"1","content":"Selected Answer: A\nThe design has to be driven by requirement. The queries would be select ones based on an office and then on employees in the office. So I feel the part key should be office id, and the sort key emp name.","poster":"SD_CS"},{"timestamp":"1705513260.0","poster":"gilleep_17","content":"not sure but A","comment_id":"1125179","upvote_count":"1"},{"timestamp":"1705273140.0","content":"Selected Answer: A\nminimum performance impact is in answer A , for answer B in partition key employee name is not good choice as many employees can have same name","poster":"AsmaZoheb","upvote_count":"1","comment_id":"1122941"},{"upvote_count":"2","content":"Selected Answer: A\nThe design of the DynamoDB table primary key that will have the minimum performance impact is:\n\nA. Partition key on the office identifier and sort key on the employee name\n\nRationale:\n\nThe most frequent query is to extract a report of an alphabetical subset of employees for a specific office.\n\nWith the office identifier as the partition key, all employees belonging to that office will be stored together in the same partition. This query can retrieve the required data from a single partition efficiently.\n\nUsing the employee name as the sort key allows sorting the results alphabetically as required by the query.\n\nThis design matches the access pattern of the query by grouping related data together in a partition while also enabling the sorting of results.\n\nOther designs may result in data for the same office being stored across multiple partitions, impacting performance for this common query pattern.","poster":"xdkonorek2","timestamp":"1701776520.0","comment_id":"1088436"},{"poster":"ninomfr64","content":"Selected Answer: B\nTricky question. Best practice tells us to use employee name as partition key as it has higher cardinality, however the most frequent query extracts employees for a specific office thus ideally the query KeyConditionExpression would be \"officeID = office123\". If performance is the primary concern I would go for a primary key with partition key on the employee name and sort key on the office identifier and having a GSI with partition key on the office identifier, thus B.","upvote_count":"1","comment_id":"988316","timestamp":"1692793800.0"},{"content":"Another tricky question this time I won't vote because I'm torn between A and B.\nMost of you says A but why do you exclude the B? As far as I know an employee table in DynamoDB should be designed to avoid hot partitions and design the partition key in order to distribuite the data accross all the table, even if we query by officeID. Let us imagine that the company has only 6 offices and hundreds of employees it will be a mass to maintain the table and most of times it will be throttled.\nSo, in my opinion is: \"B - Create a partition key on the employee name and sort key on the office identifier\"","upvote_count":"2","timestamp":"1687882380.0","poster":"rcaliandro","comment_id":"935584"},{"upvote_count":"1","content":"Selected Answer: A\nThis design allows to query for a specific office identifier and return the results sorted by employee name in alphabetical order.","poster":"MrTee","timestamp":"1682222700.0","comment_id":"877849"},{"poster":"piavik","comment_id":"864202","upvote_count":"2","content":"Unclear question \nMINIMUM performance impact (i.e. LESS possible performance boost) will be with C.\n\"A\" will give MAXIMUM performance impact.","timestamp":"1680897420.0"},{"poster":"nearavenac","upvote_count":"1","comment_id":"862566","content":"Selected Answer: C\nC have the MINIMUM performance impact","timestamp":"1680737040.0"},{"content":"Selected Answer: B\nAlso went with employee as it would provide highest cardinality!","poster":"Dr_Chomp","upvote_count":"1","comment_id":"860481","timestamp":"1680566520.0"},{"comment_id":"839916","upvote_count":"2","timestamp":"1678887240.0","content":"What does \"MINIMUM performance impact\" mean? IMO \"A\" is going to give the maximum performance impact and \"C\" the minimum","poster":"captainpike"},{"comment_id":"813145","content":"Selected Answer: A\nA is the right choice","timestamp":"1676732340.0","upvote_count":"1","poster":"ShriniW"},{"timestamp":"1676588580.0","poster":"QueTeddyJR","upvote_count":"2","content":"Selected Answer: A\nIts A. Partition on the office key and sort by the employee names.","comment_id":"811182"},{"upvote_count":"1","timestamp":"1676060940.0","comment_id":"804761","poster":"Krt5894","content":"Selected Answer: A\nVoting for A"},{"comment_id":"801112","timestamp":"1675786320.0","upvote_count":"1","content":"Selected Answer: A\nA is correct","poster":"Ashish_Mishra"},{"poster":"unbornfroyo","upvote_count":"6","timestamp":"1675300320.0","comment_id":"795655","content":"Selected Answer: A\nBy having the office identifier as the partition key, DynamoDB will distribute the data evenly across multiple partitions, allowing for efficient querying of data. Additionally, by having the employee name as the sort key, you can use the sort key to efficiently retrieve the alphabetical subset of employees for a specific office. This way, the query only needs to scan a smaller portion of the data, reducing the number of read operations and improving performance.\n\n Option B, having a composite primary key with a partition key on the employee name and a sort key on the office identifier, would be an inefficient approach as the queries would need to scan a large portion of the data to retrieve the required subset of employees."},{"content":"Definitely B - we don't want a hot partition if we're searching and most of the employees are in one office (say 3 offices with 90% being in NYC - NYC as a partition would give us a hot partition)","timestamp":"1674218640.0","poster":"BobAWS23","comment_id":"782225","upvote_count":"2"},{"upvote_count":"2","timestamp":"1674089460.0","poster":"Phinx","comment_id":"780600","content":"Selected Answer: B\nI think the keyword here is the last question \"Which design of the DynamoDB table primary key will have the MINIMUM performance impact?\". Minimum impact is required. You must use an attribute with high cardinality which in this case is the Employee name. So I think it's B."},{"upvote_count":"1","content":"Selected Answer: A\nhttps://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html\nThe Query operation in Amazon DynamoDB finds items based on primary key values.","poster":"Dirisme","comment_id":"767979","timestamp":"1673030880.0"},{"content":"Selected Answer: C\nThe answer should be C. Because we should find the MINIMUM IMPACT on the primary key. So, we should find the worst case.","poster":"efex","comment_id":"765212","timestamp":"1672804500.0","upvote_count":"1"},{"timestamp":"1671463860.0","poster":"tieyua","upvote_count":"2","comments":[{"poster":"tieyua","comment_id":"765034","upvote_count":"1","timestamp":"1672778700.0","content":"Nevermind, back to A. Key condition is equal only, so has to query by office and sort by name. \n\nThat headquarter partition must be smoking!!!"}],"content":"Partition by employee is a given, don't second guess. The keyword of this question is \"alphabetical subset of employees for a specific office\". You query with key condition A-C, filter expression office='xyz'","comment_id":"749987"},{"comment_id":"720100","content":"Selected Answer: A\nit's A. \n\noffice is the unique identifier so it's the partion key and it's A. imagine if this were a movie listing, the movie id would be the partion and the thousands of employees would be sort key. you'll get a hot partion but using employees instead of movie id as partion key makes no sense","poster":"dark_cherrymon","timestamp":"1668645360.0","upvote_count":"1"},{"timestamp":"1667953800.0","comment_id":"714171","upvote_count":"3","poster":"cloud_collector","content":"Selected Answer: A\n\"extracts a report of an alphabetical subset of employees for a specific office\"\nPartition key on the office identifier \nSort key on the employee name"},{"comment_id":"711747","poster":"rakb456","content":"It's A.\nFrom https://aws.amazon.com/tw/premiumsupport/knowledge-center/primary-key-dynamodb-table/\n\nComposite primary key: This is a combination of partition key and sort key. If the table has a composite primary key, then two items might have the same partition key value. However, those items must have different sort key values.\n\nsame partition key value :Office identifier\ndifferent sort key values: employee name","timestamp":"1667651940.0","upvote_count":"2"},{"upvote_count":"3","poster":"tbhtp","comment_id":"703884","timestamp":"1666702920.0","content":"Selected Answer: B\nIt is frankly confusing that the partition key and sort key form a primary key that influences partitioning to some extend. But be careful. In most cases, where 10GB are not exceeded, the sort key does NOT influence partitioning. Hence the partition key only will decide the physical partition which will most likely result in a hot partition.\n\nThis article will help: https://aws.amazon.com/blogs/database/choosing-the-right-dynamodb-partition-key/"},{"upvote_count":"2","timestamp":"1664452860.0","comment_id":"682644","poster":"habros","content":"Treating sort key as a composite key, high cardinality, A.\nPartition key for department, sort key for employee"},{"comments":[{"timestamp":"1664144280.0","upvote_count":"3","content":"Should be A, due to https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-sort-keys.html\n\"In an Amazon DynamoDB table, the primary key that uniquely identifies each item in the table can be composed not only of a partition key, but also of a sort key.\"\nIt acts as kind of a composite key, so you will still have the cardinality","comments":[{"upvote_count":"1","comment_id":"703886","poster":"tbhtp","timestamp":"1666703040.0","content":"Not entirely true. Mind the 10GB condition. This will help: https://aws.amazon.com/blogs/database/choosing-the-right-dynamodb-partition-key/"}],"comment_id":"679251","poster":"tfer"},{"comment_id":"682743","content":"Totally agree. I vote for B.\n\nPartition key must be \"as random as possible\" (high cardinality value). The more \"random\" it is, the less propability that a partition becomes \"hot\" because all read actions goes to that partition.\n\nSo, if you have, lets say, 4 companies and 200 employees, then you have only 4 partitions for companies, but 200 for names.\n\n\"DynamoDB uses the partition key’s value as an input to an internal hash function. The output from the hash function determines the partition in which the item is stored. Each item’s location is determined by the hash value of its partition key.\"","upvote_count":"2","poster":"SuperPiski","timestamp":"1664459220.0"}],"content":"B You want to \"use a high-cardinality value for your partition key.\" https://aws.amazon.com/blogs/database/choosing-the-right-dynamodb-partition-key/","upvote_count":"3","poster":"Gene_Poole","comment_id":"672345","timestamp":"1663504140.0"},{"poster":"mekcoll","content":"why not A?","upvote_count":"1","comment_id":"659390","timestamp":"1662309000.0"},{"timestamp":"1662283680.0","comment_id":"659144","poster":"Danbraga","content":"Selected Answer: A\nA. you need the partition key to be office, since you are extracting a list of employers by office","upvote_count":"4"},{"poster":"ADI2608","upvote_count":"2","timestamp":"1662234420.0","comment_id":"658785","content":"Its A."},{"content":"Selected Answer: B\nIt was B ?","poster":"sidvic","upvote_count":"2","comment_id":"658176","timestamp":"1662189960.0"}],"topic":"1","question_text":"A company that has multiple offices uses an Amazon DynamoDB table to store employee payroll information. Item attributes consist of employee names, office identifiers, and cumulative daily hours worked The most frequently used query extracts a report of an alphabetical subset of employees for a specific office.\nWhich design of the DynamoDB table primary key will have the MINIMUM performance impact?","exam_id":25,"unix_timestamp":1662189960,"timestamp":"2022-09-03 09:26:00"}],"exam":{"isBeta":false,"provider":"Amazon","lastUpdated":"11 Apr 2025","name":"AWS Certified Developer Associate","isMCOnly":true,"isImplemented":true,"id":25,"numberOfQuestions":443},"currentPage":18},"__N_SSP":true}