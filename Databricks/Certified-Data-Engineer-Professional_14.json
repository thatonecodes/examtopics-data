{"pageProps":{"questions":[{"id":"J4ES6Y9oBmN6AfxQugWe","timestamp":"2024-07-20 11:49:00","discussion":[{"poster":"vexor3","content":"Selected Answer: B\nB is correct","comment_id":"1251670","upvote_count":"2","timestamp":"1721468940.0"}],"question_images":["https://img.examtopics.com/certified-data-engineer-professional/image69.png"],"topic":"1","unix_timestamp":1721468940,"isMC":true,"url":"https://www.examtopics.com/discussions/databricks/view/144263-exam-certified-data-engineer-professional-topic-1-question/","answer_description":"","answer_images":[],"answers_community":["B (100%)"],"answer_ET":"B","question_id":66,"exam_id":163,"choices":{"C":"The write will insert all records except those that violate the table constraints; the violating records will be recorded to a quarantine table.","B":"The write will fail completely because of the constraint violation and no records will be inserted into the target table.","D":"The write will include all records in the target table; any violations will be indicated in the boolean column named valid_coordinates.","A":"The write will insert all records except those that violate the table constraints; the violating records will be reported in a warning log."},"question_text":"A CHECK constraint has been successfully added to the Delta table named activity_details using the following logic:\n\n//IMG//\n\n\nA batch job is attempting to insert new records to the table, including a record where latitude = 45.50 and longitude = 212.67.\n\nWhich statement describes the outcome of this batch insert?","answer":"B"},{"id":"Hr4Dz89YlXSHYdrmYbUi","url":"https://www.examtopics.com/discussions/databricks/view/142397-exam-certified-data-engineer-professional-topic-1-question/","isMC":true,"answer_images":[],"question_text":"A junior data engineer is migrating a workload from a relational database system to the Databricks Lakehouse. The source system uses a star schema, leveraging foreign key constraints and multi-table inserts to validate records on write.\n\nWhich consideration will impact the decisions made by the engineer while migrating this workload?","answer_ET":"D","discussion":[{"content":"Selected Answer: D\nYes, D is correct, not enforced","comment_id":"1366220","upvote_count":"1","poster":"lakime","timestamp":"1741344720.0"},{"comment_id":"1341657","upvote_count":"1","content":"Selected Answer: D\nD is correct as primary and foreign keys are informational only and are not enforced in databricks https://learn.microsoft.com/en-us/azure/databricks/tables/constraints","timestamp":"1737026460.0","poster":"RandomForest"},{"content":"Selected Answer: D\nD is correct","comment_id":"1229315","timestamp":"1718209920.0","poster":"hpkr","upvote_count":"3"}],"answers_community":["D (100%)"],"exam_id":163,"question_id":67,"timestamp":"2024-06-12 18:32:00","question_images":[],"answer_description":"","unix_timestamp":1718209920,"topic":"1","answer":"D","choices":{"B":"Foreign keys must reference a primary key field; multi-table inserts must leverage Delta Lakeâ€™s upsert functionality.","A":"Databricks only allows foreign key constraints on hashed identifiers, which avoid collisions in highly-parallel writes.","D":"All Delta Lake transactions are ACID compliant against a single table, and Databricks does not enforce foreign key constraints.","C":"Committing to multiple tables simultaneously requires taking out multiple table locks and can lead to a state of deadlock."}},{"id":"CLxwEQov5ZRylfNY7np3","answer_ET":"B","question_images":["https://img.examtopics.com/certified-data-engineer-professional/image10.png"],"url":"https://www.examtopics.com/discussions/databricks/view/117078-exam-certified-data-engineer-professional-topic-1-question/","unix_timestamp":1690966020,"answer_description":"","answer_images":[],"topic":"1","question_text":"A table is registered with the following code:\n//IMG//\n\nBoth users and orders are Delta Lake tables. Which statement describes the results of querying recent_orders?","isMC":true,"discussion":[{"comment_id":"969950","poster":"asmayassineg","timestamp":"1690966020.0","upvote_count":"18","content":"Correct answer is B. table is created and data of join will be stored on DBFS and it will be returned on query time"},{"comment_id":"1267921","timestamp":"1723952040.0","comments":[{"content":"Not sure how so many people misunderstood the actual question. It already says at the top that the table is registered as the code given, they're not executing the code again.","upvote_count":"3","timestamp":"1724176440.0","comment_id":"1269628","poster":"fe3b2fc"},{"timestamp":"1725308880.0","content":"Why are people so fixed on how the table was created, question says what happens when a query is run against the table.","comments":[{"comment_id":"1335187","timestamp":"1735734420.0","content":"As Benni_ale said - CTAS can be used to create a snapshot of a table. The data will be stored and not updated further, unless table is explicitly updated.","poster":"HairyTorso","upvote_count":"1"},{"comment_id":"1302795","poster":"benni_ale","upvote_count":"4","timestamp":"1729840800.0","content":"option D mentions \"return the result of joining the valid versions of the source tables\" but that's not true. when u interrogate the table resulting from a join of two tables u are not re-performing joins operations at query time anymore an the version is the one from the last time the CTAS statement was executed"}],"upvote_count":"2","comment_id":"1277008","poster":"Onobhas01"}],"poster":"practicioner","upvote_count":"18","content":"Selected Answer: D\nThe question says \"Which statement describes the results of querying recent_orders?\"\n\nThe question doesn't ask about the code snipped itself. This question is about the logic of \"select * from recent_orders\" after the creation of recent_orders.\n\nanswer is D\n\nD is the right answer"},{"upvote_count":"1","content":"Selected Answer: D\nIt's CTAAS, nothing is being stored in DBFS...","timestamp":"1742804820.0","comment_id":"1409598","poster":"lakime"},{"timestamp":"1740622320.0","content":"Selected Answer: B\nIt's CTAS. So snapshot at the time of creation will be returned.","comment_id":"1362380","upvote_count":"1","poster":"Tedet"},{"upvote_count":"2","comment_id":"1360165","poster":"ptty","content":"Selected Answer: B\nIt's B because this is different from creating a view (which would use CREATE VIEW instead), where the query logic would be executed each time the view is accessed.","timestamp":"1740238980.0"},{"content":"Selected Answer: B\nB - it is a table.\n\nQuery time answers assume we are talking about a view, which we aren't. Table is not automatically updated whenever the tables used in CTAS change - it is a standalone entity.","poster":"arekm","upvote_count":"1","timestamp":"1735645620.0","comment_id":"1334761"},{"comment_id":"1325428","upvote_count":"1","timestamp":"1733984400.0","poster":"Sriramiyer92","content":"Selected Answer: B\nThe answer is B.\nPls note it is CTAS statement and not a subquery."},{"content":"Selected Answer: B\nOnly logic there is inside create statemetn and it will execute once while executing \"create table\" statement. Further select queries will only select any data that was inserted during create table statement , data wont by updated automatically. So B","timestamp":"1729493400.0","poster":"nedlo","comment_id":"1300787","upvote_count":"1"},{"comment_id":"1298701","upvote_count":"1","timestamp":"1729079340.0","poster":"benni_ale","content":"i think B"},{"poster":"benni_ale","content":"Selected Answer: B\ni picked b","comment_id":"1297480","timestamp":"1728903480.0","upvote_count":"1"},{"upvote_count":"2","content":"Selected Answer: B\nCTAS statements persist it results, so B","poster":"Isio05","comment_id":"1226602","timestamp":"1717830420.0"},{"timestamp":"1717211100.0","comment_id":"1222461","content":"B. All logic will execute when the table is defined and store the result of joining tables to the DBFS; this stored data will be returned when the table is queried.","upvote_count":"2","poster":"imatheushenrique"},{"upvote_count":"2","timestamp":"1716135240.0","comment_id":"1213873","content":"Selected Answer: B\n\"Create Table\" is an action so \"B\"","poster":"coercion"},{"comment_id":"1145238","content":"B is correct","upvote_count":"1","timestamp":"1707453840.0","poster":"PrashantTiwari"},{"upvote_count":"1","timestamp":"1704893640.0","poster":"kz_data","comment_id":"1118588","content":"Selected Answer: B\nI think B is the correct answer"},{"content":"Selected Answer: B\nB is correct. Views compute when query is executed, not when defined. And vice versa for tables.","comment_id":"1117208","upvote_count":"1","poster":"IWantCerts","timestamp":"1704774360.0"},{"comment_id":"1114351","content":"Selected Answer: B\nKey here is that option D says \"returned\". The CTAS statement does not return results, thus option B is correct.","poster":"cryptoflam","upvote_count":"1","timestamp":"1704443700.0"},{"content":"Selected Answer: B\nThe correct answer is:\n\nB. All logic will execute when the table is defined and store the result of joining tables to the DBFS; this stored data will be returned when the table is queried.\n\nWhen the CREATE TABLE AS statement is executed, it runs the enclosed SELECT statement immediately to pull the current data from the users and orders tables where the order_date is within the last 7 days. This result is then stored as a new table called recent_orders in the Delta Lake on the DBFS (Databricks File System). Subsequent queries against recent_orders will return this stored data, and not recompute the join unless the table is updated or refreshed.","comment_id":"1075942","poster":"aragorn_brego","timestamp":"1700524920.0","upvote_count":"2"},{"content":"Selected Answer: B\nCorrect is B . CTAS command","timestamp":"1698951000.0","comment_id":"1060806","poster":"BIKRAM063","upvote_count":"3"},{"upvote_count":"1","timestamp":"1697009460.0","poster":"sturcu","content":"Selected Answer: B\nCreating a table will not display results.\nYou need to make a select alter it is created.","comment_id":"1040304"},{"content":"Based on typical Delta Lake behavior, option D is the most accurate description. Delta Lake queries generally execute at query time and retur\nn results based on the state of the source tables at the time the query began. Delta Lake provides features for managing data versions and transactions, but it doesn't precompute and store results like option B or cache results like option C.","timestamp":"1695389640.0","poster":"Santitoxic","comments":[{"comment_id":"1038968","upvote_count":"3","timestamp":"1696881060.0","poster":"Starvosxant","content":"No. Simple no.\nWhen you execute a create table even with a Join you DONT see the results imediatly unless you query the table. \nSo correct answer is B. The create table statement by default creates a Managed table, which is stored in DBFS."},{"upvote_count":"1","content":"Its create separate delta lake transaction logs for this new table. So B is the correct the answer.","poster":"Naveenkm","timestamp":"1701073140.0","comment_id":"1081308"}],"comment_id":"1014147","upvote_count":"1"},{"upvote_count":"2","comment_id":"1004023","content":"Selected Answer: B\ncorrect is B","timestamp":"1694353500.0","poster":"lucasasterio"},{"content":"Aa ok, I missed \"logic will execute at query time\" ignore my previous comment","comment_id":"988303","timestamp":"1692793500.0","poster":"robson90","upvote_count":"2"},{"upvote_count":"1","content":"Why not D? Table does not need to be stored on DBFS if using Unity Catalog. At least that's my understanding https://docs.databricks.com/en/dbfs/unity-catalog.html","comments":[{"poster":"Melik3","comment_id":"1261383","content":"D is saying that the when you query this new table the join will be executed which is wrong. this join is only executed once when creating the table and then the results are stored. When you query again the Table, the stored data will be used and not the join again.","upvote_count":"1","timestamp":"1722916260.0"}],"poster":"robson90","timestamp":"1692793380.0","comment_id":"988299"},{"upvote_count":"4","content":"correct answer is B","poster":"BrianNguyen95","timestamp":"1692273240.0","comment_id":"983570"}],"exam_id":163,"answers_community":["B (55%)","D (45%)"],"question_id":68,"answer":"B","timestamp":"2023-08-02 10:47:00","choices":{"A":"All logic will execute at query time and return the result of joining the valid versions of the source tables at the time the query finishes.","B":"All logic will execute when the table is defined and store the result of joining tables to the DBFS; this stored data will be returned when the table is queried.","E":"The versions of each source table will be stored in the table transaction log; query results will be saved to DBFS with each query.","C":"Results will be computed and cached when the table is defined; these cached results will incrementally update as new records are inserted into source tables.","D":"All logic will execute at query time and return the result of joining the valid versions of the source tables at the time the query began."}},{"id":"ijJAo4zKLjRIVcGS1dyq","topic":"1","answer_description":"","choices":{"D":"Delta Lake time travel does not scale well in cost or latency to provide a long-term versioning solution.","B":"Shallow clones can be combined with Type 1 tables to accelerate historic queries for long-term versioning.","C":"Delta Lake time travel cannot be used to query previous versions of these tables because Type 1 changes modify data files in place.","A":"Data corruption can occur if a query fails in a partially completed state because Type 2 tables require setting multiple fields in a single update."},"answers_community":["D (100%)"],"answer_ET":"D","answer_images":[],"url":"https://www.examtopics.com/discussions/databricks/view/142398-exam-certified-data-engineer-professional-topic-1-question/","exam_id":163,"question_id":69,"unix_timestamp":1718209920,"discussion":[{"poster":"hpkr","upvote_count":"3","comment_id":"1229317","timestamp":"1718209920.0","content":"Selected Answer: D\ncorrect answer - D"}],"isMC":true,"answer":"D","question_images":[],"timestamp":"2024-06-12 18:32:00","question_text":"A data architect has heard about Delta Lakeâ€™s built-in versioning and time travel capabilities. For auditing purposes, they have a requirement to maintain a full record of all valid street addresses as they appear in the customers table.\n\nThe architect is interested in implementing a Type 1 table, overwriting existing records with new values and relying on Delta Lake time travel to support long-term auditing. A data engineer on the project feels that a Type 2 table will provide better performance and scalability.\n\nWhich piece of information is critical to this decision?"},{"id":"oXEkWwwf3UP2Rllio0jH","url":"https://www.examtopics.com/discussions/databricks/view/149882-exam-certified-data-engineer-professional-topic-1-question/","exam_id":163,"timestamp":"2024-10-20 19:00:00","answer_ET":"A","answer":"A","discussion":[{"upvote_count":"2","content":"Selected Answer: A\nAnswer A is the only possible logically.\nB configures clickTime to be earlier than impressionTime\nC says that clickTime should be the same as impressionTime with all clicks left joined to impressions\nD wants to remove Watermarks which will lead to memory leaks and depletion for both streams staging/aggregation purposes by Spark","comment_id":"1300588","poster":"m79590530","timestamp":"1729443600.0"}],"topic":"1","answer_description":"","question_id":70,"unix_timestamp":1729443600,"isMC":true,"answers_community":["A (100%)"],"question_text":"A data engineer wants to join a stream of advertisement impressions (when an ad was shown) with another stream of user clicks on advertisements to correlate when impressions led to monetizable clicks.\n\nIn the code below, Impressions is a streaming DataFrame with a watermark (\"event_time\", \"10 minutes\")\n\n//IMG//\n\n\nThe data engineer notices the query slowing down significantly.\n\nWhich solution would improve the performance?","choices":{"D":"Joining on event time constraint: clickTime >= impressionTime - interval 3 hours and removing watermarks","B":"Joining on event time constraint: clickTime + 3 hours < impressionTime - 2 hours","A":"Joining on event time constraint: clickTime >= impressionTime AND clickTime <= impressionTime interval 1 hour","C":"Joining on event time constraint: clickTime == impressionTime using a leftOuter join"},"answer_images":[],"question_images":["https://img.examtopics.com/certified-data-engineer-professional/image70.png"]}],"exam":{"numberOfQuestions":200,"isBeta":false,"isMCOnly":true,"isImplemented":true,"id":163,"provider":"Databricks","name":"Certified Data Engineer Professional","lastUpdated":"12 Apr 2025"},"currentPage":14},"__N_SSP":true}