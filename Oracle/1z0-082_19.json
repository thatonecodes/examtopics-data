{"pageProps":{"questions":[{"id":"diqQlxHb9I1x8pkWaXHE","question_id":91,"topic":"1","unix_timestamp":1594837680,"answers_community":["BE (100%)"],"exam_id":380,"answer_description":"","answer":"BE","isMC":true,"answer_ET":"BE","answer_images":[],"timestamp":"2020-07-15 20:28:00","discussion":[{"timestamp":"1626373680.0","comment_id":"135953","comments":[{"upvote_count":"1","comment_id":"242276","timestamp":"1639375500.0","poster":"Ekos","content":"yes, agree"}],"upvote_count":"14","poster":"Rivaldo11","content":"Should be B and E. A is not correct - \"...LREG registers database services with all local and remote listeners...\", in 12c and higher versions."},{"upvote_count":"6","poster":"Datajimm","content":"Selected Answer: BE\na) is done by LREG\nb) is done by PMON process group\nc) is done by CKPT\nd) is done by SMON\ne) is done by PMON process group","timestamp":"1678025100.0","comment_id":"561462"},{"content":"Selected Answer: BE\nA - FALSE; LREG\nB - TRUE; Release 19, Database Concepts, 15 Process Architecture, Process Monitor Process (PMON) Group: The process monitor (PMON) detects the termination of other background processes. If a server or dispatcher process terminates abnormally, then the PMON group is responsible for performing process recovery. \nC - FALSE; CKPT\nD - FALSE; SMON\nE - TRUE; Release 19, Database Concepts, 15 Process Architecture, Process Monitor Process (PMON) Group: CLMN periodically performs cleanup of terminated processes, ... and detached network connections that have exceeded their idle timeout.","upvote_count":"1","timestamp":"1726810680.0","comment_id":"1011945","poster":"nautil2"},{"timestamp":"1689698700.0","content":"Selected Answer: BE\nB and E is correct.","poster":"LeandroHPN","upvote_count":"1","comment_id":"633093"},{"content":"B,E is correct","poster":"ryuah","comment_id":"520188","timestamp":"1673267400.0","upvote_count":"1"},{"poster":"abebeW","upvote_count":"1","comments":[{"content":"1z0-082 for Oracle Database 12cR2 or higher. agree with answering B & E. \nanswering A (register database) for Oracle 11g or lower version.","comments":[{"comment_id":"432365","poster":"leozanon94","upvote_count":"1","content":"We have to consider that the question is on PMON process and not PMON group (with PMON process, CLMN process and CLnn)\n\nhttps://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/process-architecture.html#GUID-B5CA9579-53DB-442C-A85F-F21FD334833A\n\nSo i think E is wrong for this reason.\nThe answer B is right.\nAnswer A could be right or wrong depending by Oracle version.\n\nFor me correct answers are: A, B and I think that this is an old question referenced to an old Oracle version (<= 12cR1). Idk.\nMaybe during the exam the answers will be different.","timestamp":"1661520840.0"}],"timestamp":"1661401740.0","comment_id":"431132","upvote_count":"1","poster":"LrnsTgh"}],"content":"AB\nhttps://docs.oracle.com/cd/B19306_01/server.102/b14220/process.htm","comment_id":"378730","timestamp":"1654837080.0"},{"comment_id":"150157","upvote_count":"1","content":"AE is Answer\n\n• Performs process recovery when a user process fails\n– Cleans up the database buffer cache\n– Frees resources that are used by the user process\n• Monitors sessions for idle session timeout","comments":[{"upvote_count":"6","comment_id":"150158","timestamp":"1628050140.0","comments":[{"content":"Correct, Answer is BE.","comment_id":"163830","upvote_count":"3","timestamp":"1629658080.0","poster":"avanand"}],"content":"sorry i mean BE","poster":"Muhab"}],"poster":"Muhab","timestamp":"1628050020.0"}],"question_text":"Which two statements are true about the PMON background process? (Choose two.)","choices":{"B":"It frees resources held by abnormally terminated processes","A":"It registers database services with all local and remote listeners known to the database instance","C":"It records checkpoint information in the control file","E":"It kills sessions that exceed idle time","D":"It frees unused temporary segments"},"url":"https://www.examtopics.com/discussions/oracle/view/25837-exam-1z0-082-topic-1-question-25-discussion/","question_images":[]},{"id":"en40ZD999pAClZkh9zS0","answer":"ADF","question_id":92,"unix_timestamp":1590992460,"answers_community":["ADF (43%)","AD (21%)","14%","Other"],"timestamp":"2020-06-01 08:21:00","answer_images":[],"question_images":[],"discussion":[{"poster":"dotruonghan","content":"ADE should be correct\nhttps://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/transactions.html#GUID-7690181F-8293-47B9-ADC1-905BD9C3AF57\n• A transaction begins when the first executable SQL statement is encountered. An executable SQL statement is a SQL statement that generates calls to a database instance, including DML and DDL statements and the SET TRANSACTION statement.\n• A transaction ends when any of the following actions occurs:\no A user issues a COMMIT or ROLLBACK statement without a SAVEPOINT clause.  Answer D\no A user runs a DDL command such as CREATE, DROP, RENAME, or ALTER. The database issues an implicit COMMIT statement before and after every DDL statement. If the current transaction contains DML statements, then Oracle Database first commits the transaction and then runs and commits the DDL statement as a new, single-statement transaction.\no SELECT do not have a transaction start/end. Check by command: SELECT XID AS \"txn id\", XIDUSN AS \"undo seg\", XIDSLOT AS \"slot\", XIDSQN AS \"seq\", STATUS AS \"txn status\" FROM V$TRANSACTION;","upvote_count":"18","comments":[{"timestamp":"1714183740.0","comment_id":"1202920","poster":"valiantvimal","content":"Thanks for the details. I agree with you. Just for additional info I would like to add from the same reference that you have given that SELECT query is not considered a Transaction (it is mentioned in 2 of the answer options in the question).","upvote_count":"1"},{"comment_id":"240458","upvote_count":"1","timestamp":"1607636280.0","poster":"SimoneF","content":"Spot on, I agree"}],"comment_id":"143563","timestamp":"1595697120.0"},{"poster":"you1234","comments":[{"comment_id":"128680","comments":[{"poster":"Marcello86CT","upvote_count":"3","comment_id":"624215","timestamp":"1656446760.0","content":"DDL should just close the transaction with an implicit COMMIT. In this case the question is asking when a Transaction START , no when is COMPLETED or CLOSED. So my opinion is that:\n\nA Is correct , DML after a DDL\nB not correct, TRUNACATE is a DDL and is executed after a select that is not a DML.\nC not correct for the same reason of B\nD is Correct because we have a DML after a commit so after the end of a transaction.\nE is not Correct : DDL after DDL\nF is correct : https://oracle-base.com/articles/10g/dml-error-logging-10gr2\nBy default, when a DML statement fails the whole statement is rolled back, regardless of how many rows were processed successfully before the error was detected."}],"poster":"ama","timestamp":"1594104000.0","upvote_count":"5","content":"why not A, D; E?"}],"upvote_count":"12","content":"A & D & F is correct answer","timestamp":"1593501660.0","comment_id":"123312"},{"content":"Selected Answer: ADF\n. When issuing a SELECT FOR UPDATE statement after a CREATE TABLE AS SELECT statement was issued in the same session\n\nThe SELECT FOR UPDATE statement explicitly locks rows for update, initiating a new transaction.\n\nD. When issuing the first Data Manipulation Language (DML) statement after a COMMIT OR ROLLBACK statement was issued in the same session\n\nA new transaction starts with the first DML statement (INSERT, UPDATE, DELETE) after a COMMIT or ROLLBACK, as these statements finalize the previous transaction.\n\nF. When issuing a DML statement after a DML statement failed in the same session\n\nA new transaction begins when a DML statement is issued after a previous DML statement failed, as the failure would have caused the transaction to end.","comment_id":"1344146","upvote_count":"1","timestamp":"1737463620.0","poster":"OrhiDee68"},{"content":"Selected Answer: ADF\nPay attention that the question is about starting a new transaction and not ending the transaction.\n--------\nTrue:\n--------\nA. A SELECT FOR UPDATE statement acquires locks on the selected rows, which requires a transaction. If a new transaction has not already started, this will initiate a new transaction.\nD. After a COMMIT or ROLLBACK, any subsequent DML statement (INSERT, UPDATE, DELETE, etc.) will start a new transaction.\nF. If a DML statement fails and causes an implicit rollback, any subsequent DML statement will start a new transaction.\n---------\nFalse:\n----------\nB. A TRUNCATE statement is a DDL operation that implicitly commits the current transaction, then starts and ends the transaction it creates because of the implicit commit.\nC. A CREATE TABLE statement is a DDL operation that implicitly commits the current transaction, then starts and ends the transaction it creates because of the implicit commit.\nE. CREATE INDEX statement is a DDL operation that implicitly commits the current transaction, then starts and ends the transaction it creates because of the implicit commit.","upvote_count":"2","poster":"icy3","comment_id":"1254079","timestamp":"1721791620.0"},{"comment_id":"1193544","content":"The correct answer is D,E,F\nThe situations in which a new transaction always starts are:\n\nD. When issuing the first Data Manipulation Language (DML) statement after a COMMIT OR ROLLBACK statement was issued in the same session. This is true because a COMMIT or ROLLBACK statement ends the current transaction, and the next DML statement starts a new transaction.\n\nE. When issuing a CREATE INDEX statement after a CREATE TABLE statement completed successfully in the same session. Creating an index involves a separate transaction from the creation of the table, so issuing a CREATE INDEX statement after a CREATE TABLE statement always starts a new transaction.\n\nF. When issuing a DML statement after a DML statement failed in the same session. If a DML statement fails, it does not affect the transactional state of the session, so issuing another DML statement afterward will start a new transaction.","timestamp":"1712821560.0","upvote_count":"1","poster":"ronie_23"},{"poster":"nautil2","upvote_count":"2","timestamp":"1695215940.0","comment_id":"1012350","content":"Selected Answer: BCE\nA - FALSE; SELECT FOR UPDATE locks table rows, but do not start a transaction \nB - TRUE; TRUNCATE is a single DDL command, so it starts a transaction\nC - TRUE; CREATE TABLE is a single DDL command, so it starts a transaction\nD - FALSE; typically, first DML command issued after COMMIT/ROLLBACK starts a transaction but it is not generally true. Only DML command that makes an atomic change in the database starts a transaction. \nE - TRUE; CREATE INDEX is a single DDL command, so it starts a transaction\nF - FALSE; DML statement does not start a new transaction when not preceeded by COMMIT, ROLLBACK, DDL statement or new session"},{"upvote_count":"1","comment_id":"981421","poster":"zouve","content":"Selected Answer: ADE\nthe CREATE INDEX statement is now listed in the table, which means that it does start a new transaction in Oracle 19c and later","timestamp":"1692087900.0"},{"content":"Selected Answer: ADF\nA D F\nE are two DDL statements after each other, each statement is a completed transaction, there is no active transaction after each statement. Since the question is asking when a new transaction starts E is incorrect since there is no active transaction after the two statements. Tested in Oracle.","poster":"musafir","upvote_count":"1","comment_id":"959225","timestamp":"1690005180.0"},{"timestamp":"1688392740.0","comment_id":"941902","content":"Selected Answer: ADF\nProvided answer are corrects!\n\nhttps://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/transactions.html#GUID-7690181F-8293-47B9-ADC1-905BD9C3AF57","upvote_count":"1","poster":"auwia","comments":[{"upvote_count":"1","timestamp":"1688584140.0","content":"A new transaction is always created after a DML statement is issued! Remember this! ;-)","comment_id":"944062","poster":"auwia"}]},{"timestamp":"1682417520.0","content":"Selected Answer: ACE\nA - tested\nC - DDL (always start new transaction)\nE - DDL (always start new transaction)","upvote_count":"1","poster":"RaNik69","comment_id":"880209"},{"content":"Selected Answer: ADE\nhttps://www.examtopics.com/discussions/oracle/view/10274-exam-1z0-071-topic-1-question-256-discussion/","poster":"ivanadj","comment_id":"838790","upvote_count":"1","timestamp":"1678794060.0"},{"comment_id":"778871","timestamp":"1673956860.0","upvote_count":"1","poster":"nautil2","content":"Selected Answer: ADF\nOracle 19c documentation states a DDL command is performed as a single-statement transaction. See paragraph \"End of a Transaction\" at https://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/transactions.html#GUID-510DF997-BA9C-4431-95EF-A0622881EC9C\nHowever if I am requested to choose three answers, I choose those options that causes transaction ID is assigned. It can be printed with exec dbms_output.put_line( dbms_transaction.local_transaction_id );\nI tried all options and only A, D, F returned non empty transaction ID."},{"timestamp":"1656445920.0","comment_id":"624208","upvote_count":"2","content":"Sorry Guys but i think that E is not Correct. Oracle shouldn't support Transactional DDL. DDL should just close the transaction with an implicit COMMIT. In this case the question is asking when a Transaction START , no when is COMPLETED or CLOSED. So my opinion is that:\n\nA Is correct , DML after a DDL\nB not correct, TRUNACATE is a DDL and is executed after a select that is not a DML.\nC not correct for the same reason of B\nD is Correct because we have a DML after a commit so after the end of a transaction.\nE is not Correct : DDL after DDL\nF is correct : https://oracle-base.com/articles/10g/dml-error-logging-10gr2\nBy default, when a DML statement fails the whole statement is rolled back, regardless of how many rows were processed successfully before the error was detected.\n\nThen i would say : A , D , F","poster":"Marcello86CT"},{"comment_id":"589165","upvote_count":"3","poster":"Franky_T","comments":[{"content":"Right with you","poster":"SantiBZ_07032022_1744","comment_id":"770551","timestamp":"1673276880.0","upvote_count":"1"},{"upvote_count":"1","comment_id":"957961","poster":"linhao","content":"F may be correct. First DML failed and the new transaction not start. The second DML start new transaction.","timestamp":"1689898980.0"}],"content":"Selected Answer: AD\nIssue again, only two possible answers here.\n\nA transaction implicitly begins with any operation that obtains a TX lock:\n - When a statement that modifies data is issued (DML ONLY)\n - When a SELECT ... FOR UPDATE statement is issued\n - When a transaction is explicitly started with a SET TRANSACTION statement or the DBMS_TRANSACTION package\n \nA is correct. A select for update clause obtains a transaction lock TX, which is one of the three conditions under which transactions will implicitly begin.\nB is wrong. A truncate statement is DDL, and DDL statements perform implicit commits after they are done. Commits ends transactions, they don't start them\nC is wrong. A create table statement is DDL, same issue as option B.\nD is correct. DML statements start transactions.\nE is wrong. A create index statement is DDL, same issue as option B and C.\nF is wrong. When a DML statement fails it does not end a transaction, only commit or rollback (implicit or explicit) can do this. New DML statements will simply continue in the context of the current transaction. This option is easily tested.","timestamp":"1650525300.0"},{"upvote_count":"2","poster":"ryuah","comment_id":"520203","content":"A,C,E is correct","timestamp":"1641734340.0"},{"poster":"ozan_a","upvote_count":"2","comment_id":"423811","content":"A. when issuing a SELECT FOR UPDATE statement after a CREATE TABLE AS SELECT statement was issued in the same session --> DDL auto commit + new transaction. true.\nB. when issuing a TRUNCATE statement after a SELECT statement was issued in the same session --> truncate doesn't start a transaction. wrong.\nC. when issuing a CREATE TABLE statement after a SELECT statement was issued in the same session --> whether have a transaction or not, a DDL always create a transaction. true.\nD. when issuing the first Data Manipulation Language (DML) statement after a COMMIT OR ROLLBACK statement was issued in the same session --> a select doesn't create a transaction. wrong.\nE. when issuing a CREATE INDEX statement after a CREATE TABLE statement completed successfully in the same session --> a DDL always create a transaction. true.\nF. when issuing a DML statement after a DML statement failed in the same session --> we need commit or rollback for a new transaction. wrong.\n\nAnswer : A,C,E","timestamp":"1628793240.0"},{"content":"A. when issuing a SELECT FOR UPDATE statement after a CREATE TABLE AS SELECT statement was issued in the same session --> DDL auto commit + new transaction. true.\nB. when issuing a TRUNCATE statement after a SELECT statement was issued in the same session --> truncate doesn't start a transaction. wrong.\nC. when issuing a CREATE TABLE statement after a SELECT statement was issued in the same session --> whether have a transaction or not, a DDL always create a transaction. true.\nD. when issuing the first Data Manipulation Language (DML) statement after a COMMIT OR ROLLBACK statement was issued in the same session --> a select doesn't create a transaction. wrong.\nE. when issuing a CREATE INDEX statement after a CREATE TABLE statement completed successfully in the same session --> a DDL always create a transaction. true.\nF. when issuing a DML statement after a DML statement failed in the same session --> we need commit or rollback for a new transaction. wrong.\n\nAnswer : A,C,E","timestamp":"1628793180.0","poster":"ozan_a","comment_id":"423809","upvote_count":"2"},{"comment_id":"330380","upvote_count":"2","timestamp":"1617801540.0","poster":"ioio","content":"C D E are correct\nC and E: Create Table and Create Index are DDL and a new single transaction is created anyway.\nD: when a DML issued when no transaction is still active, a new transaction will started\n\n\nSelect for update is not a DML\nTruncate is not starting a transaction\nif a DML fails, the transaction still remains active"},{"upvote_count":"1","comment_id":"319850","content":"E should be DDL after DDL , I don't konw what will happened? a new trans or not.","timestamp":"1616654460.0","poster":"Fan"},{"upvote_count":"3","content":"A,D,F is correct answer","poster":"saif_alrwiliy","comment_id":"161838","timestamp":"1597878480.0"},{"content":"the question is When does a new transaction start ? create table does start a new transaction.\nThe select is not a transaction agreed but Create table does start a new transaction.","comments":[{"content":"no, a new Transaction means that there was a previous Transaction ouccred in the same session","timestamp":"1597729800.0","poster":"ama","upvote_count":"1","comment_id":"160599"}],"poster":"Chansi","upvote_count":"1","comment_id":"157636","timestamp":"1597358040.0"},{"comments":[{"content":"C is not correct, beaucase a select is not a Transaction.","comments":[{"content":"except \"select update for\"","comment_id":"319846","upvote_count":"1","poster":"Fan","timestamp":"1616654220.0"}],"timestamp":"1597296420.0","comment_id":"156984","poster":"ama","upvote_count":"2"}],"content":"C is also correct.This is again something not clear.It just says when does a new transaction start . So all DDLs do that and there are three of them. So they are trying understand our DDL knowledge rather the DML as there are only two options for commit and Rollback.Thoughts?","comment_id":"152093","poster":"Chansi","timestamp":"1596736260.0","upvote_count":"1"},{"comment_id":"145511","timestamp":"1595918820.0","upvote_count":"2","poster":"ama","content":"well, the Situation described in F is not triggering a Rollback.\nas there is no implicit Rollback, i think there will be no new Transaction"},{"upvote_count":"1","poster":"husseinyounes","content":"E ?? it should be after an insert table to be correct??","timestamp":"1591871520.0","comments":[{"timestamp":"1591900860.0","upvote_count":"1","poster":"danito","comments":[{"timestamp":"1629866700.0","upvote_count":"1","comment_id":"431141","content":"this test 1z0-082 use Oracle 12cR2 or higher (especially 19c). 1z0-071 used oracle 12cR1 or lower and 1z0-062 used oracle 11g or lower","poster":"LrnsTgh"}],"comment_id":"108004","content":"https://www.examtopics.com/exams/oracle/1z0-071/view/26/ #256 I am not sure"}],"comment_id":"107619"},{"timestamp":"1590992460.0","comment_id":"99780","comments":[{"content":"yes, agree. A, D, and E is the correct answer","poster":"Ekos","timestamp":"1607839620.0","comment_id":"242277","upvote_count":"2"}],"upvote_count":"6","content":"A D E shoud be the correct answers","poster":"danito"}],"question_text":"In which three situations does a new transaction always start? (Choose three.)","url":"https://www.examtopics.com/discussions/oracle/view/21720-exam-1z0-082-topic-1-question-26-discussion/","answer_ET":"ADF","topic":"1","isMC":true,"answer_description":"","choices":{"E":"when issuing a CREATE INDEX statement after a CREATE TABLE statement completed successfully in the same session","D":"when issuing the first Data Manipulation Language (DML) statement after a COMMIT OR ROLLBACK statement was issued in the same session","B":"when issuing a TRUNCATE statement after a SELECT statement was issued in the same session","F":"when issuing a DML statement after a DML statement failed in the same session","C":"when issuing a CREATE TABLE statement after a SELECT statement was issued in the same session","A":"when issuing a SELECT FOR UPDATE statement after a CREATE TABLE AS SELECT statement was issued in the same session"},"exam_id":380},{"id":"Vs4b9QiLHTIPO6Qi1Tuy","exam_id":380,"topic":"1","isMC":true,"answer_ET":"E","discussion":[{"upvote_count":"8","poster":"Ekos","timestamp":"1639375740.0","comment_id":"242281","content":"E. MINUS"},{"comment_id":"1012370","timestamp":"1726839420.0","poster":"nautil2","content":"Selected Answer: E\nE is correct","upvote_count":"1"},{"timestamp":"1705493460.0","content":"Selected Answer: E\nhttps://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/The-UNION-ALL-INTERSECT-MINUS-Operators.html#GUID-B64FE747-586E-4513-945F-80CB197125EE","comment_id":"778885","upvote_count":"2","poster":"nautil2"},{"upvote_count":"2","timestamp":"1673270340.0","comment_id":"520204","poster":"ryuah","content":"E is correct"}],"choices":{"B":"UNION ALL","D":"SUBTRACT","E":"MINUS","A":"INTERSECT","C":"UNION"},"answer_description":"","answer":"E","answer_images":[],"question_images":["https://www.examtopics.com/assets/media/exam-media/04352/0001600001.png"],"question_text":"Examine the description of the SALES1 table:\n//IMG//\n\nSALES2 is a table with the same description as SALES1.\nSome sales data is duplicated in both tables.\nYou want to display the rows from the SALES1 table which are not present in the SALES2 table.\nWhich set operator generates the required output?","unix_timestamp":1607839740,"question_id":93,"url":"https://www.examtopics.com/discussions/oracle/view/39729-exam-1z0-082-topic-1-question-27-discussion/","answers_community":["E (100%)"],"timestamp":"2020-12-13 07:09:00"},{"id":"0unm25eeyFNtq1t5hkSK","question_text":"Your database instance is started with a PFILE.\nExamine these parameters:\n//IMG//\n\nYou want to increase the size of the buffer cache.\nFree memory is available to increase the size of the buffer cache.\nYou execute the command:\nSQL> ALTER SYSTEM SET DB_CACHE_SIZE=1024M;\nWhat is the outcome?","choices":{"B":"The value is changed for the current instance and in the PFILE","A":"The value is changed only in the PFILE and takes effect at the next instance startup","C":"It fails because the SCOPE clause is missing","D":"Change is applied to the current instance, but does not persist after instance restart"},"topic":"1","answers_community":["D (67%)","B (33%)"],"answer_description":"","answer_images":[],"exam_id":380,"question_id":94,"answer_ET":"D","unix_timestamp":1598873460,"isMC":true,"answer":"D","timestamp":"2020-08-31 13:31:00","discussion":[{"upvote_count":"23","comment_id":"170750","poster":"adoptc94","comments":[{"content":"yes, agree. D is the correct answer","timestamp":"1623557400.0","comment_id":"242284","poster":"Ekos","upvote_count":"1"}],"content":"Correct Answer: D, the change is applied in memory only, the change does not persist as the database can't write to the pfile\n\nThe default SCOPE option, when you start the instance using a PFILE, is MEMORY (as well as the only scope option you can use with a pfile). If scope is omitted the default scope option is used instead. The SCOPE clause is optional and not mandatory when changing the value of a parameter! \n\nA is wrong, as the pfile is a read only file for the database so it can't write to it. Changes to the pfile have to be done manually by changing it directly using f.e. vi on unix systems. \n\nB is wrong, same reason as for why answer A is wrong\n\nC is wrong, as mentioned above, when omitted the scope clause defaults to MEMORY when using a pfile. \n\nNot related to that question but the more you know: When starting the database using a spfile you have three options for the scope (MEMORY, SPFILE and BOTH). Default value is BOTH.","timestamp":"1614519060.0"},{"timestamp":"1726659480.0","comment_id":"1176537","poster":"antonica","upvote_count":"1","content":"Sorry corect is a. I tested. And If you started your instance with a server parameter file, you can use the ALTER SYSTEM command to change the values of the initialization parameters in the server parameter file. Specify the SCOPE=SPFILE option to change the values in the server parameter file only. Specify SCOPE=BOTH to change values in memory and in the server parameter file. This option is valid only for dynamic parameters. SCOPE=BOTH is the default if the instance has been started with a server parameter file."},{"poster":"nautil2","comment_id":"1012393","upvote_count":"1","content":"Selected Answer: D\nA - FALSE; DB_CACHE_SIZE is a dynamic parameter, its change is applied immediately to the instance \nB - FALSE; when starting db instance with PFILE, no parameter changes can be written to PFILE \nC - FALSE; for dynamic parameters and starting db instance with PFILE, SCOPE=MEMORY is a default /implicit option, so it can be omitted. Change is applied to current instance.\nD - TRUE; see C","timestamp":"1710951000.0"},{"timestamp":"1705910520.0","poster":"musafir","content":"Selected Answer: D\nD is correct since it's PFILE\nIf a server parameter file (spfile) was used to start up the database, then BOTH is the default. If a parameter file (pfile) was used to start up the database, then MEMORY is the default, as well as the only scope you can specify.\nhttps://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/ALTER-SYSTEM.html#GUID-2C638517-D73A-41CA-9D8E-A62D1A0B7ADB","comment_id":"959243","upvote_count":"1"},{"upvote_count":"1","content":"Selected Answer: B\nWhen you execute the \"ALTER SYSTEM\" command to modify a parameter, the default behavior is to change the value for the current instance and also update the value in the server parameter file (in this case: PFILE) to make it persistent across instance restarts.","poster":"auwia","timestamp":"1704804120.0","comments":[{"poster":"auwia","upvote_count":"1","content":"I was wrong, correct answer is D.","comment_id":"951312","timestamp":"1705222680.0"}],"comment_id":"947119"},{"poster":"canijho","upvote_count":"1","comments":[{"content":"Correct answer should be B regarding SPFILE, but not PFILE.","comment_id":"823586","timestamp":"1693127580.0","poster":"canijho","upvote_count":"1"}],"content":"All answer are wrong. Tested:\n\na) The change is applied immediately. Database cannot write into the PFILE (init.ora).\nb) Database cannot write into the PFILE (init.ora).\nc) It does not fail:\nSQL> ALTER SYSTEM SET DB_CACHE_SIZE=1024M;\nSystem altered.\nMon Feb 27 13:01:09 2023\nALTER SYSTEM SET db_cache_size=1024M SCOPE=BOTH;\nSQL> show parameter db_cache_size\nNAME TYPE VALUE\n------------------------------------ ----------- ------------------------------\ndb_cache_size big integer 1G\nd) Default SCOPE option is BOTH (as shown in the alert.log). The change persist after instance restart (validated).","comment_id":"823584","timestamp":"1693127400.0"},{"timestamp":"1686254040.0","content":"Selected Answer: D\nSpfile (server parameter file)-> default scope both\nPfile(texto parameter file) -> default scope memory (and only avalable).\nDatabase can't write un text parameter file.","comment_id":"739501","poster":"raferen10","upvote_count":"1"},{"upvote_count":"1","content":"Selected Answer: D\nright answer : D","timestamp":"1686148860.0","poster":"Juv07","comment_id":"738147"},{"content":"Selected Answer: B\nThe right answer is B!\nDefault is SCOPE=BOTH","comment_id":"620889","timestamp":"1671796260.0","poster":"Xhost","upvote_count":"2"},{"timestamp":"1666342920.0","content":"Selected Answer: D\nA is wrong. PFILES are static and any changes made to the system does not update the text (p)file.\nB is wrong. Issue as with point A.\nC is wrong. Statement without the scope parameter does not fail. Easy to test.\nD is correct. PFILE based instances change parameters by default happen in memory and as with points A and B, will not modify the PFILE.","poster":"Franky_T","comment_id":"589222","upvote_count":"2"},{"upvote_count":"1","timestamp":"1657365540.0","poster":"ryuah","comment_id":"520206","content":"D is correct"},{"comments":[{"poster":"dirk1","timestamp":"1651932900.0","comment_id":"473961","upvote_count":"1","content":"Yes, the default is SCOPE=BOTH if a server parameter file was used to start up the instance, and the default is MEMORY if a text initialization parameter file was used to start up the instance."}],"timestamp":"1645577580.0","content":"Per adoptc94's final notes, in 19c \"When starting the database using a spfile you have three options for the scope (MEMORY, SPFILE and BOTH). Default value is BOTH.\". As the default is both, when SCOPE is not used, the change will be applied to both MEMORY and the SPFILE.","upvote_count":"3","comment_id":"429554","poster":"brolem"}],"url":"https://www.examtopics.com/discussions/oracle/view/30191-exam-1z0-082-topic-1-question-28-discussion/","question_images":["https://www.examtopics.com/assets/media/exam-media/04352/0001700001.png"]},{"id":"kMr6rG9qVKYXkik9W7kN","answer":"ADE","timestamp":"2020-12-13 07:22:00","url":"https://www.examtopics.com/discussions/oracle/view/39732-exam-1z0-082-topic-1-question-29-discussion/","question_images":[],"choices":{"D":"Automatic data file extension (AUTOEXTEND)","A":"Oracle Managed Files (OMF)","C":"Online index segment shrink","E":"Capacity planning growth reports based on historical data in the Automatic Workload Repository (AWR)","B":"Online table segment shrink"},"topic":"1","answer_images":[],"question_id":95,"answer_description":"","question_text":"Which three Oracle database space management features will work with both Dictionary and Locally managed tablespaces? (Choose three.)","answer_ET":"ADE","isMC":true,"answers_community":["ADE (100%)"],"unix_timestamp":1607840520,"discussion":[{"content":"correct, A,D, and E","poster":"Ekos","timestamp":"1639376520.0","upvote_count":"9","comment_id":"242301","comments":[{"upvote_count":"2","timestamp":"1640182500.0","poster":"baeji","content":"i agree","comment_id":"250161"}]},{"comment_id":"589247","content":"Selected Answer: ADE\nA. OMF implements an automatic file name and location option. This is done at file level and has nothing to do with how the tablespace is \"managed\".\nB is wrong. Segment shrink operations are only available with ASSM, which in turn requires LMTBS.\nC is wrong. Same feature as option B.\nD is correct. AUTOEXTEND is done at file level.\nE is correct. Reports are always available through the AWR and has nothing to do with tablespace management type.","poster":"Franky_T","upvote_count":"7","timestamp":"1682072160.0"},{"upvote_count":"1","poster":"nautil2","content":"Selected Answer: ADE\nA - TRUE; Release 19, Database Administrator’s Guide, 17.3.3.6 CREATE DATABASE Statement Using Oracle Managed Files: Examples\nB - FALSE; Release 19, Database Administrator’s Guide, 19.3.3 Shrinking Database Segments Online; Shrink operations can be performed only on segments in locally managed tablespaces with automatic segment space management (ASSM). Within an ASSM tablespace, all segment types are eligible for online segment shrink except these: IOT mapping tables, Tables with rowid based materialized views,...\nC - FALSE; see B\nD - TRUE; no restriction for autoextension mentioned with DMT in Oracle documentation\nE - TRUE; see D","timestamp":"1727890380.0","comment_id":"1023340"},{"comment_id":"947121","content":"Selected Answer: ADE\nProvided answer are corrects.","timestamp":"1720521840.0","poster":"auwia","upvote_count":"1"},{"upvote_count":"1","comment_id":"739506","timestamp":"1702072620.0","content":"Selected Answer: ADE\nOnline segment shrink only works whit local managed tablespaces and ASMM is activated.","poster":"raferen10"}],"exam_id":380}],"exam":{"isMCOnly":true,"isImplemented":true,"lastUpdated":"12 Apr 2025","name":"1z0-082","id":380,"numberOfQuestions":172,"isBeta":false,"provider":"Oracle"},"currentPage":19},"__N_SSP":true}