{"pageProps":{"questions":[{"id":"8kbcRFbZXbUIKNSr1Xik","answer_images":[],"choices":{"B":"Cylinder is not properly calling the Rectangle and Ellipse interfaces’ calculateSurfaceArea methods.","D":"The calculateSurfaceArea method within Rectangle and Ellipse requires a public access modifier.","A":"The calculateSurfaceArea method within Cylinder must be declared default.","C":"Cylinder requires an implementation of calculateSurfaceArea with two parameters."},"timestamp":"2022-12-23 13:17:00","answers_community":["C (100%)"],"question_images":["https://img.examtopics.com/1z0-819/image47.png"],"question_text":"Given:\n//IMG//\n\nWhat prevents this code from compiling?","url":"https://www.examtopics.com/discussions/oracle/view/92572-exam-1z0-819-topic-1-question-29-discussion/","topic":"1","answer":"C","isMC":true,"discussion":[{"poster":"ASPushkin","comment_id":"1330829","timestamp":"1734962400.0","content":"Selected Answer: C\nIf a class implements two interfaces, both of which have a default method with the same name and parameter types, then you must resolve the conflict.\nYou should provide \"conflict default\" method in class and either implement your own greeting, or delegate to one of the conflicting methods, like this:\nRectangle.super.caculateSurfaceArea(majorR, minorR);","upvote_count":"1"},{"comment_id":"1277533","upvote_count":"1","poster":"ASPushkin","timestamp":"1725363960.0","content":"Selected Answer: C\nIf a class implements two interfaces, both of which have a default method with the same name and parameter types, then you must resolve the conflict.\nYou should provide \"conflict default\" method in the class.\nThere is a case with nearer definition/ For example\npublic interface Point {\n default double calculateSurfaceArea(double, double) { ... }\n}\npublic interface Rectangle extends Point {\n}\npublic interface Ellipse extends Point {\n default double calculateSurfaceArea(double, double) { ... }\n}\npublic class Cylinder implements Ellipse, Rectangle {\n}\nnew Cylinder().calculateSurfaceArea(double, double)\nexecutes Ellipse method because of nearer definition."},{"timestamp":"1697732880.0","content":"Selected Answer: C\nThe two interfaces have default methods, so if they didn't have the same name, Cylinder would not have to call any of them (because they already have a default implementation), so B is not correct. As the two methods in the two interfaces have the same name, the class that implements them must define its own implementation, so C is correct.","comment_id":"1048103","upvote_count":"3","poster":"RoxyFoxy"},{"comment_id":"1016638","timestamp":"1695632220.0","poster":"[Removed]","content":"Selected Answer: C\nTested in compiler. C is correct. It compiles when having only one method called calculatedSurfaceArea with two parameters in the child class.","comments":[{"timestamp":"1695632520.0","content":"Or wait, when reading the options again I guess it makes B correct..","comment_id":"1016643","poster":"[Removed]","upvote_count":"1"}],"upvote_count":"1"},{"timestamp":"1693332000.0","comment_id":"993381","upvote_count":"1","content":"C is correct. As a class implementing 2 interfaces with same(same signature) default method will cause a compile error.","poster":"[Removed]"},{"poster":"gopu_azure32","upvote_count":"1","timestamp":"1686544440.0","content":"B is correct","comment_id":"921114"},{"timestamp":"1685824860.0","comment_id":"913914","content":"Selected Answer: C\nDuplicate default methods named calculatedSurfaceArea with the parameters (double, double) and (double, double) are inherited from the types Ellipse and Rectangle","upvote_count":"1","poster":"Stavok"},{"content":"Selected Answer: C\nC is correct because two same default methods create conflict for the compiler.","timestamp":"1685505000.0","comment_id":"910779","poster":"Mukes877","upvote_count":"2"},{"comment_id":"803578","poster":"Londeka","upvote_count":"2","timestamp":"1675967580.0","content":"C is the correct answer"},{"timestamp":"1671797820.0","comment_id":"754183","upvote_count":"3","content":"B is correct if a method implements two interfaces with same method signatures it has to provide an implementation to avoid conflict , same applies to abstract methods","poster":"TADIEWA"}],"answer_ET":"C","unix_timestamp":1671797820,"exam_id":402,"question_id":136,"answer_description":""},{"id":"09rAzHBMABn0QXc5Hfw6","isMC":true,"question_id":137,"answer_ET":"BC","question_images":["https://img.examtopics.com/1z0-819/image5.png","https://img.examtopics.com/1z0-819/image6.png"],"question_text":"Given:\n//IMG//\n\nand\n//IMG//\n\nWhich two method definitions at line n1 in the Bar class compile? (Choose two.)","choices":{"C":"public List<Integer> foo(TreeSet<String> m) {...}","B":"public List<Integer> foo(Set<CharSequence> m) {...}","A":"public List<Number> foo(Set<String> m) {...}","E":"public ArrayList<Integer> foo(Set<String> m) {...}","D":"public List<Object> foo(Set<CharSequence> m) {...}","F":"public ArrayList<Number> foo(Set<CharSequence> m) {...}"},"timestamp":"2022-11-12 11:54:00","discussion":[{"comments":[{"timestamp":"1727781540.0","upvote_count":"1","comment_id":"1291936","content":"return part isn't taken into account for overloads","poster":"ASPushkin"}],"timestamp":"1694154600.0","content":"Selected Answer: BC\nB ✅ -> overrides: Same method signature including return type\nC ✅ -> overloads: Same method signature including return type, overloads with a subclass as method parameter","comment_id":"1002201","poster":"curiouss","upvote_count":"5"},{"content":"Selected Answer: BC\nsubtype of List<Integer> is ArrayList<Integer>\nso we can consider BCE\nB is the same - overriding\nC - different parameter list - overloading\nE - should be same generics\nanswer: BC","timestamp":"1733417880.0","upvote_count":"1","poster":"ASPushkin","comment_id":"1322451"},{"poster":"ASPushkin","timestamp":"1727699700.0","content":"Selected Answer: BC\nanswer: BC\nA. not correct\nthere is a same erasure for method signature but different generics for the parameter variable. So there is no overriding.\nB. correct\nsame signature method and the return part\nC. correct\noverloading\nsame method name but different parameter\nD. not correct\nsame signature including parameter variable generic but incompatible return type (according to Liskov substitution principle)\nE. is not correct\nthere is a same erasure for method signature but different generics for the parmeter variable. So there is no overriding.\nF. not correct\nsame signature including parameter generic but incompatible return type (accotding to Liskov substitution principle) It will work for ArrayList<Integer> return type.","comment_id":"1291553","upvote_count":"1"},{"comment_id":"1054196","poster":"james2033","upvote_count":"1","timestamp":"1698281520.0","content":"Selected Answer: BC\nFile Foo.java\n\nimport java.util.List;\nimport java.util.Set;\n\npublic class Foo {\n\n public List<Integer> foo(Set<CharSequence> m) {\n return null;\n }\n\n}\n\n\nFile Bar.java\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class Bar extends Foo {\n\n // line n1. B\n //public List<Integer> foo(Set<CharSequence> m) {\n // return null;\n //}\n\n // line n1. C\n public List<Integer> foo(TreeSet<String> m) {\n return null;\n }\n\n}\n\nChoose B, C."},{"upvote_count":"2","poster":"Omnisumem","content":"Selected Answer: BC\nTested: B and C.","comment_id":"1005660","timestamp":"1694516700.0"},{"upvote_count":"3","poster":"Lebannin","comment_id":"963123","content":"Selected Answer: BC\nthe answer is B and C, B is overriding and C is overloading","timestamp":"1690319400.0"},{"content":"Selected Answer: BD\nThis is a question about method overriding in Java. The method foo in the Bar class must have the same signature as the foo method in the Foo class to override it. This means that the return type and the parameter types must be the same. Therefore, the correct answers are B and D. Both of these options have a return type of List<Integer> and a parameter type of Set<CharSequence>, which matches the signature of the foo method in the Foo class.","upvote_count":"2","poster":"Stavok","timestamp":"1689420420.0","comments":[{"timestamp":"1690319340.0","content":"D is not overloading, you cannot change the return type","upvote_count":"3","comment_id":"963122","poster":"Lebannin"}],"comment_id":"952307"},{"upvote_count":"1","timestamp":"1684470720.0","content":"F is not for returning Incompatible type and E is not for Name-Clash error in Set parameter.\nSo correct answers is BC","poster":"Mukes877","comment_id":"901639"},{"upvote_count":"1","poster":"iCOW","timestamp":"1683006780.0","content":"Selected Answer: BC\nBC is correct not CF since F returning incompatible type.","comment_id":"887052"},{"content":"BC is correct","upvote_count":"1","poster":"Ankit1010","comment_id":"780271","timestamp":"1674063900.0"},{"content":"BC is correct","comment_id":"718164","upvote_count":"2","poster":"UcefSoft","timestamp":"1668450060.0"},{"upvote_count":"3","content":"BC, not F, because returns \"attempting to use incompatible return type\"","timestamp":"1668250440.0","comment_id":"716654","poster":"deti27"}],"topic":"1","answer":"BC","answer_images":[],"answers_community":["BC (88%)","13%"],"unix_timestamp":1668250440,"url":"https://www.examtopics.com/discussions/oracle/view/87356-exam-1z0-819-topic-1-question-3-discussion/","answer_description":"","exam_id":402},{"id":"BlSi0qapYp8dwJV6Jejy","isMC":true,"topic":"1","answer_ET":"BD","url":"https://www.examtopics.com/discussions/oracle/view/110612-exam-1z0-819-topic-1-question-30-discussion/","question_images":["https://img.examtopics.com/1z0-819/image48.png"],"question_text":"Given a Member class with fields for name and yearsMembership, including getters and setters and a print method, and a list of clubMembers members:\n//IMG//\n\nWhich two Stream methods can be changed to use method references? (Choose two.)","unix_timestamp":1685505720,"exam_id":402,"discussion":[{"comment_id":"1276741","content":"Selected Answer: BD\nanswer: BD\nA. Failed\nThe Basic format of a method reference is broadly <scope>::<method-name> without parameter names.\nC Failed\nThe Basic format of a method reference is broadly <scope>::<method-name> without parameter names.\nBut here there is an boolean expression at the right hand.\nB correct\nReference to an instance method of a particular object\ncontainingObject::instanceMethodName\nD. correct\nReference to an instance method of an arbitrary object of a particular type\nContainingType::methodName","upvote_count":"1","timestamp":"1725283620.0","poster":"ASPushkin"},{"content":"B & D are correct.\n\nA : .filter(Integer::equals(0)); You cannot pass parameter when calling through reference \nC: .filter(Member::getYearsMembership() >= testMembershipLength); You cannot call method reference with '()'","timestamp":"1712883240.0","poster":"rami_mlaiel","upvote_count":"1","comment_id":"1194062"},{"comment_id":"1119026","upvote_count":"1","content":"Selected Answer: BD\nb and D are correct, other options are bad sintax","timestamp":"1704920460.0","poster":"d7bb0b2"},{"comment_id":"993384","content":"BD is correct. As A & C are just bad syntax.","timestamp":"1693332180.0","upvote_count":"2","poster":"[Removed]"},{"timestamp":"1685505720.0","upvote_count":"1","comment_id":"910788","content":"Selected Answer: BD\nB and D are correct because method reference is used only for reference method and constructor not for performing comparison","poster":"Mukes877"}],"answers_community":["BD (100%)"],"question_id":138,"answer":"BD","choices":{"A":".filter(Integer::equals(0))","B":".map(testName::compareToIgnoreCase)","D":".peek(Member::print)","C":".filter(Member::getYearsMembership() >= testMembershipLength)"},"answer_description":"","answer_images":[],"timestamp":"2023-05-31 06:02:00"},{"id":"6u1YIGUfdAQL0x0NzKUg","answer_ET":"BC","discussion":[{"content":"Selected Answer: BC\nrelative paths same current working directory\nabsolute paths one absolute location to another, regardless of the current working directory\nabsolute and relative throws an exception \ngo up three levels to scratch is possible just from A, B cases\nanswer B, C","timestamp":"1725208620.0","comment_id":"1276164","poster":"ASPushkin","upvote_count":"1"},{"content":"Selected Answer: BC\nB and C are correct","comment_id":"1119027","upvote_count":"1","timestamp":"1704920520.0","poster":"d7bb0b2"},{"timestamp":"1692006300.0","comment_id":"980655","upvote_count":"1","poster":"Omnisumem","content":"Selected Answer: BC\nTetsted: BC."},{"poster":"Stavok","comment_id":"953500","timestamp":"1689527100.0","upvote_count":"2","content":"Selected Answer: BC\nThe two statements that print ..\\..\\..\\answers\\topsecret are options B and C.\n\nIn option B, p2.relativize(p3) constructs a relative path from p2 to p3. Since p2 represents the path /scratch/exam/answers/temp.txt, and p3 represents the path /scratch/answers/topsecret, the relative path from p2 to p3 is ..\\..\\..\\answers\\topsecret.\n\nIn option C, p1.relativize(p3) constructs a relative path from p1 to p3. Since p1 represents the path /scratch/exam/topsecret/answers, and p3 represents the path /scratch/answers/topsecret, the relative path from p1 to p3 is also ..\\..\\..\\answers\\topsecret"},{"content":"Selected Answer: BC\nB, C is correct others don't give required path","upvote_count":"3","poster":"Mukes877","timestamp":"1685506560.0","comment_id":"910794"},{"upvote_count":"1","poster":"TADIEWA","comment_id":"754197","content":"B,C are correct","timestamp":"1671799080.0"}],"answer_images":[],"choices":{"A":"System.out.print(p3.relativize(p1));","F":"System.out.print(p2.relativize(p1));","B":"System.out.print(p2.relativize(p3));","C":"System.out.print(p1.relativize(p3));","D":"System.out.print(p3.relativize(p2));","E":"System.out.print(p1.relativize(p2));"},"answer_description":"","unix_timestamp":1671799080,"exam_id":402,"question_id":139,"question_text":"Given:\nPath p1 = Paths.get(“/scratch/exam/topsecret/answers”);\nPath p2 = Paths.get(“/scratch/exam/answers/temp.txt”);\nPath p3 = Paths.get(“/scratch/answers/topsecret”);\nWhich two statements print ..\\..\\..\\answers\\topsecret? (Choose two.)","question_images":[],"answers_community":["BC (100%)"],"url":"https://www.examtopics.com/discussions/oracle/view/92573-exam-1z0-819-topic-1-question-31-discussion/","timestamp":"2022-12-23 13:38:00","answer":"BC","topic":"1","isMC":true},{"id":"xPdYGiadls7tyjKcwLrp","isMC":true,"question_id":140,"answer_ET":"A","question_images":["https://img.examtopics.com/1z0-819/image49.png"],"timestamp":"2023-05-31 06:26:00","choices":{"D":"studentNo, classes, name, and address","A":"studentNo and classes","B":"studentNo and name","C":"studentNo, classes and name"},"question_text":"Given the code fragment:\n//IMG//\n\nWhich fields are serialized in a Student object?","discussion":[{"timestamp":"1742584080.0","poster":"Rastislav","comment_id":"1401663","content":"Selected Answer: A\nEven though name is inherited, it is not serializable.","upvote_count":"1"},{"poster":"ASPushkin","comment_id":"1275563","content":"answer: A\nAny inherited fields are serializable only if the superclass is also declared with the interface Serializable.\nSo, fields from the Person class are not not serializable.\nWhen an object has a reference to another object, these objects must implement the Serializable interface separately, or else a NotSerializableException will be thrown.\nSo, field id from Classes is serializable.","upvote_count":"1","timestamp":"1725104940.0"},{"poster":"Omnisumem","content":"Selected Answer: C\nIn the Student class, the fields that will be serialized are:\n\nname (inherited from the Person class)\nstudentNo\nclasses\nThe name field is inherited from the Person class, and since Person is not marked as transient and does not implement Serializable, its name field will be serialized.\n\nThe studentNo field is directly declared in the Student class and since Student implements Serializable, it will be serialized.\n\nThe classes field is of type Classes, which also implements Serializable. Therefore, it will be serialized as well.\n\nHowever, the address field from the Person class is marked as transient, which means it will not be serialized.","comment_id":"1200701","timestamp":"1713872820.0","upvote_count":"1"},{"upvote_count":"1","content":"Selected Answer: C\nC is correct, Person is extended by Student so inherit his field an name are marked as seriaziable too","comment_id":"1119029","poster":"d7bb0b2","timestamp":"1704920700.0"},{"content":"C, cause even Person is not seriazable, Student inherith the field name and then is marked as seriazable, and class and student nro.\nNote Person class mark transient adress so even Studen inherit thhe fields this is no seriazable.","poster":"d7bb0b2","timestamp":"1704589560.0","upvote_count":"1","comment_id":"1115534"},{"comment_id":"1091318","poster":"d7bb0b2","upvote_count":"1","content":"When a Student object is serialized, the following fields will be included in the serialized form: \nschool from the Student class\nclasses from the Student class, which includes the id field from the Classes class\nname from the Persona class\nThe address field in the Persona class is marked as transient, which means it will be ignored during serialization and will not be included in the serialized form of a Student object.","timestamp":"1702065720.0"},{"comment_id":"1016735","upvote_count":"1","timestamp":"1695640620.0","poster":"[Removed]","content":"Tested it and answer seems to be D?!\nNot sure if I did anything wrong but when i made the Person-class implement serielizable as well, then the transient keyword was working as expected but whit no Serializable in the super-class -> the whole class and it's it's members where written down to memory/file reglardless of transient or not."},{"comment_id":"993392","upvote_count":"1","timestamp":"1693332840.0","poster":"[Removed]","content":"Selected Answer: A\nAnswer is A. \nExplanation below. Source geeksforgeeks\nSerialization: At the time of serialization, if any instance variable inherits from the non-serializable superclass, then JVM ignores the original value of that instance variable and saves the default value to the file.\n\nDe- Serialization: At the time of de-serialization, if any non-serializable superclass is present, then JVM will execute instance control flow in the superclass. To execute instance control flow in a class, JVM will always invoke the default(no-arg) constructor of that class. So every non-serializable superclass must necessarily contain a default constructor. Otherwise, we will get a runtime exception."},{"poster":"Stavok","timestamp":"1689527460.0","content":"Selected Answer: C\nWhen an object is serialized, all of its non-transient and non-static fields are serialized, including fields inherited from its superclass. In this case, the Student class extends the Person class and implements the Serializable interface. This means that when a Student object is serialized, all of its non-transient and non-static fields, as well as those of its superclass Person, are serialized.\n\nThe Student class has two non-transient and non-static fields: studentNo and classes. The classes field is an instance of the Classes class, which also implements the Serializable interface, so it will be serialized along with the Student object. The Person class has one non-transient and non-static field: name. This field is also serialized when a Student object is serialized.\n\nThe address field in the Person class is marked as transient, so it will not be serialized when a Student object is serialized.","comment_id":"953504","upvote_count":"1"},{"content":"Ans: A\nWhen a superclass does not implement Serializable,\nits attributes are not serialized.","poster":"aruni_mishra","timestamp":"1688375460.0","comment_id":"941651","upvote_count":"1"},{"comment_id":"919683","upvote_count":"1","content":"name field should be serialized, too.","timestamp":"1686354600.0","poster":"trickeryoyo"},{"content":"Selected Answer: A\nA is right","comment_id":"910796","poster":"Mukes877","upvote_count":"2","timestamp":"1685507160.0"}],"topic":"1","answer":"A","answers_community":["A (57%)","C (43%)"],"answer_images":[],"unix_timestamp":1685507160,"answer_description":"","url":"https://www.examtopics.com/discussions/oracle/view/110613-exam-1z0-819-topic-1-question-32-discussion/","exam_id":402}],"exam":{"isMCOnly":false,"provider":"Oracle","numberOfQuestions":213,"isBeta":false,"isImplemented":true,"id":402,"name":"1z0-819","lastUpdated":"12 Apr 2025"},"currentPage":28},"__N_SSP":true}