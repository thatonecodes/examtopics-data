{"pageProps":{"questions":[{"id":"Y9jbrKANplqxN4j5RDMG","isMC":true,"choices":{"D":"Push","C":"Merge","B":"Fetch","A":"Rebase"},"discussion":[{"comments":[{"content":"The merge will result as a combination of commits, whereas rebase will add all the changes in feature branch starting from the last commit of the master branch... so rebease never overwrites anything. \nHere Merge should be correct.\nhttps://www.atlassian.com/git/tutorials/merging-vs-rebasing","timestamp":"1614894780.0","comment_id":"173584","upvote_count":"13","comments":[{"comments":[{"content":"as mfela states, merge doesn't overwrite, but rebase does.","timestamp":"1624726680.0","poster":"Morke","comment_id":"252840","upvote_count":"2"}],"timestamp":"1615995480.0","upvote_count":"13","poster":"mfela","content":"From the link that you provided:\n\"But, instead of using a merge commit, rebasing re-writes the project history by creating brand new commits for each commit in the original branch.\"\nI would say A \"rebase\"","comment_id":"180970"},{"comment_id":"338317","upvote_count":"1","poster":"haxaffe","content":"You can rewrite the entire history with rebase. https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase\n\nIt's not mentoined in the answer but interactive rebase is a parameter for rebase and can do exactly what is asked.","timestamp":"1634574840.0"},{"poster":"mpindado","content":"A simple rebase will still overwrite changes on master if master has changes since feature was created.","comment_id":"383157","timestamp":"1639644120.0","upvote_count":"1"}],"poster":"TechieBloke"}],"poster":"motu","upvote_count":"53","timestamp":"1614865260.0","content":"Shouldn't it be a rebase since we want to \"override the history of the Git repository\"? A merge will not override the history, merely add the new changes,","comment_id":"173350"},{"upvote_count":"27","content":"Correct Answer is A \"Rebase\"","poster":"Corona_Virus","comments":[{"content":"Corona Virus is right","comment_id":"298476","upvote_count":"17","comments":[{"timestamp":"1633545840.0","upvote_count":"16","comment_id":"329864","content":"lol atleast theres a right with corona virus","poster":"LeeVee"}],"timestamp":"1629823200.0","poster":"Pino2012"}],"timestamp":"1614913680.0","comment_id":"173688"},{"upvote_count":"1","poster":"Dankho","timestamp":"1735335120.0","content":"Selected Answer: A\nGoing with A but it's not enough. This is the correct answer if we interpret the question as asking what starts the process of overriding the history. While rebase alone doesn't update the remote main branch, it sets up the rewritten history, which is a prerequisite for overriding the repository's history.\n\nTo finalize the update, you would need to:\n1 - Switch to the main branch.\n2 - Apply the rebased changes, typically with a fast-forward or force-push.\n\nWhy not Merge: Merge combines changes from two branches but does not rewrite or replace history; it creates a merge commit instead.","comment_id":"1332631"},{"comment_id":"1174255","poster":"FeriAZ","content":"Selected Answer: A\nOverriding History: Rebasing allows you to rewrite the commit history of your branch. You can replay the commits from the experimentation branch on top of the latest commit of the main branch, effectively integrating the changes while discarding the original history of the experimentation branch.","upvote_count":"1","timestamp":"1726395660.0"},{"comment_id":"993348","poster":"SenseiJC","timestamp":"1709234580.0","content":"Selected Answer: A\nI think it is \"A. Rebase\" because a merge preserves the history on the branch (assuming commits on master and experiment happened in parallel). Only Rebase will do as the question requests and \"override the history\" because it forces the merged branch to offer its commits AFTER the head of the main branch.","upvote_count":"1"},{"poster":"xRiot007","content":"Rebase will override history. Please do not use this on commercial projects.","upvote_count":"2","comment_id":"963666","timestamp":"1706276160.0"},{"upvote_count":"1","content":"Selected Answer: C\nGiven answer is correct 100%. Rebasing is the process of moving or combining a sequence of commits to a new base commit. Since you created your branch, main branch has moved, so you can rebase your branch to latest commit of main branch. This doesn't do ANYTHING to the main branch. To get changes to main branch from your feature branch, YOU HAVE TO DO A MERGE","timestamp":"1694277840.0","poster":"Rams_84zO6n","comment_id":"834270"},{"content":"Please update it to A.","comments":[{"content":"I think the given answer is correct. Rebase makes sense if you are updating feature branch with latest commit of main branch. This will make you merge to main branch easy later. But the question asked is How to get the changes from branch to main","comment_id":"834278","timestamp":"1694278080.0","poster":"Rams_84zO6n","upvote_count":"1"}],"upvote_count":"2","timestamp":"1692284760.0","poster":"rahul51it","comment_id":"812150"},{"timestamp":"1690904100.0","poster":"dottLorenz","upvote_count":"1","content":"Rebase the master branch to the feature and override the other commit present in the master after the fork of feature\nSo rebase is the response","comment_id":"795361"},{"timestamp":"1688921640.0","upvote_count":"2","content":"Selected Answer: A\nA. Rebase to squash all the commits in the main branch\nMerge will add the commit history from the feature branch onto of the main branch","poster":"icedog","comment_id":"770779"},{"poster":"syu31svc","upvote_count":"1","timestamp":"1675586280.0","content":"Selected Answer: A\nhttps://docs.microsoft.com/en-us/azure/devops/repos/git/rebase?view=azure-devops&tabs=visual-studio-2019\n\n\"Git rebase resequences the commit history of the target branch so that it contains all source branch commits, followed by all target branch commits since the last common commit. Another way to view it is that a rebase replays the changes in your target branch on top of the source branch history\"\n\nAnswer is A","comment_id":"642787"},{"timestamp":"1674015780.0","poster":"mclovin","upvote_count":"1","content":"Selected Answer: A\nif it's overriding, then answer is Rebase","comment_id":"632795"},{"comment_id":"604354","content":"Selected Answer: A\nA is correct answer.","poster":"Eltooth","timestamp":"1668948780.0","upvote_count":"1"},{"timestamp":"1664010120.0","content":"Selected Answer: A\nsince yuou need to rewrite the main history you need to use a rebase. The only way to ensure to write all experimentation history in the main branch\nhttps://www.atlassian.com/git/tutorials/merging-vs-rebasing","upvote_count":"3","comment_id":"574284","poster":"rdemontis"},{"timestamp":"1659595860.0","content":"Got this January 2022. Rebase. 100% on that part.","comment_id":"540313","poster":"lugospod","upvote_count":"6"},{"content":"Rebase, naturally.","timestamp":"1658489100.0","comment_id":"529873","poster":"Art3","upvote_count":"1"},{"poster":"Art3","comment_id":"528366","timestamp":"1658309100.0","content":"Selected Answer: A\nCorrect is Rebase (A).","upvote_count":"1"},{"timestamp":"1655555220.0","upvote_count":"2","poster":"ora555","content":"I'm still going to rebase the answer.\nI found the document.\nhttps://docs.microsoft.com/en-us/azure/devops/repos/git/rebase?view=azure-devops&tabs=visual-studio","comment_id":"504263"},{"comment_id":"504254","poster":"ora555","upvote_count":"1","content":"The answer is merge. Because the problem statement points out that you update your main branch.\nhttps://qiita.com/ko-he-8/items/94e872f2154829c868df","timestamp":"1655554440.0"},{"upvote_count":"2","timestamp":"1644253200.0","poster":"fabulousethiopia","content":"The rebase would replace the old commits with new ones and it would look like that part of your project history abruptly vanished.\n\nhttps://www.atlassian.com/git/tutorials/rewriting-history/git-rebase","comment_id":"421259"},{"poster":"poplovic","upvote_count":"3","timestamp":"1643084880.0","comment_id":"413569","content":"rebase is correct\nhttps://git-scm.com/book/en/v2/Git-Branching-Rebasing"},{"timestamp":"1638859860.0","comment_id":"376501","content":"I agree REBASE is the right answer, merge will not override the history","poster":"SACHMAM","upvote_count":"3"},{"upvote_count":"3","poster":"nvnrao57","comment_id":"344598","timestamp":"1635421020.0","content":"Option A: Rebase"},{"timestamp":"1631700660.0","upvote_count":"11","comment_id":"311381","poster":"DeepMoon","comments":[{"timestamp":"1664812320.0","upvote_count":"1","poster":"Sriniv","comment_id":"580364","content":"Yes you are not suppose to rebase main branch.Answer is merge"}],"content":"You never rebase the main. You only rebase the branch you are working on. So that it will capture all the commits done by other developers to the main branch.\nAfter you are done with your feature. You make a pull request. If your code is up to snuff; Maintainer of the upstream repository will merge your commits to the main branch.\nWhen that merge happens; it adds on commits you did to the feature branch. Which is what you want to happen.\n So that answer is merge.\nBut what makes the question confusing is the wording 'override the history of the git repository'. Overriding happens with merge when a new 'merge commit' is written to the main and the HEAD is moved."},{"timestamp":"1630098180.0","content":"Git Merge doesn't override the git commit histories but Git Squash Merge does","upvote_count":"1","comment_id":"300501","poster":"dandynamite"},{"poster":"Pino2012","upvote_count":"3","comment_id":"297535","timestamp":"1629728400.0","content":"So is it rebase or merge? I have my exam in 2 days........"},{"upvote_count":"1","comment_id":"285267","timestamp":"1628304420.0","content":"Rebase is the correct answer.","poster":"077dammy"},{"upvote_count":"5","comment_id":"285135","poster":"agueda","timestamp":"1628284560.0","content":"I think the \"override\" is misleading. To \"overwrite\" something is to put something else in its place, destroying the thing overwritten. To \"override\" something is to cause something else to operate instead of it without harming or changing the thing overridden. With this in mind, i think \"merge\" is the way to go"},{"content":"you can rebase a feature branch with the main branch, so the correct answer is MERGE","timestamp":"1627577760.0","upvote_count":"2","comment_id":"279515","poster":"timurlan"},{"timestamp":"1621517700.0","comment_id":"223743","upvote_count":"3","content":"A. Rebase","poster":"kumardeb"},{"poster":"imkoti","timestamp":"1617543180.0","comment_id":"192929","upvote_count":"7","content":"Rebase is correct ans"},{"timestamp":"1616963760.0","content":"Rebase - https://git-scm.com/book/en/v2/Git-Branching-Rebasing","comment_id":"189277","poster":"StoneZuk","upvote_count":"5"},{"upvote_count":"4","timestamp":"1614933300.0","poster":"CristianN","content":"Pull request & merge to be more precisely.","comment_id":"173760"}],"answer_description":"","topic":"7","url":"https://www.examtopics.com/discussions/microsoft/view/30573-exam-az-400-topic-7-question-62-discussion/","answer_ET":"A","question_text":"You are developing an application. The application source has multiple branches.\nYou make several changes to a branch used for experimentation.\nYou need to update the main branch to capture the changes made to the experimentation branch and override the history of the Git repository.\nWhich Git option should you use?","question_id":386,"answer":"A","answer_images":[],"question_images":[],"timestamp":"2020-09-04 13:41:00","answers_community":["A (92%)","8%"],"exam_id":55,"unix_timestamp":1599219660},{"id":"jvAbDKoNnbLeJO4dHmPM","question_text":"Note: This question is part of a series of questions that present the same scenario. Each question in the series contains a unique solution that might meet the stated goals. Some question sets might have more than one correct solution, while others might not have a correct solution.\nAfter you answer a question in this section, you will NOT be able to return to it. As a result, these questions will not appear in the review screen.\nYou use Azure Pipelines to build and test a React.js application.\nYou have a pipeline that has a single job.\nYou discover that installing JavaScript packages from npm takes approximately five minutes each time you run the pipeline.\nYou need to recommend a solution to reduce the pipeline execution time.\nSolution: You recommend defining a container job that uses a custom container that has the JavaScript packages preinstalled.\nDoes this meet the goal?","isMC":true,"discussion":[{"upvote_count":"7","comment_id":"327601","timestamp":"1617484920.0","content":"Correct, but I found a better explanation:\nhttps://docs.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops","poster":"Zoli75"},{"comments":[{"timestamp":"1662962820.0","comment_id":"666635","comments":[{"comment_id":"963671","poster":"xRiot007","timestamp":"1690371540.0","upvote_count":"2","content":"@Def21 - Why - You can have in the registry an image with those tools already installed and then you just use it."}],"content":"B is correct. This does not help. You still need to install the package when you build the container. You should use container registry to store a ready image.","upvote_count":"4","poster":"Def21"}],"poster":"rdemontis","upvote_count":"6","timestamp":"1648125840.0","comment_id":"574346","content":"Selected Answer: A\nI think the answer is A (Yes).\n\"Containers provide isolation from the host and allow you to pin specific versions of tools and dependencies. Host jobs require less initial setup and infrastructure to maintain\"\n\nhttps://docs.microsoft.com/en-us/azure/devops/pipelines/process/container-phases?view=azure-devops\n\n\"Containers can be hosted on registries other than Docker Hub. To host an image on Azure Container Registry or another private container registry, add a service connection to the private registry. Then you can reference it in a container spec:\"\n\nhttps://docs.microsoft.com/en-us/azure/devops/pipelines/process/container-phases?view=azure-devops#endpoints\n\nSince it's possible to build an application inside a container and the container can be generated via a custom image, I'd say that using in the build pipeline a container with an image that already has the js packages installed can be a great solution."},{"timestamp":"1731154980.0","upvote_count":"1","content":"Selected Answer: A\nA, Yes this meets the goal, but pipeline caching is the preferred","comment_id":"1309077","poster":"Gooldmember"},{"poster":"vsvaid","upvote_count":"2","content":"Selected Answer: B\nNo for me. Use pipeline caching","timestamp":"1703269560.0","comment_id":"1103627"},{"poster":"xRiot007","timestamp":"1690371480.0","upvote_count":"2","comment_id":"963669","content":"Answer is Yes. You can build a Docker container image with these already installed and save it in your registry. Later, you just use it dirrectly."},{"poster":"syu31svc","comment_id":"643244","timestamp":"1659774480.0","content":"Selected Answer: B\nhttps://docs.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops\n\n\"Pipeline caching can help reduce build time by allowing the outputs or downloaded dependencies from one run to be reused in later runs, thereby reducing or avoiding the cost to recreate or redownload the same files again. Caching is especially useful in scenarios where the same dependencies are downloaded over and over at the start of each run. This is often a time consuming process involving hundreds or thousands of network calls.\n\nCaching can be effective at improving build time provided the time to restore and save the cache is less than the time to produce the output again from scratch. Because of this, caching may not be effective in all scenarios and may actually have a negative impact on build time.\"\n\nAnswer is No","upvote_count":"4"},{"timestamp":"1651320000.0","upvote_count":"4","poster":"srikrishnan22","content":"Selected Answer: B\nanswer is B","comment_id":"594979"},{"content":"It's not sure, but I think that YES, it decreases total time.","poster":"Art3","upvote_count":"1","timestamp":"1642858020.0","comment_id":"529875"},{"poster":"Sakile","upvote_count":"3","comment_id":"450363","timestamp":"1632408720.0","content":"From Microsoft: Pipeline caching can help reduce build time by allowing the outputs or downloaded dependencies from one run to be reused in later runs, thereby reducing or avoiding the cost to recreate or redownload the same files again. Caching is especially useful in scenarios where the same dependencies are downloaded over and over at the start of each run. This is often a time consuming process involving hundreds or thousands of network calls."},{"poster":"Concay","timestamp":"1622858040.0","comment_id":"374658","content":"Answer should be correct..container image wont rebuild but skip if nothing change","upvote_count":"5","comments":[{"poster":"mpindado","comments":[{"upvote_count":"1","timestamp":"1735296000.0","comment_id":"1332360","content":"the problem is that we have to think it \"the MS way\" ......","poster":"hotspot02103"}],"upvote_count":"7","comment_id":"383165","content":"The container job will not build the image, but use the image to create a container in which the app is built.\nSo using a container with a pre-computed image is not only valid but common parttern in any CI-CD system. Yes is correct.","timestamp":"1623826560.0"}]},{"comment_id":"328225","content":"Wouldn't the docker image meet the goal anyway? maybe is not the best solution but I think it does meet the goal of reducing the time since you could have a base image with the packages. Any idea?","upvote_count":"5","timestamp":"1617567000.0","poster":"Tesshu","comments":[{"timestamp":"1618054080.0","comment_id":"332481","content":"I also think the docker image could be a solution. It does seem more work to setup and keep up to date than plain caching though.\nhttps://docs.microsoft.com/en-us/azure/devops/pipelines/process/container-phases?view=azure-devops","poster":"Sylph","upvote_count":"3"},{"content":"Yes I will go with \"Yes\" on the test if this pops up. Those chain questions can have multiple correct answers as far as i know.","upvote_count":"3","comment_id":"338321","timestamp":"1618764060.0","poster":"haxaffe"}]}],"url":"https://www.examtopics.com/discussions/microsoft/view/48983-exam-az-400-topic-7-question-63-discussion/","question_id":387,"answer_description":"","unix_timestamp":1617484920,"exam_id":55,"answers_community":["B (59%)","A (41%)"],"topic":"7","answer":"B","answer_ET":"B","question_images":[],"timestamp":"2021-04-03 23:22:00","choices":{"B":"No","A":"Yes"},"answer_images":[]},{"id":"DBWtftjIhEzLKhIdGHI9","discussion":[{"poster":"arol","upvote_count":"7","timestamp":"1638777120.0","content":"Answer is correct","comment_id":"375668"},{"timestamp":"1719073680.0","upvote_count":"1","content":"Selected Answer: A\nAgree with answer","poster":"vsvaid","comment_id":"1103629"},{"upvote_count":"1","content":"Selected Answer: A\nA is the answer\nhttps://learn.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops","comment_id":"970990","poster":"yana_b","timestamp":"1706962740.0"},{"comment_id":"914027","content":"Selected Answer: A\nA is the answer.\n\nhttps://learn.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops\nPipeline caching can help reduce build time by allowing the outputs or downloaded dependencies from one run to be reused in later runs, thereby reducing or avoiding the cost to recreate or redownload the same files again. Caching is especially useful in scenarios where the same dependencies are downloaded over and over at the start of each run. This is often a time consuming process involving hundreds or thousands of network calls.\n\nCaching can be effective at improving build time provided the time to restore and save the cache is less than the time to produce the output again from scratch. Because of this, caching may not be effective in all scenarios and may actually have a negative impact on build time.","timestamp":"1701660000.0","poster":"zellck","upvote_count":"1"},{"poster":"hebertpena88","upvote_count":"1","comment_id":"644080","timestamp":"1675861320.0","content":"Selected Answer: A\nI use this in my apps, this is correct"},{"timestamp":"1675679340.0","upvote_count":"1","comment_id":"643245","content":"Selected Answer: A\nhttps://docs.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops\n\n\"Pipeline caching can help reduce build time by allowing the outputs or downloaded dependencies from one run to be reused in later runs, thereby reducing or avoiding the cost to recreate or redownload the same files again. Caching is especially useful in scenarios where the same dependencies are downloaded over and over at the start of each run. This is often a time consuming process involving hundreds or thousands of network calls.\n\nCaching can be effective at improving build time provided the time to restore and save the cache is less than the time to produce the output again from scratch. Because of this, caching may not be effective in all scenarios and may actually have a negative impact on build time.\"\n\nAnswer is Yes","poster":"syu31svc"},{"timestamp":"1668949200.0","upvote_count":"1","content":"Selected Answer: A\nA is correct answer.","comment_id":"604359","poster":"Eltooth"},{"timestamp":"1668023040.0","poster":"UnknowMan","upvote_count":"1","comment_id":"599212","content":"Answer is correct"},{"content":"Selected Answer: A\ncorrect","poster":"rdemontis","comment_id":"574353","timestamp":"1664016900.0","upvote_count":"1","comments":[{"timestamp":"1674746040.0","comments":[{"comment_id":"963672","content":"It is both. A container image that has these tools already installed can be saved on the registry and then used.","poster":"xRiot007","timestamp":"1706276460.0","upvote_count":"1"}],"comment_id":"637425","upvote_count":"1","poster":"kennynelcon","content":"You said container before now ?"}]},{"poster":"Whirly","upvote_count":"1","timestamp":"1662303960.0","content":"Selected Answer: A\nhttps://docs.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops","comment_id":"560921"}],"unix_timestamp":1622958720,"answer_description":"","question_id":388,"answer_ET":"A","answers_community":["A (100%)"],"question_text":"Note: This question is part of a series of questions that present the same scenario. Each question in the series contains a unique solution that might meet the stated goals. Some question sets might have more than one correct solution, while others might not have a correct solution.\nAfter you answer a question in this section, you will NOT be able to return to it. As a result, these questions will not appear in the review screen.\nYou use Azure Pipelines to build and test a React.js application.\nYou have a pipeline that has a single job.\nYou discover that installing JavaScript packages from npm takes approximately five minutes each time you run the pipeline.\nYou need to recommend a solution to reduce the pipeline execution time.\nSolution: You recommend enabling pipeline caching.\nDoes this meet the goal?","question_images":[],"exam_id":55,"isMC":true,"answer":"A","url":"https://www.examtopics.com/discussions/microsoft/view/54689-exam-az-400-topic-7-question-64-discussion/","timestamp":"2021-06-06 07:52:00","topic":"7","choices":{"A":"Yes","B":"No"},"answer_images":[]},{"id":"dTHf8bq3qrkRgEMKgDSm","question_id":389,"answer_ET":"B","choices":{"A":"Yes","B":"No"},"timestamp":"2021-05-16 18:58:00","discussion":[{"poster":"Concay","timestamp":"1638676860.0","comment_id":"374663","upvote_count":"8","content":"Build image is a single task so multiple job doesnt help"},{"comment_id":"1103736","poster":"vsvaid","upvote_count":"1","content":"Selected Answer: B\nPipeline caching","timestamp":"1719085680.0"},{"comment_id":"643246","content":"Selected Answer: B\nhttps://docs.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops\n\n\"Pipeline caching can help reduce build time by allowing the outputs or downloaded dependencies from one run to be reused in later runs, thereby reducing or avoiding the cost to recreate or redownload the same files again. Caching is especially useful in scenarios where the same dependencies are downloaded over and over at the start of each run. This is often a time consuming process involving hundreds or thousands of network calls.\n\nCaching can be effective at improving build time provided the time to restore and save the cache is less than the time to produce the output again from scratch. Because of this, caching may not be effective in all scenarios and may actually have a negative impact on build time.\"\n\nAnswer is No","timestamp":"1675679340.0","poster":"syu31svc","upvote_count":"1"},{"poster":"Eltooth","upvote_count":"1","timestamp":"1668949200.0","comment_id":"604360","content":"Selected Answer: B\nB is correct answer."},{"upvote_count":"3","timestamp":"1664017020.0","poster":"rdemontis","comment_id":"574356","content":"Selected Answer: B\nsince the pipeline has a single job, parallel jobs make no sense.\ncorrect answer"},{"poster":"Indran","comment_id":"358941","content":"a yes, all will improve","comments":[{"upvote_count":"8","content":"No, as the pipeline has only a single job, enabling parallel jobs would not bring any improvement.","poster":"PauloSilesiano","timestamp":"1637347140.0","comment_id":"361550"}],"timestamp":"1637089080.0","upvote_count":"1"}],"answers_community":["B (100%)"],"answer_images":[],"answer":"B","isMC":true,"answer_description":"","exam_id":55,"question_text":"Note: This question is part of a series of questions that present the same scenario. Each question in the series contains a unique solution that might meet the stated goals. Some question sets might have more than one correct solution, while others might not have a correct solution.\nAfter you answer a question in this section, you will NOT be able to return to it. As a result, these questions will not appear in the review screen.\nYou use Azure Pipelines to build and test a React.js application.\nYou have a pipeline that has a single job.\nYou discover that installing JavaScript packages from npm takes approximately five minutes each time you run the pipeline.\nYou need to recommend a solution to reduce the pipeline execution time.\nSolution: You recommend enabling parallel jobs for the pipeline.\nDoes this meet the goal?","topic":"7","question_images":[],"url":"https://www.examtopics.com/discussions/microsoft/view/52902-exam-az-400-topic-7-question-65-discussion/","unix_timestamp":1621184280},{"id":"m4n5btZqh85lIId4vIUN","unix_timestamp":1584692520,"answer_description":"","answers_community":["B (64%)","A (36%)"],"answer_images":[],"topic":"7","url":"https://www.examtopics.com/discussions/microsoft/view/17036-exam-az-400-topic-7-question-66-discussion/","choices":{"B":"No","A":"Yes"},"question_text":"Note: This question is part of a series of questions that present the same scenario. Each question in the series contains a unique solution that might meet the stated goals. Some question sets might have more than one correct solution, while others might not have a correct solution.\nAfter you answer a question in this section, you will NOT be able to return to it. As a result, these questions will not appear in the review screen.\nYou plan to create a release pipeline that will deploy Azure resources by using Azure Resource Manager templates. The release pipeline will create the following resources:\n✑ Two resource groups\n✑ Four Azure virtual machines in one resource group\n✑ Two Azure SQL databases in other resource group\nYou need to recommend a solution to deploy the resources.\nSolution: Create two standalone templates, each of which will deploy the resources in its respective group.\nDoes this meet the goal?","question_images":[],"isMC":true,"answer":"B","timestamp":"2020-03-20 09:22:00","exam_id":55,"discussion":[{"comments":[{"poster":"hotspot02103","comment_id":"1335156","timestamp":"1735725960.0","content":"if the templates are standalone, you'll need a template of scope \"subscription\" to create the two RG's, then you need individual (2x) standalone templates scoped to the two RGs. That makes the standalone template 3x. You can't technically implement this with only 2x stand alone templates due to scoping issues (assuming non of the templates are nested, nor linked)","upvote_count":"1"},{"timestamp":"1702987680.0","poster":"KumaTed","upvote_count":"1","content":"the question notes that \"Some question sets might have more than one correct solution, while others might not have a correct solution.\"\nso , the answer should be A.","comment_id":"927354"},{"content":"yes, it will do but not best practice way","upvote_count":"5","comment_id":"450775","poster":"d0bermannn","timestamp":"1648118880.0"}],"poster":"TosO","timestamp":"1600582920.0","content":"A is correct - you can deploy several ARM templates in one deployment - just add different tasks or multiple ARM deployment steps in the task","upvote_count":"52","comment_id":"66220"},{"upvote_count":"21","content":"Agree with Tos0... but these ARM questions suck!","poster":"cavemanc82","comment_id":"72954","comments":[{"upvote_count":"4","timestamp":"1651446060.0","poster":"totalz","content":"Because the documents suck, still are!","comment_id":"471456"}],"timestamp":"1602331980.0"},{"poster":"vsvaid","upvote_count":"2","timestamp":"1719085800.0","comment_id":"1103737","content":"Selected Answer: A\nWe can deploy multiple ARM templates. Not best solution but will work"},{"comment_id":"1103637","upvote_count":"1","content":"Ignore my previous answer, I will go with No. Possible but not recommended","timestamp":"1719074400.0","poster":"vsvaid"},{"upvote_count":"1","content":"Seems like it is possible so A, though not best solution","poster":"vsvaid","timestamp":"1719074280.0","comment_id":"1103635"},{"timestamp":"1706276520.0","comment_id":"963673","poster":"xRiot007","upvote_count":"1","comments":[{"content":"Actually, I am not so sure about it. You need a master ARM template to control the other 2, and the question specifies nothing about that.","poster":"xRiot007","comment_id":"963679","upvote_count":"1","timestamp":"1706276820.0"}],"content":"A - Yes - you can deploy multiple templates in one deployment."},{"timestamp":"1694204820.0","upvote_count":"2","poster":"armvch","comment_id":"833413","content":"Selected Answer: B\nSure you can deploy it this way but it's not recommended approach"},{"poster":"AzureJobsTillRetire","comment_id":"781664","comments":[{"upvote_count":"1","comment_id":"963675","poster":"xRiot007","content":"Answer is A - Yes. You are not being asked here what is best practice, you are asked if it is possible, which it is.","timestamp":"1706276580.0"},{"content":"You need to recommend a solution.\nQuestion: Does this meet the goal?\nThe goal is that you would be recommending best practices.","upvote_count":"5","comment_id":"781665","poster":"AzureJobsTillRetire","timestamp":"1689798780.0"}],"content":"Selected Answer: B\nI think that we all agree that this is not best practice. The question asks what you would “recommend” as a solution, I do not think we should recommend this solution for the reason that this is not the best practice. Hence the answer has to be No – we do not recommend.","upvote_count":"7","timestamp":"1689798660.0"},{"content":"I think answer is B \nFor small to medium solutions, a single template is easier to understand and maintain. You can see all the resources and values in a single file. For advanced scenarios, linked templates enable you to break down the solution into targeted components. You can easily reuse these templates for other scenarios.\n\nhttps://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/linked-templates?tabs=azure-powershell","poster":"pkg007","comment_id":"670358","upvote_count":"3","timestamp":"1678931400.0"},{"poster":"syu31svc","content":"Selected Answer: B\nAnswer is No\n\nTo deploy your solution, you can use either a single template or a main template with many related templates. The related template can be either a separate file that is linked to from the main template or a template that is nested within the main template.","timestamp":"1676440680.0","comment_id":"647011","upvote_count":"4"},{"poster":"Eltooth","comment_id":"604361","timestamp":"1668949560.0","content":"Selected Answer: A\nTemplate 1 :\nResource Group 1\n4 x Azure VMs\n\nTemplate 2:\nResource Group 2\n2 x Azure SQL databases (if standalone)","upvote_count":"3"},{"comments":[{"content":"exactly, it's technically impossible due to scoping, not sure why all are marking A...\nyou either need 3x stand alone templates, or less templates but linked or nested !!","upvote_count":"1","comment_id":"1335158","timestamp":"1735726020.0","poster":"hotspot02103"}],"content":"Selected Answer: B\nTry creating it, you will find that you can't create it without linked templates.","upvote_count":"3","poster":"jay158","comment_id":"587987","timestamp":"1666155060.0"},{"poster":"Cheehp","content":"Selected during exam. \nYes.","timestamp":"1665742080.0","upvote_count":"1","comment_id":"585696"},{"comment_id":"581814","upvote_count":"2","timestamp":"1665060300.0","poster":"AlexLiourtas","content":"Selected Answer: A\nYou can use individual ARM templates to deploy to different resource groups."},{"content":"Selected Answer: A\nThe answer is Yes. You can use how many templates you want and add the relative tasks","comments":[{"comments":[{"poster":"rdemontis","upvote_count":"2","content":"Sorry, on second thought I'm afraid my previous answer might be wrong. \nMy doubt is that my solution is not in tune with the requirement in the question because probably standalone template means a single template with no other linked or nested ones. And if so, the correct answer to the question is No. As mentioned above you need both ARM templates to be nested or linked.","timestamp":"1664029860.0","comment_id":"574530"}],"poster":"rdemontis","timestamp":"1664028000.0","upvote_count":"2","content":"To be more precise, the solution works by using two standalone Nested Templates. In fact you can create the resource group in the main template and it is essential to use a related template (nested/linked) to create the resources contained in the resource group specifying a dependsOn. \n\nIt is also essential that the main has a scope at the subscription level. It must indicate the following schema:\n\n\"$schema\": \"https://schema.management.azure.com/schemas/2018-05-01/subscriptionDeploymentTemplate.json#\"\n\nhttps://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/deploy-to-subscription?tabs=azure-cli#resource-groups","comment_id":"574507"}],"comment_id":"574361","poster":"rdemontis","upvote_count":"2","timestamp":"1664017500.0"},{"timestamp":"1645733760.0","upvote_count":"2","content":"just remember that \"Some question sets might have more than one correct solution\"","poster":"s9p3r7","comment_id":"430952"},{"timestamp":"1640800500.0","upvote_count":"6","comment_id":"393967","poster":"Dalias","content":"got this in 30 Jun 2021 exams. scored 800+ marks. i answered as A."},{"content":"the solution is doable but it is not the one I would recommend. So, I would go for NO.","comments":[{"timestamp":"1655364780.0","upvote_count":"2","content":"The question is \"Does the solution meet the goal?\" not \"It is the recommended way?\"","comment_id":"502803","poster":"Quirkafleeg"}],"upvote_count":"2","poster":"samyoyoyo","timestamp":"1638090060.0","comment_id":"368548"},{"comment_id":"356108","upvote_count":"1","poster":"applemalik","timestamp":"1636794240.0","comments":[{"content":"The ARM template deployment task will create the group automatically if not exist if using deployment scope \"Resource Group\".\nIf using deployment scope \"Subscription\", then you should add the resource group inside the template.","upvote_count":"2","comment_id":"383184","poster":"mpindado","timestamp":"1639646940.0"}],"content":"It does not meet the goal. The two standalone templates will definitely deploy the VMs and the SQL to the respective groups. The challenge with this is creating the groups, which is part of the solution. So, it is no from me."},{"content":"Answer is Yes, \n Each template can be used to deploy resources to their respective resource group.","poster":"vglearn","comment_id":"289162","upvote_count":"5","timestamp":"1628796360.0"},{"comment_id":"287497","timestamp":"1628586540.0","poster":"namco23","upvote_count":"3","content":"Is B - Verified"},{"comment_id":"241708","timestamp":"1623505800.0","content":"each of which will deploy the resources in its respective group\nwhich ARM will deploy Resource Groups?\nAnswer No","upvote_count":"3","poster":"Dady9","comments":[{"content":"Actually, you can deploy to multiple resource groups by using nested or linked templates\nhttps://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/deploy-to-resource-group?tabs=azure-cli#deploy-to-multiple-resource-groups","timestamp":"1636204740.0","comment_id":"350941","poster":"monniq","upvote_count":"1","comments":[{"upvote_count":"1","comment_id":"383188","timestamp":"1639647180.0","content":"This is true but only in \"resource group\" scope and using a single task. So you may use a single task on the 1st resource group and link the ARM template for the 2nd resource group.\nYou are also able to deploy with 2 different arm tasks, one for each resource group.","poster":"mpindado"}]}]},{"content":"https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/linked-templates\n\n\"For small to medium solutions, a single template is easier to understand and maintain. You can see all the resources and values in a single file. For advanced scenarios, linked templates enable you to break down the solution into targeted components. You can easily reuse these templates for other scenarios.\"\n\nI get the impression that they would recommend a single standalone or multiple linked/nested, but not two separate standalone templates. I'm going with B - No","upvote_count":"5","timestamp":"1611058740.0","poster":"dx","comment_id":"138585"},{"timestamp":"1608982320.0","upvote_count":"1","comment_id":"120382","poster":"Atanu","content":"Ans is \"Yes\""},{"timestamp":"1608500460.0","upvote_count":"5","content":"B, the question says: \"You need to recommend.....\", and the recommendation is use nested or linked templates \nhttps://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/linked-templates\n\n B, the question says: \"You need to recommend.....\", and the recommendation is use nested or linked templates \nhttps://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-best-practices","poster":"zyxphreez","comments":[{"timestamp":"1613518200.0","poster":"cucuff","content":"Actually the question is \"Does this meet the goal?\". \nYes, it meets the goal, but is not the recommended way. Tricky question and still can't decide.","upvote_count":"3","comment_id":"159468"}],"comment_id":"114969"},{"timestamp":"1605528540.0","upvote_count":"2","comment_id":"89863","poster":"Yogothegreat","content":"B. No ( this is the correct answer as it cannot be Post Deployment ..it has to be Pre Deployment )","comments":[{"poster":"veselin465","upvote_count":"3","timestamp":"1633523040.0","content":"are you sure you are commenting the right question?","comment_id":"329598"}]},{"content":"https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/cross-resource-group-deployment?tabs=azure-powershell\nhttps://samcogan.com/deploying-resource-groups-with-arm-templates/\nIf you use two standalone templates you should anyway use nested or linked templates with dependsOn parameter, because before creating any resources in resource groups they must already exist. According to the solution statement, I think, the answer is No.","comment_id":"88153","timestamp":"1605262920.0","poster":"kcinofni","upvote_count":"6"}],"question_id":390,"answer_ET":"B"}],"exam":{"name":"AZ-400","isImplemented":true,"numberOfQuestions":558,"id":55,"lastUpdated":"12 Apr 2025","isMCOnly":false,"provider":"Microsoft","isBeta":false},"currentPage":78},"__N_SSP":true}