{"pageProps":{"questions":[{"id":"chRnVn303l6rVGnaUoGF","answer_description":"","timestamp":"2020-05-18 22:22:00","answers_community":["B (100%)"],"answer_images":[],"question_images":[],"isMC":true,"topic":"7","question_text":"Note: This question is part of a series of questions that present the same scenario. Each question in the series contains a unique solution that might meet the stated goals. Some question sets might have more than one correct solution, while others might not have a correct solution.\nAfter you answer a question in this section, you will NOT be able to return to it. As a result, these questions will not appear in the review screen.\nYou need to recommend an integration strategy for the build process of a Java application. The solution must meet the following requirements:\n✑ The builds must access an on-premises dependency management system.\n✑ The build outputs must be stored as Server artifacts in Azure DevOps.\n✑ The source code must be stored in a Git repository in Azure DevOps.\nSolution: Configure the build pipeline to use a Hosted VS 2019 agent pool. Include the Java Tool Installer task in the build pipeline.\nDoes this meet the goal?","question_id":416,"url":"https://www.examtopics.com/discussions/microsoft/view/20894-exam-az-400-topic-7-question-9-discussion/","choices":{"A":"Yes","B":"No"},"answer":"B","answer_ET":"B","exam_id":55,"discussion":[{"upvote_count":"10","timestamp":"1612162560.0","content":"The answer is no - https://azuredevopslabs.com/labs/vstsextend/octopus/","poster":"NKnab","comment_id":"148369"},{"timestamp":"1718981760.0","upvote_count":"1","content":"Selected Answer: B\nNo is the answer","poster":"vsvaid","comment_id":"1102763"},{"upvote_count":"1","poster":"gabo","content":"Doesn't Hosted pool mean \"Self-Hosted\" pool?","timestamp":"1711498500.0","comment_id":"1018218"},{"comment_id":"647664","upvote_count":"1","timestamp":"1676559120.0","content":"Selected Answer: B\nUse self-hosted agent\n\nAnswer is No","poster":"syu31svc"},{"poster":"UnknowMan","upvote_count":"1","comment_id":"598671","content":"Selected Answer: B\nNeed a self hosted agent","timestamp":"1667941020.0"},{"comment_id":"598548","content":"Selected Answer: B\nno the ans is self-hosted","poster":"demonite","upvote_count":"1","timestamp":"1667918220.0"},{"comment_id":"572856","poster":"rdemontis","timestamp":"1663835400.0","content":"Selected Answer: B\nanswer is no, we need to use a self hosted agent","upvote_count":"1"},{"timestamp":"1628786700.0","comment_id":"289083","content":"Answer is No","poster":"vglearn","upvote_count":"2"},{"timestamp":"1615298460.0","comment_id":"176491","upvote_count":"2","poster":"CristianN","content":"As of today there is no Hosted VS2017 agent pool, the choice is Azure Pipelines which incorporate hosted agent pools"},{"comment_id":"102097","content":"The answer is \"Yes\"\nIf configured the hosted agent pool will be able to reach the on premise management system\nhttps://docs.microsoft.com/en-us/azure/devops/pipelines/agents/agents?view=azure-devops&tabs=browser","poster":"ATS006300","comments":[{"timestamp":"1637990040.0","upvote_count":"1","poster":"Kalaismile06","content":"We can't use Hosted VS2017 agent to build Java App. so, the answer is \"NO\".","comment_id":"367590"},{"poster":"jitkv20","upvote_count":"1","content":"Sorry I'm starting with Azure devops. Reading through that article too, unless self hosted agent is installed in on-premise system, can we make use of build pipeline there? Here they say its MS hosted 2017 agent right?","timestamp":"1611716280.0","comment_id":"144504"},{"comment_id":"102845","poster":"junkz","upvote_count":"1","comments":[{"upvote_count":"1","timestamp":"1608685080.0","content":"Same confusing here, I think enable the Microsoft-hosted agent to access the on-premise dependency is an important setting, but it doesn't mention here. So I will choose No.","poster":"zalyoung","comment_id":"116882"}],"content":"I agree with that, but this extra config step is not mentioned in the answer, so not sure it can automatically be infered","timestamp":"1607144640.0"}],"timestamp":"1607060880.0","upvote_count":"3"},{"timestamp":"1605738120.0","content":"The answer is Yes","poster":"Fred64","comments":[{"poster":"Doenoe","content":"I dont think the answer is yes, the hosted agent pool would not be able to reach the on premise management system","comment_id":"99277","upvote_count":"11","timestamp":"1606745880.0","comments":[{"poster":"Duleep","timestamp":"1611605100.0","content":"agreed with you, answer should be NO, \"The builds must access an on-premises dependency management system\" hosted agent doesn't have access to on-premiss","comment_id":"143592","upvote_count":"3"}]}],"upvote_count":"1","comment_id":"91613"}],"unix_timestamp":1589833320},{"id":"594lbWG5nlgOlqMsCmiG","answer_description":"","question_images":["https://img.examtopics.com/az-400/image33.png"],"answers_community":[],"url":"https://www.examtopics.com/discussions/microsoft/view/96494-exam-az-400-topic-7-question-90-discussion/","question_text":"DRAG DROP -\n\nYou have an Azure DevOps pipeline that is used to deploy a Node.js app.\n\nYou need to ensure that the dependencies are cached between builds.\n\nHow should you configure the deployment YAML? To answer, drag the appropriate values to the correct targets. Each value may be used once, more than once, or not at all. You may need to drag the split bar between panes or scroll to view content.\n\nNOTE: Each correct selection is worth one point.\n\n//IMG//","topic":"7","answer_ET":"","exam_id":55,"timestamp":"2023-01-22 15:52:00","question_id":417,"discussion":[{"comment_id":"790883","content":"I think we are overthinking this one and it's typical MS confusing question. They probably want similar answer as on the given link https://learn.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops#conditioning-on-cache-restoration\n\nSo basically install dependencies (npm install) IF cache NOT restored. Therefore:\n- npm install\n- ne(variables.CACHE_RESTORED, 'true')\n\nThe build.sh would be below above script","comments":[{"comment_id":"1124809","poster":"Hillah","timestamp":"1705482000.0","upvote_count":"2","content":"You need to ensure that the dependencies are cached between builds.\nTherefore, we assume that npm is already installed, we only need to cache at build\nHence\n- build.sh\n- Eq(variables.CACHE_RESTORED, 'true')"},{"timestamp":"1702224180.0","poster":"mfawew223","comment_id":"1092620","content":"To support this, the comments have come to 2 different answers, but one doesnt make sense to design a pipeline that way.\n\nThe 2 answers can be described as either \"if npm is cached, then run build.sh\" or \"if npm is not cached, install npm\". Whats going to happen if the pipeline isnt cached? in the first answer, the pipeline would just stop/fail if npm isnt cached. So how would you have npm cached in the first place? \n\n For the 2nd answer, what happens if npm isnt cached? npm gets installed, then we move to the next step.\n\nThe step being shown isnt a build step. its a step that ensures that npm is installed BEFORE the build.sh uses npm in another step. The only thing this step should be doing is ensuring npm is installed for the rest of the pipeline. Thus, basiltomato's answer is the correct one","upvote_count":"2"}],"upvote_count":"37","timestamp":"1674928080.0","poster":"basiltomato"},{"poster":"wiokito","timestamp":"1674437820.0","upvote_count":"9","content":"i think it should be :\n- npm install\n- ne(variables.CACHE_RESTORED, 'true')\nhttps://learn.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops#conditioning-on-cache-restoration","comments":[{"upvote_count":"4","timestamp":"1674636780.0","poster":"wiokito","comment_id":"787427","content":"i edit my answer: the goal here is to \"ensure\" caching so the solution is:\n- build.sh\n- Eq(variables.CACHE_RESTORED, 'true')"}],"comment_id":"784850"},{"poster":"Mattt","comment_id":"1294711","upvote_count":"2","timestamp":"1728391140.0","content":"The answer is \n- npm install\n- ne(variables.CACHE_RESTORED, 'true')\n\n\nif the cache is empty, we sould run npm install.\nBuild should be run after that without any condition\n\nsteps:\n- task: Cache@2\n inputs:\n key: mykey | mylockfile\n restoreKeys: mykey\n path: $(Pipeline.Workspace)/mycache\n cacheHitVar: CACHE_RESTORED\n\n- script: npm install\n condition: ne(variables.CACHE_RESTORED, 'true')\n\n- script: build.sh"},{"upvote_count":"1","timestamp":"1721466060.0","poster":"sondrex","content":"Script: npm install\nCondition: ne(variables.CACHE_RESTORED, 'true')","comment_id":"1251641"},{"upvote_count":"2","content":"The Answer is correct: \nvariables:\n npm_config_cache: $(Pipeline.Workspace)/.npm\n\nsteps:\n- task: Cache@2\n inputs:\n key: 'npm | \"$(Agent.OS)\" | package-lock.json'\n restoreKeys: |\n npm | \"$(Agent.OS)\"\n path: $(npm_config_cache)\n cacheHitVar: CACHE_RESTORED\n \n- script: ./build.sh\n condition: ne(variables.CACHE_RESTORED, 'true')","timestamp":"1714902720.0","comment_id":"1206830","poster":"4bd3116"},{"content":"https://learn.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops","poster":"Kalaisuran","comment_id":"1182195","timestamp":"1711339320.0","upvote_count":"1"},{"content":"The 3 ... means that there is more of the pipline that is not shown, if we presume the parts of the pipline not shown are to do with the deployment we can deduce that we are dealing with the part of the pipeline that handles package installation. \n\nThjere for the answer is \n\n- npm install\n- ne(variables.CACHE_RESTORED, 'true')","comment_id":"1087166","timestamp":"1701644520.0","upvote_count":"3","poster":"4b31a3a"},{"upvote_count":"1","poster":"varinder82","content":"Final Answer after going through below comments\n\n- npm install\n- ne(variables.CACHE_RESTORED, 'true')","comment_id":"1083401","timestamp":"1701259560.0"},{"content":"trigger:\n- master\n\npool:\n vmImage: 'ubuntu-latest'\n\nsteps:\n- checkout: self\n\n- task: Cache@2\n inputs:\n key: 'npm | package-lock.json'\n path: $(Pipeline.Workspace)/.npm\n cacheHitVar: CACHE_RESTORED\n\n- script: npm ci\n displayName: 'npm ci'\n condition: ne(variables.CACHE_RESTORED, 'true')\n\n- script: npm run build\n displayName: 'npm build'","upvote_count":"1","comment_id":"1026978","poster":"CirusD","timestamp":"1696630260.0"},{"timestamp":"1695780840.0","comment_id":"1018355","upvote_count":"1","comments":[{"content":"On the other hand if you choose to run npm install, then it should run only if Cache is not restored, so choose ne(variables.CACHE_RESTORED, 'true')","timestamp":"1695937920.0","upvote_count":"1","comment_id":"1020238","poster":"gabo"}],"poster":"gabo","content":"If you choose to run the build.sh script, then that should run only if Cache is successfully restored, so choose eq(variables.CACHE_RESTORED, 'true')"},{"upvote_count":"2","poster":"Dats1987","timestamp":"1694039340.0","comment_id":"1000995","content":"In some scenarios, the successful restoration of the cache should cause a different set of steps to be run. For example, a step that installs dependencies can be skipped if the cache was restored. This is possible using the cacheHitVar task input. Setting this input to the name of an environment variable will cause the variable to be set to true when there's a cache hit, inexact on a restore key cache hit, otherwise it will be set to false. This variable can then be referenced in a step condition or from within a script.\n\nIn the following example, the install-deps.sh step is skipped when the cache is restored:\nsteps:\n- task: Cache@2\n inputs:\n key: mykey | mylockfile\n restoreKeys: mykey\n path: $(Pipeline.Workspace)/mycache\n cacheHitVar: CACHE_RESTORED\n\n- script: install-deps.sh\n condition: ne(variables.CACHE_RESTORED, 'true')\n\n- script: build.sh"},{"content":"1. build.sh\n2. ne(variables.CACHE_RESTORED, 'true')\n\nhttps://learn.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops#conditioning-on-cache-restoration","upvote_count":"5","poster":"zellck","comment_id":"913297","timestamp":"1685769420.0","comments":[{"comment_id":"1020239","timestamp":"1695937980.0","content":"This is incorrect. You are building the app if cache is not restored which will cause the pipeline to fail.","upvote_count":"1","poster":"gabo"}]},{"poster":"AlexeyG","upvote_count":"3","content":"variables:\n NUGET_PACKAGES: $(Pipeline.Workspace)/.nuget/packages\n\nsteps:\n- task: Cache@2\n inputs:\n key: 'nuget | \"$(Agent.OS)\" | $(Build.SourcesDirectory)/**/packages.lock.json'\n restoreKeys: |\n nuget | \"$(Agent.OS)\"\n nuget\n path: $(NUGET_PACKAGES)\n displayName: Cache NuGet packages\n\nAnswer on exam\n$(Build.SourcesDirectory)/**/packages.lock.json'\n\"$(Agent.OS)\"\n$(NUGET_PACKAGES)\n\ngot this in 02 March 2023 exams. scored 870 marks.","comment_id":"826872","timestamp":"1677759900.0"},{"upvote_count":"6","poster":"crymo99","comment_id":"789047","comments":[{"upvote_count":"1","timestamp":"1695938040.0","comment_id":"1020240","poster":"gabo","content":"This is incorrect. You are building the app if cache is not restored which will cause the pipeline to fail."}],"content":"I believe given answer is correct.\n- build.sh\n- ne(variables.CACHE_RESTORED, 'true')","timestamp":"1674760980.0"},{"comment_id":"785621","timestamp":"1674492600.0","upvote_count":"4","poster":"mrg998","content":"Answer is:\nNpm install - install\nEq(variables.CACHE_RESTORED, 'true') - only if cache has been restored\nhttps://learn.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops#conditioning-on-cache-restoration"},{"timestamp":"1674399120.0","poster":"3arle","comment_id":"784404","upvote_count":"3","content":"at first should be npm install, then build\nhttps://learn.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops#conditioning-on-cache-restoration"}],"isMC":false,"answer_images":["https://img.examtopics.com/az-400/image34.png"],"unix_timestamp":1674399120,"answer":""},{"id":"GCJIaYgA9jJdFj7SdBcL","answer_images":["https://www.examtopics.com/assets/media/exam-media/04257/0040000001.png"],"topic":"8","question_id":418,"answer_description":"Box 1: --aggressive -\nCleanup unnecessary files and optimize the local repository:\ngit gc --aggressive\n\nBox 2: prune -\nPrune all unreachable objects from the object database:\ngit prune\nReference:\nhttps://gist.github.com/Zoramite/2039636","exam_id":55,"answer":"","answer_ET":"","url":"https://www.examtopics.com/discussions/microsoft/view/48636-exam-az-400-topic-8-question-1-discussion/","unix_timestamp":1617281580,"timestamp":"2021-04-01 14:53:00","isMC":false,"question_images":["https://www.examtopics.com/assets/media/exam-media/04257/0039900001.png"],"question_text":"HOTSPOT -\nYou manage the Git repository for a large enterprise application.\nYou need to minimize the data size of the repository.\nHow should you complete the commands? To answer, select the appropriate options in the answer area.\nNOTE: Each correct selection is worth one point.\nHot Area:\n//IMG//","answers_community":[],"discussion":[{"timestamp":"1681380600.0","content":"answer correct. \n\n# Prune all unreachable objects from the object database\ngit prune\n\n# Cleanup unnecessary files and optimize the local repository\ngit gc —aggressive","poster":"SteveChai","upvote_count":"15","comment_id":"334559"},{"timestamp":"1680353580.0","poster":"denisred","content":"git gc --aggressive --prune=now","comment_id":"325833","upvote_count":"8"},{"timestamp":"1723457160.0","comment_id":"645851","content":"\"minimize the data size of the repository\"\n\nhttps://git-scm.com/docs/git-gc\n\n\"--aggressive\nUsually git gc runs very quickly while providing good disk space utilization and performance. This option will cause git gc to more aggressively optimize the repository at the expense of taking much more time.\n\n--prune=<date>\nPrune loose objects older than date (default is 2 weeks ago, overridable by the config variable gc.pruneExpire). --prune=now prunes loose objects regardless of their age and increases the risk of corruption\"\n\nAnswer is correct","upvote_count":"4","poster":"syu31svc"},{"timestamp":"1716206220.0","upvote_count":"1","comment_id":"604386","poster":"Eltooth","content":"--aggressive\nprune"},{"upvote_count":"1","timestamp":"1715282640.0","comment_id":"599249","poster":"UnknowMan","content":"Yes correct\n\ngit prune\ngit gc --aggressive"},{"comment_id":"581062","timestamp":"1712297820.0","content":"correct","poster":"rdemontis","upvote_count":"1"}]},{"id":"kOLWGyS2Nc6iXLJnT3Zk","answer_ET":"","answer_description":"Step 1: Delete and recreate the repository.\nStep 2: Add Config.json to the .gitignore file\nEach line in the .gitignore excludes a file or set of files that match a pattern.\nExample:\n# ignore a single file\n\nConfig.json -\nStep 3: Run the git add .gitignore command\nAt the initial commit we want basically move from Untracked to Staged, for staging we have to indicate which file we want to move or specify a pattern, as example:\nReference:\nhttp://hermit.no/how-to-find-the-best-gitignore-for-visual-studio-and-azure-devops/ https://geohernandez.net/how-to-add-an-existing-repository-into-azure-devops-repo-with-git/","unix_timestamp":1617447840,"answer":"","answer_images":["https://www.examtopics.com/assets/media/exam-media/04257/0041700001.png"],"exam_id":55,"topic":"8","isMC":false,"discussion":[{"comment_id":"327943","poster":"Sylph","content":"I think it should be:\nAdd Config.json to the .gitignore file.\nRun the git add .gitignore command.\nRun the git commit command.","timestamp":"1617537900.0","comments":[{"content":"Got this in 30 June 2021 exam. Scored 800+ followed this answer","upvote_count":"8","poster":"Dalias","comment_id":"394007","comments":[{"content":"King! Thank you!","poster":"rfox321","upvote_count":"1","timestamp":"1632563940.0","comment_id":"451360"}],"timestamp":"1624983180.0"},{"poster":"pexonconsulting","content":"same here","upvote_count":"2","timestamp":"1617861840.0","comment_id":"330935"},{"upvote_count":"2","timestamp":"1621340040.0","comment_id":"360470","poster":"Kinon4","content":"Agree on Sylph's answer"},{"timestamp":"1648203480.0","comment_id":"574936","upvote_count":"1","poster":"rdemontis","content":"you are right"},{"comment_id":"490980","content":"if you dont trust this answer test it and verify for yourself.","poster":"[Removed]","upvote_count":"2","timestamp":"1638304560.0"},{"comments":[{"upvote_count":"1","timestamp":"1654380420.0","content":"Thanks for sharing.","comment_id":"611592","poster":"FunkyB"}],"timestamp":"1644587160.0","content":"Got this question in Feb-2022 exam (scored 910+). Followed this answer.","poster":"Optimist_Indian","upvote_count":"20","comment_id":"545346"},{"comments":[{"comment_id":"691134","timestamp":"1665405240.0","content":"1. Adding config.json file to .gitignore file -> Assuming the .gitignore file already exists in the files. But not added to the git yet. \n2. `git add .gitignore` -> Adding the .gitignore file to the git, staging it\n3. `git commit` commiting the file to the local branch. \n\nAnswer by sylph makes sense.","poster":"ravikrg","upvote_count":"10"}],"upvote_count":"3","timestamp":"1660720200.0","comment_id":"647962","content":"DUDE .gitignore is a file, You create the file first then add your file paths into it and once you run the commit git will not commit the files specified in your .gitignore file. PLEASE dont fall for this one and try it yourself.","poster":"adsdadasdad"}],"upvote_count":"201"},{"timestamp":"1617645600.0","poster":"LeeVee","content":"Should be\n\n1. Run git add .gitignore\n2. Add config.json to the .gitignore\n3. Run git commit","comment_id":"328924","upvote_count":"34","comments":[{"poster":"lyggwtwtczxnhznebw","content":"Agreed. The .gitgnore file will not be created by default, so you need to add it manually","comment_id":"376998","comments":[{"upvote_count":"22","timestamp":"1623642180.0","poster":"zioalex","comments":[{"timestamp":"1624280940.0","content":"I misunderstood. This is the correct answer. Disregard comment below","poster":"lyggwtwtczxnhznebw","comment_id":"387131","upvote_count":"3"},{"timestamp":"1624019220.0","poster":"lyggwtwtczxnhznebw","comments":[{"poster":"celciuz","content":"\"git add .gitignore\" does not auto create the .gitignore file. You will need to manually create the .gitignore file in your project root then run \"git add .gitignore\" to add it as a newly added git file to be tracked and then to be committed by using git commit","timestamp":"1629289740.0","comment_id":"426844","upvote_count":"9"}],"upvote_count":"3","content":"This is wrong. git add .gitignore creates the gitignore file. There is no gitignore before running that command, so you cannot add anything to it","comment_id":"384806"}],"content":"This is wrong. If you add the file before modifying it you need to re-add later. The correct sequence is:\n1. Add config.json to the .gitignore\n2. Run git add .gitignore\n3. Run git commit","comment_id":"381504"}],"timestamp":"1623091860.0","upvote_count":"3"},{"upvote_count":"1","comment_id":"1171102","content":"Git add does not create the file but puts it in a staged state","poster":"virnay1","timestamp":"1710171660.0"}]},{"upvote_count":"1","timestamp":"1738260900.0","content":"It should be:\n1. Manually create the .gitignore file and add the config.json\n- Add Config.json to the .gitignore file.\n2. Run the \"git add\" command to stage the newly created .gitignore file \n- Run the git add .gitignore command.\n3. Commit the staged changes\n- Run the git commit command.","comment_id":"1349174","poster":"wahabajasco"},{"content":"1. Git add .gitignore\n2. Add config.json to the .gitignore file.\n3. git commit","comment_id":"1296241","timestamp":"1728676560.0","upvote_count":"2","poster":"UrbanRellik"},{"comment_id":"1278414","content":"1. Add config.json to the .gitignore\n2. Run git add .gitignore \n3. Run git commit","timestamp":"1725471960.0","upvote_count":"1","poster":"megleg"},{"content":"1. Add config.json \n2. Run git add .gitignore\n3. Run git commit","timestamp":"1703340120.0","comment_id":"1104056","poster":"vsvaid","upvote_count":"1"},{"poster":"yana_b","comment_id":"1016463","comments":[{"timestamp":"1728466200.0","comment_id":"1295066","upvote_count":"1","poster":"Mattt","content":"Correct answer"}],"upvote_count":"2","content":"Provided answer is correct:\n\nhttps://learn.microsoft.com/en-us/azure/devops/repos/git/ignore-files?view=azure-devops&tabs=visual-studio-2022\nEntries in a .gitignore or exclude file have no effect on files that Git already tracks. \n\nGit tracks files that you've previously committed. \n\nTo permanently remove a file from the Git snapshot so that Git no longer tracks it, but without deleting it from the filesystem, run the following commands:\n\ngit rm --cached <file path>\ngit commit <some message>\n\nThen, use a .gitignore or exclude file entry to prevent Git from reporting changes to the file.\n\nWe do not have the above options amongst the answers => delete & recreate the repo should be the 1st step.","timestamp":"1695619140.0"},{"timestamp":"1690539300.0","comment_id":"965470","content":"Answer is : \n1. Add the config file to the git ignore file \n2. Run git add to add the change to staging \n3. Run git commit to commit all staged changes.","poster":"xRiot007","upvote_count":"1"},{"timestamp":"1686214740.0","upvote_count":"2","poster":"dipti927","comment_id":"918050","content":"Correct Answer : \nAdd Config.json to the .gitignore file.\nRun the git add .gitignore command.\nRun the git commit command."},{"comments":[{"comments":[{"comment_id":"1295069","upvote_count":"1","timestamp":"1728466500.0","poster":"Mattt","content":"Sorry, we still haven't commited."}],"upvote_count":"1","poster":"Mattt","timestamp":"1728466320.0","content":"The given answer is correct.\nYou have alresdy commited the config file. Your commit stays in the history and config secrets leak to the git history.","comment_id":"1295068"}],"poster":"Pamban","content":"Moderator, please correct these answers. people are paying to these content and many members provide the evidence for the given answer is incorrect...","comment_id":"909899","upvote_count":"5","timestamp":"1685423280.0"},{"poster":"randomaccount123","content":"I think some people are getting confused and thinking git add .gitignore will add the file. It doesn't. That will just add the file to the staging area if it already exists. If it doesn't exist you will get an error. You therefore need to add config.json to the file first and then run git add to add it to the staging area. Then obviously once its in the staging area you can the commit it.","timestamp":"1680168420.0","upvote_count":"1","comment_id":"855546"},{"content":"Verified correct answer is : \n1-Add Config.json to the .gitignore file.\n2-Run the git add .gitignore command.\n3-Run the git commit command.","upvote_count":"2","timestamp":"1675531200.0","comment_id":"798196","poster":"AKhalid"},{"poster":"Atos","comments":[{"content":"Wrong, git add will not add the file. It will just add it to the staging area if it already exists. If it doesn't you will get an error.","timestamp":"1680168540.0","upvote_count":"1","poster":"randomaccount123","comment_id":"855550"}],"content":"\"Delete and recreate the repository\" - seems extremely harsh. Also it doesn't indicate that config.json was committed. I think we can rule this out.\n\"git reflog expire\" - this removes reflog entries, not really relevant. I think we can rule this out.\n\nSo now just the ordering:\n\n1. Run the git add .gitignore command - This will add the file for us to exclude config.json\n\n2. Add Config.json to the .gitignore file - makes sense adding something in our empty file to exclude.\n\n3. Run the git commit - This will add it to the repository.","timestamp":"1663770360.0","comment_id":"675214","upvote_count":"2"},{"content":"A . gitignore file is a plain text file where each line contains a pattern for files/directories to ignore.\n\nSo answer is \n\n1) Add Config.json to the .gitignore file.\n2) Run the git add .gitignore command.\n3) Run the git commit command.","comment_id":"644407","upvote_count":"4","timestamp":"1660033140.0","poster":"syu31svc"},{"content":"Run the git add .gitignore command\nAdd Config.json to the .gitignore file\nRun the git commit command\n\nhttps://stackoverflow.com/questions/10744305/how-to-create-a-gitignore-file#:~:text=gitignore%20file%20is%20not%20added,commit%20%2Dm%20%22message%22%20.","comment_id":"604411","upvote_count":"1","comments":[{"timestamp":"1653222420.0","upvote_count":"3","comment_id":"605470","poster":"Eltooth","content":"On labing this with Git you cannot run \"git add .gitignore\" command if the .gitignore file does not exist. \nSo you either manually create the .gitignore file first then add config.json file to it, or follow steps that @Sylph suggests at top of page."}],"timestamp":"1653050460.0","poster":"Eltooth"},{"upvote_count":"1","comment_id":"599279","content":"- Add manualy a gitignore file (git add .gitignore just add a file named .gitignore, is not a build in command)\n- Add Config.json to the gitignore file\n- Run git commit","timestamp":"1652126760.0","poster":"UnknowMan"},{"content":"1. Git Ignore command.\n2. Add Config.json to the .gitignore file.\n3. Run the git commit command.\nRun the git commit command.\nhttps://docs.microsoft.com/en-us/azure/devops/repos/git/ignore-files?view=azure-devops&tabs=visual-studio","timestamp":"1640258640.0","upvote_count":"1","comment_id":"507786","poster":"aroravibhu"},{"comment_id":"391505","content":"Got this in the AZ-400 exam (June 2021).","timestamp":"1624733520.0","upvote_count":"3","poster":"francis6170"},{"comments":[{"content":"Why would you delete and re-create entire repository just to ignore a file ?","comments":[{"comment_id":"386766","timestamp":"1624250520.0","upvote_count":"1","poster":"erickim007","content":"if you don't want to, you would remove GIT cache. if you don't, adding .gitignore file would not have impact to your codeline therefore will keep check in your config.json file."}],"comment_id":"385034","poster":"kanak01","upvote_count":"3","timestamp":"1624047000.0"},{"content":"this is only valid if that file has already been committed, which the question says nothing about. if it's untracked, adding it to the .gitignore and the git add git commit is enough.","poster":"CheesusCrust89","upvote_count":"2","timestamp":"1624880580.0","comment_id":"392868"}],"upvote_count":"5","content":"Guys, we do not need to but deleting repository is right thing to do because git cache and track changes. If you add .gitignore file to existing one, it does not likely affect your repository. If this answer option had 'git rm -r --cached', order would be \n\n1. git rm -r --cached\n2. git add .ignore\n3. add config.json to ignore list\n4. git commit\n\nHowever we don't have the option therefore the way we would do is;\n\n1. delete repo & recreate with .gitignore as this is part of your step in creating repo\n2. add config.json to ignore file list\n3. git commit\n\nso given answer is correct.","timestamp":"1623896580.0","poster":"erickim007","comment_id":"383839"},{"upvote_count":"2","timestamp":"1622977800.0","comment_id":"375944","poster":"Ravi22","comments":[{"comment_id":"379979","upvote_count":"5","poster":"kanak01","timestamp":"1623435360.0","content":"Swap 1 and 2"}],"content":"1. Run git add .gitignore\n2. Add config.json to the .gitignore\n3. Run git commit"},{"comment_id":"331119","upvote_count":"5","poster":"gokula2010","comments":[{"comment_id":"420271","poster":"k4d","content":"this is the correct answer. First you need to create this file manually, then add into git and commit change","timestamp":"1628166660.0","upvote_count":"4"}],"timestamp":"1617880440.0","content":"Question asking us to select three options, so it should be \n1. Add Config.json to the .gitignore file.\n2. Run the git add .gitignore command.\n3. Run the git commit command.\n\nIf question asking to select four then it should be valid to choose recreate the repo as first item otherwise it should not be valid."},{"upvote_count":"1","poster":"Jamboon","timestamp":"1617447840.0","comments":[{"poster":"veselin465","timestamp":"1617468240.0","content":"I was also surprised by that, so i did a little research\nIt looks like that the rules in .gitignore file only apply to untracked files. And according to the question, the config file has never been added in a commit, so it should be untracked, therefore there should not be a reason recreating the repo. One thing is sure, if the config file was actually tracked, then recreating would have been the only LISTED thing in this question you can do to untrack it (but of course there are better ways to do it). All this information came mainly from a stackoverflow discussion: https://stackoverflow.com/questions/7927230/remove-directory-from-remote-repository-after-adding-them-to-gitignore","upvote_count":"4","comment_id":"327497"}],"content":"Do you really need to recreate the repo?","comment_id":"327299"}],"timestamp":"2021-04-03 13:04:00","question_text":"DRAG DROP -\nYou manage the Git repository for a large enterprise application.\nDuring the development of the application, you use a file named Config.json.\nYou need to prevent Config.json from being committed to the source control whenever changes to the application are committed.\nWhich three actions should you perform in sequence? To answer, move the appropriate actions from the list of actions to the answer area and arrange them in the correct order.\nSelect and Place:\n//IMG//","answers_community":[],"url":"https://www.examtopics.com/discussions/microsoft/view/48920-exam-az-400-topic-8-question-10-discussion/","question_images":["https://www.examtopics.com/assets/media/exam-media/04257/0041600001.png"],"question_id":419},{"id":"R5sCvZCAQMp9qZ2vyXr1","url":"https://www.examtopics.com/discussions/microsoft/view/35765-exam-az-400-topic-8-question-11-discussion/","exam_id":55,"discussion":[{"comments":[{"timestamp":"1621081020.0","comment_id":"357820","content":"Wrong leh self hosted agent can run on rocker and it is cheaper than VM definitely","upvote_count":"4","comments":[{"content":"C -- ACI is correct \nhttps://devblogs.microsoft.com/devops/azure-devops-agents-on-azure-container-instances-aci/","timestamp":"1650258420.0","poster":"jay158","upvote_count":"2","comment_id":"587477"},{"upvote_count":"3","content":"Sorry, it is C because ACI can be cheap but it might take much longer to run so cost will increase.","poster":"Concay","comment_id":"376332","timestamp":"1623014100.0"}],"poster":"Concay"},{"content":"C is correct. You can also configure the scale set agent pool to have zero agents on standby to save cost. https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/agents?view=azure-devops&tabs=browser#faq","comment_id":"261193","timestamp":"1609954440.0","upvote_count":"9","poster":"ETKap"}],"poster":"passtest100","content":"Should be C\nIt requires self-hosted agent rather than Microsoft-hosted agent. It is better to use scale set according to the following link\nhttps://docs.microsoft.com/en-us/azure/devops/pipelines/agents/agents?view=azure-devops&tabs=browser\nAzure virtual machine scale set agents\nAzure virtual machine scale set agents are a form of self-hosted agents that can be auto-scaled to meet your demands. This elasticity reduces your need to run dedicated agents all the time. Unlike Microsoft-hosted agents, you have flexibility over the size and the image of machines on which agents run.\nYou specify a virtual machine scale set, a number of agents to keep on standby, a maximum number of virtual machines in the scale set, and Azure Pipelines manages the scaling of your agents for you.\nFor more information, see Azure virtual machine scale set agents.","upvote_count":"34","comment_id":"231800","timestamp":"1606814700.0"},{"timestamp":"1604414040.0","poster":"Hooters","upvote_count":"20","comments":[{"timestamp":"1623014160.0","comments":[{"poster":"prashantjoge","upvote_count":"2","comment_id":"579952","timestamp":"1648918860.0","comments":[{"content":"wrong azure agents can run on a self-hosted VM or on a container in the Self-hosted VM. Has nothing to do with ACI. So scalesets definitely. As it turns off after its done the job. See discussions","comment_id":"579970","timestamp":"1648920420.0","poster":"prashantjoge","upvote_count":"1"}],"content":"reduce cost, not time. It runs once 30 mins a day"}],"poster":"Concay","upvote_count":"1","content":"No it is not correct. It takes long forever to run.","comment_id":"376333"}],"comment_id":"211999","content":"B. Azure Container Instances - this will be less on price"},{"poster":"Dankho","content":"Selected Answer: B\nThe solution must minimize costs.","comment_id":"1332986","timestamp":"1735394400.0","upvote_count":"1"},{"poster":"sondrex","comment_id":"1251675","content":"Correct answer С\nBased on the most recent Microsoft documentation, the recommended compute type for the self-hosted agent in your Azure Pipelines build pipeline is:\n\nC. an Azure virtual machine scale set\n\nExplanation:\nAzure Virtual Machine Scale Sets (VMSS): This option is cost-effective for scenarios where you need to run build pipelines periodically and want to manage the scale of your virtual machines efficiently. VMSS allows you to automatically scale the number of VMs based on demand and set the number of VMs to zero when not in use, which helps minimize costs.","upvote_count":"1","timestamp":"1721469420.0"},{"poster":"uncledana","timestamp":"1720073580.0","comment_id":"1241870","content":"C - requires a self hosted agent","upvote_count":"1"},{"poster":"karthikwarrior","timestamp":"1718182140.0","comment_id":"1228909","upvote_count":"1","content":"B. Azure Container Instances\n\nExplanation:\n\nCost Efficiency: Azure Container Instances (ACI) are billed per second based on the resources you allocate to your container, making it a very cost-effective solution for workloads that run infrequently or for short durations.\nEase of Use: ACI is straightforward to set up and tear down, which suits a build pipeline running once daily for a short duration.\nScalability: While not as scalable as Kubernetes or VM scale sets for high-demand scenarios, ACI is perfect for intermittent and short-lived tasks, such as a daily build process.\nOptions A, C, and D generally involve higher ongoing costs due to their more persistent nature and additional management overhead:"},{"upvote_count":"3","comment_id":"1222632","timestamp":"1717244340.0","content":"C with number of standby agents set to 0 there will only be an agent spon up when there is a job. https://learn.microsoft.com/en-us/azure/devops/pipelines/agents/scale-set-agents?view=azure-devops","poster":"TheBigMan"},{"timestamp":"1716103680.0","content":"Selected Answer: C\nScale set allows you to configure the scale set agent pool to have zero agents on standby.\nif you set Number of agents to keep on standby to zero, for example to conserve cost for a low volume of jobs, Azure Pipelines starts a VM only when it has a job.\nReference:\nhttps://learn.microsoft.com/en-us/azure/devops/pipelines/agents/scale-set-agents?view=azure-devops#can-i-configure-the-scale-set-agent-pool-to-have-zero-agents-on-standby","upvote_count":"3","poster":"arr73","comment_id":"1213649"},{"poster":"vsvaid","timestamp":"1703341200.0","comment_id":"1104062","content":"Selected Answer: B\nContainer Instance","upvote_count":"1"},{"timestamp":"1701260340.0","upvote_count":"1","poster":"varinder82","content":"Final answer after going through all the comments \n\nAzure Container Instances","comment_id":"1083415"},{"timestamp":"1696632540.0","comment_id":"1026989","upvote_count":"4","content":"If the primary concern is cost minimization, then Azure Container Instances (ACI) can indeed be more cost-effective than Azure Virtual Machines for short-lived tasks or infrequent operations.\n\nAzure Container Instances bills per second, and for a task that runs for 30 minutes once a day, ACI might be a better financial choice. The advantage of ACI is that you only pay for the actual compute resources you consume, without any VM infrastructure overhead.","poster":"CirusD"},{"poster":"mtzaroon","content":"Selected Answer: C\nseems scale set","upvote_count":"2","comment_id":"1001509","timestamp":"1694088300.0"},{"upvote_count":"1","content":"Selected Answer: B\nChatGPT: For a build pipeline that runs once daily and takes 30 minutes to complete, I would recommend using Azure Container Instances to minimize costs. Azure Container Instances is a service that allows you to run containers directly, without the need for any virtual machine infrastructure. This makes it a cost-effective option for workloads that have short running times and do not require persistent storage, such as a build pipeline that runs once daily for 30 minutes. On the other hand, an Azure virtual machine scale set is designed to provide easy management of multiple virtual machines and automatic scaling of resources, which may not be necessary for this particular use case1. So, the best option would be B. Azure Container Instances.","poster":"pc1707","timestamp":"1692934680.0","comment_id":"989647"},{"upvote_count":"1","comment_id":"965475","poster":"xRiot007","content":"You are asked for the cheapest, not the fastest, considering this will run for half an hour a day, B - ACI is the correct answer.","timestamp":"1690539660.0"},{"timestamp":"1679140800.0","comments":[{"poster":"Fal991l","upvote_count":"2","comment_id":"867551","content":"It's backed by GTP.","timestamp":"1681235100.0"},{"poster":"Fal991l","upvote_count":"3","comment_id":"867567","content":"GPT: Using Azure virtual machines would provide more control over the size and image of the machine used for the self-hosted agent, allowing for a more cost-effective option that meets the requirements of the pipeline. It also provides the flexibility to easily adjust the size and configuration of the VM as needed, should the pipeline requirements change in the future.\n\nAzure Kubernetes Service (AKS) cluster and Azure Container Instances (ACI) are more suitable for running highly-scalable applications, and may not be necessary for a build pipeline that runs once daily for 30 minutes.\n\nAzure virtual machine scale sets are designed to automatically scale based on workload demand, which may be overkill for a pipeline that only runs once daily for 30 minutes.\n\nIn summary, option D - Azure virtual machines, is the most suitable and cost-effective compute type for the requirements of the build pipeline.","timestamp":"1681236060.0"}],"upvote_count":"4","content":"For this scenario, where the build pipeline requires a self-hosted agent and needs to run once daily for a period of 30 minutes, the most cost-effective compute type to recommend would be an Azure virtual machine.\n\nAzure virtual machines (VMs) can be created and configured with the required build tools and dependencies, and can be used as self-hosted agents for Azure Pipelines. They offer the flexibility to choose the appropriate size and configuration based on the workload requirements. Additionally, they can be started and stopped on-demand to save costs when not in use.\n\nAzure Kubernetes Service (AKS) cluster and Azure Container Instances (ACI) are container-based compute options, which are more suitable for running long-running, highly-scalable applications. They may not be the most cost-effective option for this scenario.\n\nAn Azure virtual machine scale set (VMSS) can automatically scale up or down based on the workload demand, but it may be overkill for a build pipeline that runs only once daily.","comment_id":"842738","poster":"adityagoel26"},{"comment_id":"808453","content":"Selected Answer: D\nAI has another option:\nAzure virtual machines would be the most cost-effective option for running a self-hosted agent for a daily 30-minute build pipeline. Virtual machines can be started and stopped as needed, allowing you to only pay for the compute resources you actually use. Additionally, virtual machine scale sets can automatically scale the number of agents based on demand, further optimizing costs. AKS and Azure Container Instances may be more appropriate for containerized workloads or applications that require high scalability, but for a simple daily build pipeline, virtual machines would be the best option.","timestamp":"1676384280.0","poster":"geobarou","upvote_count":"2"},{"timestamp":"1659685380.0","upvote_count":"3","comment_id":"642813","content":"Selected Answer: B\nhttps://docs.microsoft.com/en-us/azure/devops/pipelines/agents/docker?view=azure-devops\n\n\"minimize costs\" so all the more answer is B","poster":"syu31svc"},{"content":"Selected Answer: B\nAzure Pipelines scales in the agents when the number of idle agents exceeds the standby count for more than 30 minutes (configurable using Delay in minutes before deleting excess idle agents).\nhttps://docs.microsoft.com/en-us/azure/devops/pipelines/agents/scale-set-agents?view=azure-devops#how-azure-pipelines-manages-the-scale-set","comment_id":"638378","timestamp":"1658972100.0","upvote_count":"1","poster":"3tallah"},{"comment_id":"604413","poster":"Eltooth","timestamp":"1653050640.0","content":"Selected Answer: B\nB is correct answer.","upvote_count":"1"},{"timestamp":"1652127000.0","upvote_count":"1","comment_id":"599280","poster":"UnknowMan","content":"Selected Answer: B\nB do the job, fast creation, deletion and lowcost"},{"upvote_count":"3","poster":"rdemontis","timestamp":"1648204500.0","content":"Selected Answer: B\nAnswer is correct due to the less expensive solution.\nhttps://medium.com/@cloudlabs01/running-azure-self-hosted-agent-in-azure-container-instance-aci-ad1fa338d769","comment_id":"574940"},{"content":"Selected Answer: B\nThe solution must minimize costs, ACI is the cheapest workable solution","comment_id":"547604","timestamp":"1644913440.0","poster":"BesQpin","upvote_count":"1"},{"comment_id":"540320","upvote_count":"15","timestamp":"1643964840.0","poster":"lugospod","content":"Got this January 2022. Container services...got 100% on that part."},{"upvote_count":"2","poster":"Art3","timestamp":"1642962000.0","content":"Selected Answer: B\nB seems to be cheapest, you pay only for computing time.","comment_id":"530738"},{"comments":[{"comment_id":"626988","upvote_count":"2","content":"Your selected option doesn't match explaination. you selected scale-set (C), but you suggest ACI, answer B.","timestamp":"1656938340.0","poster":"basw77"}],"poster":"jay158","upvote_count":"4","comment_id":"519739","timestamp":"1641669900.0","content":"Selected Answer: C\nACI is cheapest. you pay only for build time.\nOther option will also work but will cost more."},{"comment_id":"459175","poster":"Kolego","upvote_count":"2","content":"I answered ACI. Not sure, 870pts, tho.","timestamp":"1633688760.0"},{"content":"ANS - C\nhttps://docs.microsoft.com/en-us/azure/devops/pipelines/agents/scale-set-agents?view=azure-devops","poster":"Sant25","timestamp":"1633065000.0","comment_id":"455295","upvote_count":"2"},{"upvote_count":"10","comment_id":"447828","timestamp":"1632082320.0","comments":[{"content":"Thank you for provisioning this link which ticks all the boxes. ACI is the answer which is a cheaper PAAS solution that can replace IAAS VMS when Microsoft hosted agents dont suit your requirement.","timestamp":"1652402040.0","comment_id":"600894","poster":"jvyas","upvote_count":"2"}],"content":"there are two questions in this problem\n1. could ACI be used in the scenario when a self-hosted agent is used?\nIt is a 'Yes'\n\n2. compared with VMSS, is ACI cheaper?\nIt is a \"Yes\", https://docs.microsoft.com/en-us/azure/container-instances/container-instances-restart-policy\n\"The ease and speed of deploying containers in Azure Container Instances provides a compelling platform for executing run-once tasks like build, test, and image rendering in a container instance.\n\nWith a configurable restart policy, you can specify that your containers are stopped when their processes have completed. Because container instances are billed by the second, you're charged only for the compute resources used while the container executing your task is running.\"\n\nhere is the solution with details \nhttps://devblogs.microsoft.com/devops/azure-devops-agents-on-azure-container-instances-aci/","poster":"poplovic"},{"upvote_count":"4","timestamp":"1626187140.0","content":"I prefer answer \"B. Azure Container Instances\" since self-hosted agent can run in Docker. Execution can be orchestrated with ACI instances. This works for Windows and Linux self-hosted agents.\n\nFrom docs:\nYou can set up a self-hosted agent in Azure Pipelines to run inside a Windows Server Core (for Windows hosts), or Ubuntu container (for Linux hosts) with Docker. This is useful when you want to run agents with outer orchestration, such as Azure Container Instances.\n\nhttps://docs.microsoft.com/en-us/azure/devops/pipelines/agents/docker?view=azure-devops","comment_id":"405500","poster":"saschgo"},{"upvote_count":"4","poster":"saschgo","comment_id":"405496","content":"I prefer answer \"B. Azure Container Instances\" since self-hosted agent can run in Docker. Execution can be orchestrated with ACI instances. This works for Windows and Linux self-hosted agents.\n\nFrom docs:\nYou can set up a self-hosted agent in Azure Pipelines to run inside a Windows Server Core (for Windows hosts), or Ubuntu container (for Linux hosts) with Docker. This is useful when you want to run agents with outer orchestration, such as Azure Container Instances.\n\nhttps://docs.microsoft.com/en-us/azure/devops/pipelines/agents/docker?view=azure-devops","timestamp":"1626187080.0"},{"upvote_count":"1","comment_id":"388167","content":"B is probably the right answer here, but in my experience, a Windows 10 Pro VM in Azure running a container is actually cheaper than running a container directly on Azure. However, because that's not an option, just running the agent on the VM directly, then the container is probably cheaper.","timestamp":"1624382160.0","poster":"swiftfoxmark2"},{"comment_id":"387339","poster":"itworxx","content":"B. Most cost effective.\nAccording to the Azure Calculator running a container for 3600 seconds (1 hour, just to counter the \"it is slower\" comments) using 4vCPU and 16GB mem costs $0.23. There's no way a VMSS is cheaper. Not even without any instances when it is not needed.","timestamp":"1624297740.0","upvote_count":"3"},{"upvote_count":"2","comment_id":"383845","timestamp":"1623897180.0","content":"The answer should be ScaleSet. Scaleset can works with custom images or built-in images that we can control the price. And also Scaleset can have zero as initial value and spin up a new VM as required.","poster":"erickim007"},{"upvote_count":"5","content":"I think is B. ACI is cheaper than a VM and We do not have any performance constraints:\nhttps://azure.microsoft.com/en-us/pricing/details/container-instances/\nAnd we can have our self-hosted agent also in ACI.","poster":"zioalex","comment_id":"381513","timestamp":"1623642780.0"},{"upvote_count":"1","poster":"GenXCoder","timestamp":"1623085800.0","content":"Outdated question.\nUse azure batch.","comment_id":"376934"},{"content":"Should be C.","poster":"TanmoyD","comment_id":"351438","timestamp":"1620339780.0","upvote_count":"3"},{"poster":"fihdsaHFHVKJFEV324","comment_id":"300389","comments":[{"content":"it should be ACI","poster":"fihdsaHFHVKJFEV324","timestamp":"1614448200.0","upvote_count":"6","comment_id":"300391"}],"upvote_count":"4","content":"https://github.com/TheCloudScout/ACI-Self-hosted-agents","timestamp":"1614447900.0"},{"timestamp":"1612711620.0","comments":[{"comment_id":"287891","poster":"egib","content":"hmmm I'm now relying more against C, didn't even consider it up until now.\n\nI think I'm going with C as well","upvote_count":"2","timestamp":"1612994640.0"}],"comment_id":"285593","content":"I think the best option is C. When creating the VMSS pool in Az Devops Project, you can set the \"Number of agents to keep on standby\" to zero to conserve cost for a low volume of jobs, and Azure Pipelines will start a VM only when it has a job\nRef: https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/scale-set-agents?view=azure-devops#create-the-scale-set-agent-pool","poster":"agueda","upvote_count":"8"},{"content":"B. Azure Container Instances","comment_id":"223719","timestamp":"1605885240.0","poster":"kumardeb","upvote_count":"3"},{"poster":"Hooters","timestamp":"1604518860.0","comment_id":"212984","content":"Self hosted agent can be hosted on a container and can be further used for running commands","upvote_count":"2"},{"comment_id":"211150","timestamp":"1604314560.0","upvote_count":"3","content":"I m not sure but dont need the container, azure vm is best pricing option\nCould be D??","poster":"eray95"}],"isMC":true,"answer_images":[],"topic":"8","answer_description":"","answers_community":["B (58%)","C (35%)","8%"],"answer_ET":"B","question_text":"You are designing a build pipeline in Azure Pipelines.\nThe pipeline requires a self-hosted agent. The build pipeline will run once daily and will take 30 minutes to complete.\nYou need to recommend a compute type for the agent. The solution must minimize costs.\nWhat should you recommend?","choices":{"A":"an Azure Kubernetes Service (AKS) cluster","B":"Azure Container Instances","D":"Azure virtual machines","C":"an Azure virtual machine scale set"},"unix_timestamp":1604314560,"question_id":420,"timestamp":"2020-11-02 11:56:00","answer":"B","question_images":[]}],"exam":{"isBeta":false,"isImplemented":true,"name":"AZ-400","id":55,"isMCOnly":false,"provider":"Microsoft","lastUpdated":"12 Apr 2025","numberOfQuestions":558},"currentPage":84},"__N_SSP":true}