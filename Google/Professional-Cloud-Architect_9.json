{"pageProps":{"questions":[{"id":"YMpgXqftOBAGGTYWWbX7","answer_ET":"B","topic":"1","isMC":true,"choices":{"A":"Add a taint to one of the nodes of the Kubernetes cluster. For the specific microservice, configure a pod anti-affinity label that has the name of the tainted node as a value.","B":"Use Istio's fault injection on the particular microservice whose faulty behavior you want to simulate.","C":"Destroy one of the nodes of the Kubernetes cluster to observe the behavior.","D":"Configure Istio's traffic management features to steer the traffic away from a crashing microservice."},"answers_community":["B (89%)","11%"],"unix_timestamp":1625114400,"timestamp":"2021-07-01 06:40:00","url":"https://www.examtopics.com/discussions/google/view/56640-exam-professional-cloud-architect-topic-1-question-135/","answer":"B","question_id":41,"answer_images":[],"discussion":[{"comments":[{"poster":"XDevX","upvote_count":"5","comment_id":"397102","timestamp":"1641153720.0","content":"I see it the same way - it is b)"}],"poster":"TotoroChina","timestamp":"1641041400.0","comment_id":"395833","upvote_count":"45","content":"Answer is B.\napplication crash, not node."},{"timestamp":"1641019200.0","upvote_count":"22","poster":"XDevX","comment_id":"395503","content":"I think that c) is not the correct answer.\nI am not a GKE or Kubernetes expert, so maybe I am wrong.\nMy understanding is, that in Kubernetes a microservice can run on pods on different nodes and one node can contain pods running differend microservices - so to kill one node will not kill a microservice but several pods running on that node. Please correct me if I am wrong."},{"content":"Selected Answer: B\nin this case Istio's fault injection on the particular microservice","timestamp":"1735967880.0","upvote_count":"1","poster":"plumbig11","comment_id":"1336265"},{"content":"Selected Answer: B\nBetween B and C.\n\nC is the wrong answer as the microservice may very well be running in one of the other nodes that were not destroyed.","poster":"de1001c","upvote_count":"2","comment_id":"1226187","timestamp":"1733588280.0"},{"poster":"hzaoui","content":"Selected Answer: B\nFault injection is a technique used in chaos engineering to deliberately introduce errors into a system to test its resilience and observe its behavior under failure conditions. Istio is a service mesh that can manage the traffic between microservices. It includes fault injection capabilities that enable you to simulate failures such as delays or crashed services without actually stopping the service or damaging the environment. This allows you to validate how the rest of your application reacts to the failure of a specific microservice.","comment_id":"1130637","upvote_count":"5","timestamp":"1721820180.0"},{"upvote_count":"1","poster":"ammonia_free","comment_id":"1123502","timestamp":"1721051880.0","content":"Selected Answer: B\nTesting Objective: The choice between options B and C depends on the testing objectives. If the goal is to understand the behavior of the system when a specific microservice fails (this is how the question is formulated), then a targeted approach (Option B) is more appropriate. If the goal is to understand the broader resiliency of the system to node failures, then Option C would be more relevant.\nMicroservice Focus: Given the question's focus on a specific microservice, Istio's fault injection (Option B) provides a more direct and controlled way to simulate the failure of that microservice and observe the system's response, aligning better with the scenario described."},{"poster":"spuyol","content":"Selected Answer: B\nKill one randomly selected k8s cluster node doesn't guarantee you kill pods of the microservice. The node could or colud not have microservices of that app running on it.","timestamp":"1720021380.0","upvote_count":"1","comment_id":"1112987"},{"content":"IMHO the right answer is C. This link clearly explains why (remember that we are in a testing environment, so what's the problem in generating a cras of an entire node of the cluster?):\nhttps://www.linkedin.com/pulse/google-cloud-architect-case-study-5-biswa-prakash-nayak/","timestamp":"1716572820.0","comments":[{"content":"The problem is that according to the question: \"During testing, you want to validate the behavior of your application in case a specific micsoservice should suddenly crash\"....Even on testing environment specific microservice can run on more then one node and not on the one you destroyed.....moreover you should not affect other parts o the application (other microservices running on the destroyed node)","timestamp":"1729861860.0","poster":"Gino17m","comment_id":"1202003","upvote_count":"1"}],"upvote_count":"1","comment_id":"1079581","poster":"JoeJoe"},{"content":"B is the correct option, if you deleted a node you will deleted more than the microservices that you wanted to eliminated.","poster":"MiguelMiguel","timestamp":"1714423140.0","comment_id":"1057174","upvote_count":"1"},{"poster":"someone2011","comment_id":"1018572","comments":[{"timestamp":"1711531560.0","comment_id":"1018574","poster":"someone2011","upvote_count":"2","content":"Probably C is the best to simulate the entire microservice crashing."}],"timestamp":"1711531440.0","upvote_count":"2","content":"https://istiobyexample.dev/fault-injection/\nIn a Kubernetes environment, you can approach chaos testing at different layers - for instance, by deleting pods at random, or shutting off entire nodes.\n\nBut failures also happen at the application layer. Infinite loops, broken client libraries - application code can fail in an infinite number of ways! This is where Istio fault injection comes in. You can use Istio VirtualServices to do chaos testing at the application layer, by injecting timeouts or HTTP errors into your services, without actually updating your app code. Let’s see how.\nSo both C and B work."},{"comment_id":"1011285","upvote_count":"2","timestamp":"1710858300.0","content":"B seems correct. Istio's fault injection is right way to introduce fault.","poster":"rakp"},{"content":"I think perhaps C is correct due to the very specific test scenario. Chaos testing would be great for generally resilience test but it wants to test the behaviour of the app when the microservice crashed. Shutting down the microservice seems the simplest way to test this scenario.","timestamp":"1702213260.0","comments":[{"timestamp":"1716573000.0","content":"I agree, mostly because we are in a testing environment, so a node crash is not a great disaster even if there are other microservices running in thst node's pods.","upvote_count":"1","poster":"JoeJoe","comment_id":"1079583"}],"poster":"BiddlyBdoyng","comment_id":"919966","upvote_count":"1"},{"comment_id":"827592","poster":"BeCalm","upvote_count":"1","content":"Isn’t Istio used in the context of Anthos vs. GKE?","timestamp":"1693698480.0"},{"content":"Selected Answer: B\nIstio fault injection :https://istiobyexample.dev/fault-injection/","comment_id":"766476","timestamp":"1688542980.0","poster":"roaming_panda","upvote_count":"2"},{"content":"Selected Answer: B\nB is the correct answer","comment_id":"744988","upvote_count":"1","timestamp":"1686732960.0","poster":"surajkrishnamurthy"},{"poster":"ale_brd_111","timestamp":"1685774460.0","comment_id":"734294","content":"Selected Answer: B\nIstio is replicated and replaced by Anthos service mesh, please update the answer.","upvote_count":"2"},{"upvote_count":"1","content":"Selected Answer: B\nB is ok","poster":"megumin","comment_id":"719531","timestamp":"1684224600.0"},{"poster":"Mahmoud_E","timestamp":"1681925040.0","upvote_count":"1","comment_id":"699217","content":"destroying a node is not really testing microservices failure"},{"poster":"DoodleDo","upvote_count":"2","content":"B is the right answer - reference - https://istio.io/latest/docs/tasks/traffic-management/fault-injection/","timestamp":"1680811560.0","comment_id":"688087"},{"timestamp":"1678615200.0","content":"Selected Answer: B\nB is the answer","upvote_count":"2","poster":"satyagade","comment_id":"666723"},{"timestamp":"1678254780.0","content":"I too think it is B and seems logical.. if you want to simulate a failure of the part of the application then inject some failure code and observe the behaviour. But the comments here says Istio is depricated.. does this mean it is totally not being used? Any help here will be helpful for the exam.","upvote_count":"1","poster":"Jay_Krish","comment_id":"663076"},{"content":"It should be B) ANTHOS fault injection (anthos is replacing Istio which is deprecated)","comment_id":"646435","timestamp":"1676319180.0","poster":"chickennuggets","upvote_count":"3"},{"timestamp":"1670462640.0","upvote_count":"4","poster":"Jabree12","comment_id":"612964","content":"Seems as if B is the correct answer since we want to see what happens if a specific microservice fails and not a whole node, just swap ISTIO for Anthos Service Mesh which is the new option."},{"content":"Selected Answer: C\nSorry C is the answen.,","comment_id":"603973","poster":"amxexam","upvote_count":"1","timestamp":"1668874920.0"},{"poster":"nkit","content":"CAUTION- ISTIO is deprecated in GKE, choose wisely.","timestamp":"1666249020.0","comment_id":"588469","upvote_count":"2"},{"comment_id":"577133","timestamp":"1664404740.0","poster":"brvinod","upvote_count":"4","content":"Selected Answer: B\nhttps://istio.io/latest/docs/tasks/traffic-management/fault-injection/"},{"upvote_count":"3","comments":[{"upvote_count":"4","timestamp":"1665759720.0","poster":"nkit","content":"Did all the questions came in your exams from this practice test? Please be careful while commenting.","comment_id":"585862"}],"content":"2/15/21 exam","poster":"azureaspirant","timestamp":"1660591260.0","comment_id":"548060"},{"timestamp":"1658331840.0","poster":"ks100","content":"Selected Answer: C\nthere is no mention of Istio / service mesh in the question.","comment_id":"528630","upvote_count":"2"},{"timestamp":"1657256820.0","poster":"OrangeTiger","upvote_count":"6","comment_id":"519362","content":"B will be worong Answer.\nThis question may update.\n'Warning: Istio on GKE has been deprecated. New clusters with this feature enabled will no longer be available after December 31, 2021. Istio on GKE will no longer be supported on existing clusters after September 30, 2022.'"},{"poster":"haroldbenites","content":"Go for B","timestamp":"1655270580.0","upvote_count":"1","comment_id":"501950"},{"content":"Selected Answer: B\nB) Please note that Istio is replicated and replaced by Anthos service mesh: https://cloud.google.com/anthos/service-mesh","poster":"PhilipKoku","comment_id":"501527","timestamp":"1655218680.0","upvote_count":"4"},{"poster":"anjuagrawal","upvote_count":"1","content":"Voted B","comment_id":"497297","timestamp":"1654738440.0"},{"upvote_count":"1","comment_id":"495965","content":"Selected Answer: B\nhttps://cloud.google.com/istio/docs/istio-on-gke/overview","timestamp":"1654597560.0","poster":"Bobch"},{"timestamp":"1654390920.0","content":"B is the correct answer\nhttps://istio.io/latest/docs/tasks/traffic-management/fault-injection/","poster":"vincy2202","comment_id":"494052","upvote_count":"1"},{"timestamp":"1653869460.0","poster":"cdcollector","content":"Selected Answer: B\nYou cannot force terminate a node in kubernetes, all options are to drain and gracefully shut down a node.","upvote_count":"1","comment_id":"490343"},{"poster":"joe2211","content":"Selected Answer: B\nvote B","upvote_count":"3","timestamp":"1653514200.0","comment_id":"486981"},{"timestamp":"1653278880.0","content":"Selected Answer: C\nC is correct, it introduces chaos ...","poster":"nileshlg","upvote_count":"1","comment_id":"484776","comments":[{"upvote_count":"1","comment_id":"498381","timestamp":"1654839480.0","content":"It introduces \"chaos\" between the users, not bw the Microservices. I prefer \"B\"","poster":"rajibdein"}]},{"timestamp":"1653131400.0","upvote_count":"3","poster":"ravisar","content":"Microservice runs on all nodes. The Micro service runs on Pod, Pod runs on Nodes. Nodes is nothing but Virtual machines. Once deployed the application microservices will get deployed across all Nodes. Destroying one node may not mimic the behaviour of microservice crashing as it may be running in other nodes. \n\nSo B is seems to be correct. istio fault injection is to test the resiliency of your application.","comment_id":"483263"},{"timestamp":"1653107220.0","content":"Selected Answer: B\nAnswer shoould be B","poster":"pakilodi","upvote_count":"1","comment_id":"483046"},{"comment_id":"459531","poster":"unnikrisb","timestamp":"1649488440.0","upvote_count":"3","content":"we use Istio for fault injection so Option B : YAML/ServiceMesh"},{"poster":"[Removed]","upvote_count":"3","content":"Should be B. Destroying a node can remove more sercices. Ask is one microservice.","comment_id":"449120","timestamp":"1647896580.0"},{"comment_id":"427997","timestamp":"1645354440.0","poster":"MikeB19","content":"Correction i mean d ic correct not c","upvote_count":"1"},{"poster":"AnilKr","comment_id":"418521","content":"C, istio's fault injection can be used here as its name suggests - https://istio.io/latest/docs/tasks/traffic-management/fault-injection/","upvote_count":"2","timestamp":"1643785860.0"},{"content":"B. Use Istioג€™s fault injection on the particular microservice whose faulty behavior you want to simulate.","comment_id":"404029","poster":"victory108","timestamp":"1641916260.0","upvote_count":"6"},{"comment_id":"403314","timestamp":"1641822240.0","poster":"milan74","content":"Agree on answer B.\nDocumentation link: https://istio.io/latest/docs/tasks/traffic-management/fault-injection/","upvote_count":"2"},{"content":"Answer: B","timestamp":"1641645120.0","comment_id":"401781","poster":"mbrueck","upvote_count":"1"},{"content":"Answer is B","upvote_count":"5","timestamp":"1641553680.0","comment_id":"400700","poster":"MamthaSJ"}],"answer_description":"","exam_id":4,"question_text":"You are developing your microservices application on Google Kubernetes Engine. During testing, you want to validate the behavior of your application in case a specific microservice should suddenly crash. What should you do?","question_images":[]},{"id":"0gNWGlax9xZkRUdZMs1b","question_id":42,"discussion":[{"upvote_count":"27","content":"A, App Engine, you just want you people dedicated to the App","poster":"kopper2019","comment_id":"397215","timestamp":"1656810960.0"},{"upvote_count":"13","comments":[{"upvote_count":"7","content":"But \"focus on just building code without having to create and maintain the underlying infrastructure\" => A right","timestamp":"1669900680.0","comment_id":"491664","poster":"joe2211"}],"comment_id":"450449","content":"AppEngine is regional. Millions of distributed global users = GkE.","timestamp":"1663956300.0","poster":"Rzla"},{"content":"Selected Answer: D\nD\nGKE - Auto mode is free from managing the underlying infra.","poster":"thewalker","timestamp":"1732789980.0","upvote_count":"1","comment_id":"1082431"},{"timestamp":"1726749060.0","content":"Selected Answer: A\nCompute Engine & Google Kubernetes Engine are not pure PaaS, so they will require some management and maintenance. So C & D are eliminated. Cloud Endpoints is also not best fit for the given requirement, so B is also eliminated.\nApp Engine is fully managed platform.","upvote_count":"6","comment_id":"1011291","poster":"rakp"},{"timestamp":"1700741820.0","content":"Selected Answer: A\nApp Engine would work","comment_id":"725096","upvote_count":"1","poster":"Aninina"},{"poster":"megumin","upvote_count":"1","comment_id":"719533","timestamp":"1700129460.0","content":"Selected Answer: A\nA is ok"},{"timestamp":"1688396760.0","upvote_count":"3","content":"App Engine is right choice, Developer can focus on developing code rather than worry about infrastructure. A is right","poster":"AzureDP900","comment_id":"626609"},{"timestamp":"1686181080.0","content":"The users are global but doesn't mean that app can't be regional. A is the correct answer it seems.","comment_id":"612968","upvote_count":"1","poster":"Jabree12"},{"comment_id":"585881","upvote_count":"2","timestamp":"1681487160.0","content":"Another dumb question. Does the company have an operations team? K8s is specifically meant for appcode devs to be abstracted away from infra and your devops/ops handles the infra making it so all a dev has to do is say \"here's my built container image that was built in a fully automated fashion that was completely abstracted from me after I merged my pull request\". Then again, test writes are def going for app engine here.","poster":"learner311"},{"comment_id":"548061","upvote_count":"2","poster":"azureaspirant","content":"2/15/21 exam","timestamp":"1676496060.0"},{"upvote_count":"1","poster":"mshry","content":"Selected Answer: A\nI am seeing some confusion in answers for questions relating to requests or concurrent sessions being served by a solution. I think we ought not to look at API rate limits being synonymous to data handling limits, as these are programming limits to that API. An analogy would be comparing the control plane request limits to the data limits.","timestamp":"1676131980.0","comment_id":"545409"},{"comment_id":"543489","timestamp":"1675910460.0","content":"go for A","upvote_count":"1","poster":"haroldbenites"},{"content":"Why not Cloud Endpoint?","poster":"anjuagrawal","upvote_count":"1","comment_id":"497301","timestamp":"1670557200.0","comments":[{"content":"Not to manage infra so it's A","timestamp":"1671245280.0","poster":"Urban_Life","comment_id":"503314","upvote_count":"1"}]},{"content":"Selected Answer: A\nA is the correct answer","poster":"vincy2202","upvote_count":"2","comment_id":"494056","timestamp":"1670209980.0"},{"poster":"ravisar","timestamp":"1669036920.0","content":"In GKE, you have to create underlying infrastructure. It is not PAAS. Only app engine provide capability for developers to focus on code. The GKE, you need to configure many other items Apart from Code. So A seems to be more accurate. Regarding global nature, the app engine application servers users globally. I agree that there may be little latency for regions other than NA, however since the focus of the question is \"Code\", I would select A.","comment_id":"483273","upvote_count":"4"},{"timestamp":"1668379800.0","content":"App Engine support limited numbers of languages, they does not mention which interface, so for flexibity i will go for D","comment_id":"477842","upvote_count":"1","poster":"XAliX"},{"poster":"danielfootc","content":"I would say it's App Engine for developers to focus on code.","comment_id":"465590","upvote_count":"2","timestamp":"1666333380.0"},{"comment_id":"461696","poster":"JasonL_GCP","content":"Can anyone tell me why the answer to the following question is D? I am not seeing any difference between this question and the one below.\n\nYour company has announced that they will be outsourcing operations functions. You want to allow developers to easily stage new versions of a cloud-based application in the production environment and allow the outsourced operations team to autonomously promote staged versions to production. You want to minimize the operational overhead of the solution. Which Google Cloud product should you migrate to?\n\nA. App Engine\nB. GKE On-Prem\nC. Compute Engine\nD. Google Kubernetes Engine","upvote_count":"1","comments":[{"poster":"BobbyFlash","content":"Question 110. Answer is A. Please try to review the discussion there and not to hijack this one.","upvote_count":"2","timestamp":"1672264380.0","comment_id":"511599"},{"comment_id":"462826","content":"By considering the number of concurrent requests, D is the appropriate answer.","upvote_count":"2","timestamp":"1665874260.0","poster":"JasonL_GCP"}],"timestamp":"1665689340.0"},{"comment_id":"454176","upvote_count":"2","poster":"rottzy","timestamp":"1664458860.0","content":"millions of users from a single region? then its App engine!"},{"upvote_count":"2","comment_id":"445901","content":"App Engine is like EBS Service in AWS. Its PAAS. Developer can focus on code.","poster":"anku15","timestamp":"1663328520.0"},{"upvote_count":"3","poster":"AnilKr","timestamp":"1659416520.0","content":"Option A make sense, App engine is fully managed service and developers don't need to worry about infrastructure. \nYou cannot change the region. Your app will be served from the region you chose when creating the app. Anyone can use the app, but users closer to the selected region will have lower latency.\n\nWhile the App Engine service itself operates in multiple regions, an App Engine app is served from a single region. The app will, however, scale across multiple zones within that region.","comment_id":"418516"},{"comment_id":"410971","timestamp":"1658412720.0","poster":"thunderpowerpaul","content":"App engine is regional only and not global, answer D is more suitable","upvote_count":"2"},{"upvote_count":"3","timestamp":"1657546860.0","poster":"victory108","comment_id":"404020","content":"A. App Engine"},{"comment_id":"401783","content":"A App Engine","poster":"mbrueck","upvote_count":"1","timestamp":"1657276380.0"},{"timestamp":"1657193820.0","poster":"MamthaSJ","content":"Answer is A","comment_id":"400826","upvote_count":"3"},{"comment_id":"400694","upvote_count":"2","content":"A is ok","timestamp":"1657184280.0","poster":"JeffClarke111"},{"content":"Its A\nhttps://cloud.google.com/appengine/docs/standard/go/how-requests-are-handled","poster":"crazyaboutazure","comment_id":"397181","timestamp":"1656800400.0","upvote_count":"4"},{"upvote_count":"4","poster":"XDevX","timestamp":"1656785340.0","comment_id":"397105","content":"IMHO it can be a) or d) - I have chosen a) in todays exam because of the requirement to just focus on code - in GKE you have to consider also other aspects..."},{"content":"Answer is D.\nMillions of concurrent users, App engine/GKE, which is better?","comments":[{"poster":"Linus11","content":"App Engine","comment_id":"422209","timestamp":"1660058100.0","upvote_count":"2"}],"poster":"TotoroChina","comment_id":"395837","timestamp":"1656672840.0","upvote_count":"2"}],"answer_ET":"A","answer":"A","answers_community":["A (92%)","8%"],"question_text":"Your company is developing a new application that will allow globally distributed users to upload pictures and share them with other selected users. The application will support millions of concurrent users. You want to allow developers to focus on just building code without having to create and maintain the underlying infrastructure. Which service should you use to deploy the application?","unix_timestamp":1625136840,"choices":{"A":"App Engine","D":"Google Kubernetes Engine","C":"Compute Engine","B":"Cloud Endpoints"},"url":"https://www.examtopics.com/discussions/google/view/56754-exam-professional-cloud-architect-topic-1-question-136/","timestamp":"2021-07-01 12:54:00","exam_id":4,"isMC":true,"answer_images":[],"topic":"1","question_images":[],"answer_description":""},{"id":"3lfqQAXzcV8BqLKO0m3N","answer_ET":"C","timestamp":"2021-07-01 07:01:00","choices":{"D":"Use a versioning strategy for the APIs that adds the suffix ג€DEPRECATEDג€ to the current API version number on every backward-incompatible change. Use the current version number for the new API.","A":"Create a distribution list of all customers to inform them of an upcoming backward-incompatible change at least one month before replacing the old API with the new API.","B":"Create an automated process to generate API documentation, and update the public API documentation as part of the CI/CD process when deploying an update to the API.","C":"Use a versioning strategy for the APIs that increases the version number on every backward-incompatible change."},"discussion":[{"content":"It is C","poster":"kopper2019","upvote_count":"35","comments":[{"content":"https://cloud.google.com/apis/design/versioning","poster":"sebafranek","comments":[{"timestamp":"1688665020.0","upvote_count":"5","content":"more specifically: https://cloud.google.com/apis/design/versioning#release-based_versioning","poster":"[Removed]","comment_id":"768022"}],"upvote_count":"9","timestamp":"1643984700.0","comment_id":"419686"}],"timestamp":"1641179760.0","comment_id":"397216"},{"upvote_count":"23","content":"Answer C\nAll Google API interfaces must provide a major version number, which is encoded at the end of the protobuf package, and included as the first part of the URI path for REST APIs. If an API introduces a breaking change, such as removing or renaming a field, it must increment its API version number to ensure that existing user code does not suddenly break.","timestamp":"1642083960.0","poster":"VishalB","comment_id":"405398"},{"poster":"plumbig11","upvote_count":"1","timestamp":"1735967940.0","comment_id":"1336266","content":"Selected Answer: C\nUse a versioning strategy for the APIs that increases the version number on every backward-incompatible change."},{"content":"Selected Answer: C\nBreaking changes = version bump in the API url","comment_id":"1226196","timestamp":"1733589000.0","poster":"de1001c","upvote_count":"1"},{"upvote_count":"1","poster":"spuyol","comment_id":"1142457","content":"Answer is A\nQuestion asks: You are responsible for the API lifecycle and want to ensure stability for your customers in case the API makes backward-incompatible changes.\n\nOption C is a must for the API lifecycle but doing only that will not help your customers. In my opinion they have to be notified of backward-incompatible changes with time enough to stay ready","timestamp":"1722961380.0"},{"timestamp":"1720695720.0","upvote_count":"3","poster":"convers39","comment_id":"1119764","content":"Selected Answer: C\nThis is not a GCP-specific or even cloud-specific question, but a development best practice. No need to look at other options."},{"content":"I had a test today. The overall question was almost the same, but question mentioned Apigee.","timestamp":"1717646160.0","poster":"mastrrrr","upvote_count":"4","comment_id":"1089028"},{"comment_id":"993236","poster":"heretolearnazure","content":"C is correct","timestamp":"1709229120.0","upvote_count":"1"},{"timestamp":"1702213500.0","content":"Maybe A on top of C but are we really going to mandate customers only have 1 month to be ready? I don't think so, use the version strategy and let them migrate when ready!","upvote_count":"1","comment_id":"919968","poster":"BiddlyBdoyng"},{"timestamp":"1701343860.0","upvote_count":"1","content":"Anyways option A is also a recommended best practice. Its version incompatible change afterall.","poster":"Atanu","comment_id":"910108"},{"upvote_count":"1","content":"Selected Answer: C\nClearly C","timestamp":"1697676780.0","poster":"gu_pp","comment_id":"874199"},{"content":"Selected Answer: C\nc version numbers cannot be changed as given in d","timestamp":"1695050100.0","comment_id":"842992","poster":"bharath2k5","upvote_count":"1"},{"poster":"CGS22","content":"Selected Answer: C\nThe correct answer is: C. Use a versioning strategy for the APIs that increases the version number on every backward-incompatible change.\n\nA versioning strategy for the APIs that increases the version number on every backward-incompatible change is the best way to ensure stability for your customers in case the API makes backward-incompatible changes. This will allow you to track the changes that have been made to the API and allow your customers to easily identify the latest version of the API.","timestamp":"1694259000.0","comment_id":"834000","upvote_count":"3"},{"content":"Selected Answer: C\nSee @seafranek comment","upvote_count":"1","comment_id":"794843","poster":"zerg0","timestamp":"1690853460.0"},{"timestamp":"1687421040.0","upvote_count":"1","content":"If 'A' is the correct answer, one would wonder why.\nThe new version might be back-ward incompatible but does not necessarily mean its a breaking one. In that case A might be sufficient, although C remains mandatoryBest Practice imho.","comment_id":"753176","poster":"HenkH"},{"poster":"surajkrishnamurthy","comment_id":"744991","upvote_count":"2","content":"Selected Answer: C\nC is the correct answer","timestamp":"1686733200.0"},{"upvote_count":"1","content":"Selected Answer: C\nC is ok","comment_id":"719536","poster":"megumin","timestamp":"1684224900.0"},{"timestamp":"1682567640.0","upvote_count":"1","comment_id":"705200","content":"option C","poster":"Balaji_Sakthi"},{"timestamp":"1679321640.0","content":"Selected Answer: C\nAnswer is C as per https://cloud.google.com/apis/design/versioning","comment_id":"674122","poster":"Aswincoder","upvote_count":"4"},{"timestamp":"1672767540.0","comment_id":"626620","poster":"AzureDP900","upvote_count":"2","content":"C is right answer"},{"poster":"Jabree12","comment_id":"612970","timestamp":"1670464020.0","upvote_count":"4","content":"A does not ensure stability for anyone. It's just a notification."},{"content":"Selected Answer: C\nversioning can be done using API gateway APIGEE","comment_id":"612551","poster":"kummimhk","upvote_count":"4","timestamp":"1670386200.0"},{"poster":"amxexam","content":"Selected Answer: C\nI am with C. But looking at depri called option in D made me worder there is something more to backward in compatable.\nhttps://cloud.google.com/endpoints/docs/openapi/lifecycle-management","comment_id":"604839","timestamp":"1669036320.0","upvote_count":"3"},{"timestamp":"1660481160.0","upvote_count":"2","comment_id":"547190","content":"Users can use a tool called kubemci (a tool to configure Kubernetes ingress to load balance traffic across multiple Kubernetes clusters) to create a LoadBalancer spread across clusters and associate an anycast IP.\nThis approach is now deprecated and Ingress for Anthos is the recommended way to deploy multi-cluster ingress moving forward.","poster":"jpco"},{"poster":"haroldbenites","comment_id":"543492","content":"Go for C.\nVersioning \nThis topic describes the versioning strategies used by Google APIs. In general, these strategies apply to all Google-managed services.\n\nSometimes it is necessary to make backwards-incompatible (or \"breaking\") changes to an API. These kinds of changes can cause issues or breakage for code that has dependencies on the original functionality.\n\nGoogle APIs use a versioning scheme to prevent breaking changes. Additionally, Google APIs make some functionality only available under certain stability levels, such as alpha and beta components.","upvote_count":"3","timestamp":"1660006020.0"},{"content":"Selected Answer: C\nit shoud be c","timestamp":"1658577060.0","poster":"Pime13","upvote_count":"2","comment_id":"530563"},{"timestamp":"1657258140.0","poster":"OrangeTiger","comment_id":"519367","upvote_count":"4","content":"I think C is the correct answer for versioning.\nBut isn't it necessary to inform API users?"},{"poster":"rajadhav","upvote_count":"2","timestamp":"1655255880.0","content":"Versioning of an API and documentation is implementation part of backward compatibility.\nBut changes should be inform to the customers well in advance.\nA is correct answer.","comment_id":"501825"},{"comment_id":"495984","upvote_count":"2","timestamp":"1654598220.0","poster":"Bobch","content":"Answer C\nhttps://cloud.google.com/apis/design/compatibility"},{"poster":"vincy2202","timestamp":"1654393020.0","comment_id":"494061","upvote_count":"2","content":"C is the correct answer"},{"content":"Selected Answer: C\nvote C","poster":"joe2211","timestamp":"1653514320.0","upvote_count":"5","comment_id":"486982"},{"poster":"pakilodi","timestamp":"1653107400.0","upvote_count":"3","content":"Selected Answer: C\nThe answer is C","comment_id":"483048"},{"timestamp":"1652446980.0","upvote_count":"1","poster":"[Removed]","content":"Suggested A is wrong. Correct Answer is C","comment_id":"477558"},{"timestamp":"1643783940.0","content":"Google APIs use a versioning scheme to prevent breaking changes and hence C","comment_id":"418511","poster":"AnilKr","upvote_count":"2"},{"timestamp":"1642272240.0","content":"@kopper 2019, thank you for this. where can i find these questions? All 21 new Qs in Question #152\"","comment_id":"407302","poster":"Dia","upvote_count":"1"},{"comments":[{"upvote_count":"1","comment_id":"780601","content":"NO LAS ENCUENTRO","poster":"[Removed]","timestamp":"1689720780.0"}],"upvote_count":"2","timestamp":"1642224000.0","poster":"kopper2019","content":"hey guys new Qs posted as of July 12th, 2021, All 21 new Qs in Question #152","comment_id":"406713"},{"content":"21 NEw Qs - July 12, 2021\n7. For this question, refer to the TerramEarth case study.The application from your private data center to Google Cloud. The TerramEarth Security team sent you several recent Linux vulnerabilities published by common vulnerabilities and exposures (CVE). You need assistance in understanding how these vulnerabilities could impact your migration. What should you do?Choose two answers\na. Read the CVE’s from the Google Cloud status dashboard to understand the impact\nb. Read the CVE’s from the Google Cloud platform security bulletins to understand the\nimpact\nc. Open a support case regarding the CVE and chat with the support engineer\nd. Post a question regarding the CVE in stack overflow to get an explanation\ne. Post a question regarding the CVE in a Google Cloud discussion group to get an answer\nAnswer B, C, please share you answers","poster":"kopper2019","timestamp":"1642218600.0","comment_id":"406608","upvote_count":"7"},{"upvote_count":"3","poster":"kopper2019","comment_id":"406605","content":"21 New Qs - July 12, 2021\n6. For this question, refer to the TerramEarth case study. TerramEarth has legacy web application that you cannot migrate to cloud. However you still want to build a cloud native way to monitor the application. If the application goes down you want the URL to point to “site is unavailable” page as soon as possible. You also want your ops team to receive a notification for the issue. You need to build a reliable solution for minimum cost. What should you do?\na. Create a cron job on a Compute Engine VM that runs every minute. The cron job invokes a python program to check the application URL.If the application is down, switch the\nURL to the “site is unavailable”page, and notify the ops team","timestamp":"1642218540.0","comments":[{"content":"D - Cloud monitoring uptime checks can be used to check availability of a URL and set alert policy : https://cloud.google.com/monitoring/uptime-checks\nWhat do you think?","timestamp":"1642506180.0","poster":"syvoon","comment_id":"408845","comments":[{"comment_id":"428376","comments":[{"poster":"exo_k","upvote_count":"7","content":"https://cloud.google.com/blog/products/management-tools/how-to-use-pubsub-as-a-cloud-monitoring-notification-channel\nvote for D","timestamp":"1645696560.0","comment_id":"430579"}],"upvote_count":"1","content":"Uptime check can't use PubSub as notification channel. I suppose B is correct","poster":"giorgio64","timestamp":"1645395780.0"}],"upvote_count":"9"}]},{"upvote_count":"3","content":"C. Use a versioning strategy for the APIs that increases the version number on every backward-incompatible change.","poster":"victory108","timestamp":"1641915600.0","comment_id":"404019"},{"content":"Answer is C","timestamp":"1641645300.0","comment_id":"401790","upvote_count":"1","poster":"mbrueck"},{"comment_id":"400827","poster":"MamthaSJ","content":"Answer is C","upvote_count":"4","timestamp":"1641562740.0"},{"content":"A and B still break the API. So does D but by changing the URL. Right answer should be C","timestamp":"1641040860.0","poster":"Enzian","comment_id":"395825","upvote_count":"5"},{"timestamp":"1641020460.0","upvote_count":"1","poster":"XDevX","content":"Have you any reference regarding a)? I google now but I found no concrete best practice in that matter. \nWhat I found is the following:\nFundamentally, if client code could refer to something, then removing or renaming it is a breaking change and must result in a major version increase. Code referring to the old name will cause failures at compile-time for some languages (such as C# and Java) and may cause execution-time failures or data loss in other languages. Wire format compatibility is irrelevant here.\nhttps://cloud.google.com/apis/design/compatibility#backwards-incompatible_breaking_changes\nSo I tend to c) instead of a)","comment_id":"395527"}],"exam_id":4,"unix_timestamp":1625115660,"answer_description":"","answer":"C","question_id":43,"question_images":[],"isMC":true,"answer_images":[],"url":"https://www.examtopics.com/discussions/google/view/56656-exam-professional-cloud-architect-topic-1-question-137/","answers_community":["C (100%)"],"topic":"1","question_text":"Your company provides a recommendation engine for retail customers. You are providing retail customers with an API where they can submit a user ID and the\nAPI returns a list of recommendations for that user. You are responsible for the API lifecycle and want to ensure stability for your customers in case the API makes backward-incompatible changes. You want to follow Google-recommended practices. What should you do?"},{"id":"BQUNJJSGLCtSL08nOuZ4","question_id":44,"isMC":true,"question_images":[],"exam_id":4,"timestamp":"2021-07-03 03:16:00","answer_ET":"C","question_text":"Your company has developed a monolithic, 3-tier application to allow external users to upload and share files. The solution cannot be easily enhanced and lacks reliability. The development team would like to re-architect the application to adopt microservices and a fully managed service approach, but they need to convince their leadership that the effort is worthwhile. Which advantage(s) should they highlight to leadership?","answer_description":"","discussion":[{"timestamp":"1641180960.0","content":"decoupling, new features, CI/CD, A/B testing, scaling is the advantage so C","upvote_count":"23","comment_id":"397239","poster":"Mitra123"},{"timestamp":"1642224000.0","poster":"kopper2019","content":"hey guys new Qs posted as of July 12th, 2021, All 21 new Qs in Question #152","upvote_count":"12","comments":[{"poster":"bishalsainju","timestamp":"1652004180.0","comments":[{"content":"+1. Please let me know as well.","timestamp":"1667724300.0","poster":"tannV","upvote_count":"2","comment_id":"597591","comments":[{"content":"Almost questions ware replaced、when i 2nd try.Good luck.","comment_id":"1124685","upvote_count":"1","poster":"OrangeTiger","timestamp":"1721184960.0"}]},{"comment_id":"611813","content":"+ 1 Please let me know as well.","timestamp":"1670249940.0","poster":"YAS007","upvote_count":"2"}],"upvote_count":"4","comment_id":"474264","content":"Hey man do you know if in second attempt as well, we get these same questions?"}],"comment_id":"406720"},{"content":"Here they need to convince why the effort is worthwhile - to prove that you will talk on enhancements hence C. All of these lead to cost reduction/saving eventually.","comment_id":"827866","timestamp":"1693729200.0","upvote_count":"1","poster":"PST21"},{"timestamp":"1686733320.0","comment_id":"744992","poster":"surajkrishnamurthy","content":"Selected Answer: C\nC is the correct answer","upvote_count":"1"},{"timestamp":"1684391280.0","upvote_count":"2","poster":"FenixRa73","content":"I had the same question on the exam, my choice was A, passed","comment_id":"721172"},{"upvote_count":"1","poster":"megumin","timestamp":"1684225020.0","comment_id":"719537","content":"Selected Answer: C\nC is ok"},{"poster":"samsonakala","comment_id":"706709","timestamp":"1682707860.0","upvote_count":"1","content":"C most definitely. Following the best practice."},{"content":"C is better: Management like to understand business benefit in simple language. They don't bother about the technology","comment_id":"632803","timestamp":"1674019560.0","poster":"Sitender","comments":[{"timestamp":"1710859920.0","upvote_count":"1","poster":"rakp","content":"Agree with you. Isn't A the simplest answer. It says all the same things as C, just without any technicality.","comment_id":"1011314"}],"upvote_count":"2"},{"upvote_count":"3","timestamp":"1672767660.0","content":"C clearly states all of the benefits, C is right.","comment_id":"626621","poster":"AzureDP900"},{"comments":[{"upvote_count":"1","timestamp":"1670047500.0","poster":"9xnine","content":"HA is not mentioned in the question, reliability is, but decoupling the architecture improves reliability.","comment_id":"610892"}],"poster":"amxexam","content":"Selected Answer: B\nThere is very less discussion for this question.\n.I thing we are forgetting reliablity or HA.\nI am voting for B","comment_id":"604843","timestamp":"1669036560.0","upvote_count":"2"},{"poster":"ryzior","timestamp":"1667551320.0","content":"Devs will talk to their managers - so more technically, then the managers will talk to their managers (maybe CxO level) and they will talk 'money'. So I think the correct answer is C but A is still quite possible in very flat organizations. Again the question is asked in some context which is not expressed :(","comments":[{"timestamp":"1667551500.0","content":"and CxOs are not interested in 'easier' or 'automatically' which are parts of A answer, the job to make things easier/less cumbersome are on the low level managers or leads of the streams :)","poster":"ryzior","upvote_count":"1","comment_id":"596563"}],"comment_id":"596560","upvote_count":"2"},{"comment_id":"589666","content":"Selected Answer: C\nC to decouple infrastructure from application, the development team want a fully managed service approach","timestamp":"1666401600.0","poster":"wilwong","upvote_count":"2"},{"content":"C. \"develop and release new features\". Work as a dev in any environment. All leadership cares about is \"first to market\" and differentiators.","poster":"learner311","timestamp":"1665762720.0","upvote_count":"2","comment_id":"585883"},{"poster":"[Removed]","content":"Selected Answer: C\nI got similar question on my exam. Answered C.","upvote_count":"5","comment_id":"545508","timestamp":"1660243680.0"},{"upvote_count":"2","comment_id":"527716","timestamp":"1658240640.0","comments":[{"timestamp":"1658664000.0","content":"do you have the same response to every question","poster":"pgarg2000","comment_id":"531344","upvote_count":"6"}],"content":"Got this question in my exam, answered C","poster":"technodev"},{"poster":"OrangeTiger","upvote_count":"4","timestamp":"1657258500.0","content":"I vote A.\nManagement is concerned about costs.\nA is the only option that touches on costs.","comment_id":"519371"},{"upvote_count":"2","timestamp":"1654739520.0","content":"The answer should be between A or C. Choice is to be made between cost effective or Scaling respectively. They have to convince leadership on the effort and not cost so I think we can go for C.","comment_id":"497305","poster":"anjuagrawal"},{"content":"Selected Answer: C\nC is OK","comment_id":"496945","poster":"Bobch","upvote_count":"1","timestamp":"1654698120.0"},{"content":"C is the correct answer","comment_id":"494063","upvote_count":"1","timestamp":"1654393740.0","poster":"vincy2202"},{"content":"Selected Answer: C\nvote C","comment_id":"486991","upvote_count":"4","timestamp":"1653515460.0","poster":"joe2211"},{"upvote_count":"3","content":"CEO and COO do not care about CI/CD","comment_id":"478447","poster":"nansi","timestamp":"1652579520.0"},{"content":"Today passed the exam, I choose C","upvote_count":"3","timestamp":"1651585560.0","comments":[{"content":"Hey man, do you know smo who gave it on the second attempt, and got the same questions?","poster":"bishalsainju","upvote_count":"3","comments":[{"content":"+1. Any input will be helpful.","comment_id":"592912","upvote_count":"1","poster":"tannV","timestamp":"1666852560.0"}],"comment_id":"474263","timestamp":"1652004120.0"}],"comment_id":"472146","poster":"MaxNRG"},{"content":"I would choose C as well.","upvote_count":"2","timestamp":"1650522780.0","poster":"danielfootc","comment_id":"465593"},{"comment_id":"440361","timestamp":"1646581740.0","poster":"JustJack21","content":"C - based on how much longer it is compared to the rest.","upvote_count":"2"},{"comment_id":"440090","content":"C is OK","poster":"Cloud4us","upvote_count":"2","timestamp":"1646547540.0"},{"upvote_count":"4","poster":"victory108","comment_id":"405135","content":"C. The new approach will make it easier to decouple infrastructure from an application, develop and release new features, manage the underlying infrastructure, manage CI/CD pipelines and perform A/B testing, and scale the solution if necessary.","timestamp":"1642056900.0"},{"poster":"taoj","content":"BAD QUESTION!\nDoes leadership mean the head of the company? the head of the department?the head of the team?\ndifferent people concern different stuff.\n\nA or C\nA for me","comments":[{"comment_id":"512205","timestamp":"1656502500.0","content":"I was thinking about the same thing. If you are presenting to the CxO team, It would be A, and their focus is to make the company more profitable, and don't really care about technical details.","upvote_count":"1","poster":"RegisFTM"},{"content":"I'm with you on this one. Senior leadership do not know what A/B, CI/CD is in principle.","poster":"pr2web","timestamp":"1645383540.0","upvote_count":"3","comment_id":"428276"},{"comment_id":"437015","poster":"MikeB19","timestamp":"1646134440.0","content":"I agree a or c. Actually both answers are right This question is a matter of opinion","upvote_count":"1"}],"upvote_count":"6","comment_id":"403606","timestamp":"1641871980.0"},{"poster":"mbrueck","content":"Answer: C","timestamp":"1641645420.0","upvote_count":"2","comment_id":"401791"},{"poster":"MamthaSJ","comment_id":"400829","timestamp":"1641562860.0","upvote_count":"5","content":"Answer is C"},{"poster":"kopper2019","comment_id":"397217","content":"It is C","upvote_count":"5","timestamp":"1641179760.0"}],"answers_community":["C (88%)","13%"],"topic":"1","unix_timestamp":1625274960,"choices":{"D":"The process can be automated with Migrate for Compute Engine.","B":"The monolithic solution can be converted to a container with Docker. The generated container can then be deployed into a Kubernetes cluster.","C":"The new approach will make it easier to decouple infrastructure from application, develop and release new features, manage the underlying infrastructure, manage CI/CD pipelines and perform A/B testing, and scale the solution if necessary.","A":"The new approach will be significantly less costly, make it easier to manage the underlying infrastructure, and automatically manage the CI/CD pipelines."},"url":"https://www.examtopics.com/discussions/google/view/56976-exam-professional-cloud-architect-topic-1-question-138/","answer_images":[],"answer":"C"},{"id":"mOMyYnkWz2pOlDspsE3g","answer_description":"","answer":"A","answer_images":[],"discussion":[{"timestamp":"1626314520.0","content":"21 NEw Qs - July 12, 2021\n# 15. An application development team has come to you for advice.They are planning to write and deploy an HTTP(S) API using Go 1.12. The API will have a very unpredictable workload and must remain reliable during peaks in traffic. They want to minimize operational overhead for this application. What approach should you recommend?\n\na. Use a Managed Instance Group when deploying to Compute Engine\nb. Develop an application with containers, and deploy to Google Kubernetes Engine (GKE)\nc. Develop the application for App Engine standard environment\nd. Develop the application for App Engine Flexible environment using a custom runtime\n\nAnswer C, , please share you answers","poster":"kopper2019","comments":[{"poster":"muhasinem","timestamp":"1626448380.0","upvote_count":"5","comment_id":"407963","content":"C is ok."},{"comment_id":"430358","content":"Answer A","poster":"namanp12345","comments":[{"comment_id":"430359","content":"Sorry C","poster":"namanp12345","timestamp":"1629760500.0","upvote_count":"1"}],"timestamp":"1629760500.0","upvote_count":"1"},{"comment_id":"480022","timestamp":"1637152980.0","poster":"Neo_ACE","upvote_count":"2","content":"Answer is C"},{"poster":"learner311","timestamp":"1649952000.0","content":"C. Unpredictable workload. Flexible does not scale nearly as fast as standard.","comment_id":"585887","upvote_count":"2"}],"comment_id":"406634","upvote_count":"22"},{"timestamp":"1627298340.0","upvote_count":"13","content":"Anyone can tell please if at the new exam there are also questions from the old set(before question 115)?","comment_id":"414607","comments":[{"comment_id":"445590","content":"old ones are not removed","upvote_count":"4","comments":[{"content":"really ? the old ones are are still on exam ? from 1-100 ? how about old case study questions ?","timestamp":"1632940800.0","comment_id":"454396","poster":"ale183","upvote_count":"2"}],"timestamp":"1631761560.0","poster":"kopper2019"}],"poster":"juccjucc"},{"upvote_count":"1","comment_id":"1323591","poster":"LDAP_Anand","content":"Selected Answer: B\nB is correct","timestamp":"1733670900.0"},{"timestamp":"1717770900.0","upvote_count":"2","poster":"de1001c","content":"Selected Answer: A\nTest current status, load test tools only purpouse is to test load and consider success/failure based on latency / response times.","comment_id":"1226200"},{"upvote_count":"1","timestamp":"1705631220.0","poster":"35cd41b","content":"Selected Answer: A\nA is correct, jmeter, k6","comment_id":"1126342"},{"comment_id":"1124527","poster":"ammonia_free","timestamp":"1705441920.0","content":"Selected Answer: A\nIMO, something here should be a multiple-choice option, and the examinee should have selected A and B. Otherwise, I am picking option A.","upvote_count":"1"},{"timestamp":"1686911040.0","poster":"kubinho","upvote_count":"2","comment_id":"925061","content":"Admin should really deleting the wrong answers.. I think 90% of people here just copying explanations and really have no idea what they are talking about. every second question has different answer with different \"voting\"answer.."},{"content":"Using Curl seems weird, how is Curl going to inject the load? Curl would be fine if we just wanted to test the underlying latency of the system.","timestamp":"1686395580.0","poster":"BiddlyBdoyng","upvote_count":"1","comment_id":"919970"},{"timestamp":"1681865820.0","content":"Selected Answer: A\nIt is A.\nYou want to TEST the deployment, not changing anything (yet).","comment_id":"874202","upvote_count":"1","poster":"gu_pp"},{"poster":"CGS22","upvote_count":"4","comment_id":"834009","content":"Selected Answer: A\nThe correct answer is: A. Use a load testing tool to simulate the expected number of concurrent users and total requests to your application, and inspect the results.\n\nA load testing tool can be used to simulate the expected number of concurrent users and total requests to your application. This will allow you to test how your application handles the expected load and to identify any potential problems.\n\nEnabling autoscaling on the GKE cluster and enabling horizontal pod autoscaling on your application deployments will not help you to test the latency of your application. This will only help to ensure that your application can handle the expected load.","timestamp":"1678369440.0"},{"timestamp":"1677198120.0","content":"Selected Answer: B\nis curl returns latency info?","upvote_count":"1","comment_id":"819934","poster":"MaryMei"},{"poster":"surajkrishnamurthy","content":"Selected Answer: A\nA is the correct answer","upvote_count":"1","timestamp":"1671015900.0","comment_id":"744993"},{"poster":"sanait100","upvote_count":"2","content":"Also, there is no expected numbers, the users can be tens of thousands so whatever testing you do with A may not be sufficient so it's better to keep autoscaling for whatsoever load comes in and curl test ensures autoscaling happens when required","timestamp":"1670363880.0","comment_id":"737242"},{"poster":"sanait100","timestamp":"1670363700.0","upvote_count":"2","comment_id":"737238","content":"The question specifically asks that your CTO expects a successful launch and you need to ensure your application can handle the expected load of tens of thousands of users. In A, you are just testing and not taking an action. In B, you are not only testing with curl commands to check for latency but also taking action to enable the cluster to acquire more resources. So, I will go with B."},{"poster":"megumin","timestamp":"1668594060.0","upvote_count":"1","content":"Selected Answer: A\nA is ok","comment_id":"719539"},{"timestamp":"1666204260.0","comment_id":"699262","content":"Selected Answer: A\nA is the correct, no load ==> no latency checking","poster":"Mahmoud_E","upvote_count":"1"},{"comment_id":"695373","poster":"AHUI","timestamp":"1665835260.0","upvote_count":"1","content":"Ans A: the question asks you want to test"}],"unix_timestamp":1625127120,"question_images":[],"answers_community":["A (83%)","B (17%)"],"isMC":true,"answer_ET":"A","question_text":"Your team is developing a web application that will be deployed on Google Kubernetes Engine (GKE). Your CTO expects a successful launch and you need to ensure your application can handle the expected load of tens of thousands of users. You want to test the current deployment to ensure the latency of your application stays below a certain threshold. What should you do?","topic":"1","question_id":45,"choices":{"D":"Use Cloud Debugger in the development environment to understand the latency between the different microservices.","B":"Enable autoscaling on the GKE cluster and enable horizontal pod autoscaling on your application deployments. Send curl requests to your application, and validate if the auto scaling works.","C":"Replicate the application over multiple GKE clusters in every Google Cloud region. Configure a global HTTP(S) load balancer to expose the different clusters over a single global IP address.","A":"Use a load testing tool to simulate the expected number of concurrent users and total requests to your application, and inspect the results."},"timestamp":"2021-07-01 10:12:00","exam_id":4,"url":"https://www.examtopics.com/discussions/google/view/56706-exam-professional-cloud-architect-topic-1-question-139/"}],"exam":{"name":"Professional Cloud Architect","lastUpdated":"11 Apr 2025","isImplemented":true,"isBeta":false,"numberOfQuestions":279,"provider":"Google","isMCOnly":false,"id":4},"currentPage":9},"__N_SSP":true}