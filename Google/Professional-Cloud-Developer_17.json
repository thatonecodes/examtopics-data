{"pageProps":{"questions":[{"id":"apRIMTY7rEWYcCSSxNvQ","url":"https://www.examtopics.com/discussions/google/view/91690-exam-professional-cloud-developer-topic-1-question-171/","answers_community":["D (100%)"],"exam_id":7,"answer_description":"","timestamp":"2022-12-15 14:04:00","answer":"D","answer_ET":"D","topic":"1","answer_images":[],"isMC":true,"question_text":"You are developing an application that consists of several microservices running in a Google Kubernetes Engine cluster. One microservice needs to connect to a third-party database running on-premises. You need to store credentials to the database and ensure that these credentials can be rotated while following security best practices. What should you do?","choices":{"A":"Store the credentials in a sidecar container proxy, and use it to connect to the third-party database.","B":"Configure a service mesh to allow or restrict traffic from the Pods in your microservice to the database.","C":"Store the credentials in an encrypted volume mount, and associate a Persistent Volume Claim with the client Pod.","D":"Store the credentials as a Kubernetes Secret, and use the Cloud Key Management Service plugin to handle encryption and decryption."},"question_images":[],"discussion":[{"comment_id":"1014689","timestamp":"1727071560.0","poster":"__rajan__","content":"Selected Answer: D\nD is correct.","upvote_count":"1"},{"upvote_count":"2","poster":"purushi","content":"Selected Answer: D\nStoring credentials as a Kubernetes secret + KMS for encryption and decryption of the DB credentials are the best answer.","comment_id":"974119","timestamp":"1722966780.0"},{"comment_id":"806351","poster":"mrvergara","timestamp":"1707743760.0","upvote_count":"1","content":"Selected Answer: D\nStoring sensitive information such as database credentials in Kubernetes Secrets is a common and secure way to manage sensitive information in a cluster. The Cloud Key Management Service (KMS) can be used to further protect the secrets by encrypting and decrypting them, ensuring that they are protected both at rest and in transit. This combination of Kubernetes Secrets and Cloud KMS provides a secure way to manage and rotate credentials while following security best practices.\n\nOptions A and B are not recommended, as they do not provide a secure and centralized way to manage and rotate credentials. Option C is not recommended because storing secrets in an encrypted volume mount is not as secure as using a Key Management Service, as the encryption keys must still be managed and protected within the cluster."},{"upvote_count":"3","comment_id":"753228","poster":"TNT87","content":"https://cloud.google.com/kubernetes-engine/docs/how-to/encrypting-secrets#reencrypt-secrets\nAnswer D","timestamp":"1703244660.0"},{"upvote_count":"3","content":"Selected Answer: D\nD is the answer.\n\nhttps://cloud.google.com/kubernetes-engine/docs/how-to/encrypting-secrets\nBy default, Google Kubernetes Engine (GKE) encrypts customer content stored at rest, including Secrets. GKE handles and manages this default encryption for you without any additional action on your part.\n\nApplication-layer secrets encryption provides an additional layer of security for sensitive data, such as Secrets, stored in etcd. Using this functionality, you can use a key managed with Cloud KMS to encrypt data at the application layer. This encryption protects against attackers who gain access to an offline copy of etcd.","timestamp":"1702645440.0","comment_id":"746091","poster":"zellck"}],"question_id":81,"unix_timestamp":1671109440},{"id":"2rfuLsJczrtLfbg4RFly","exam_id":7,"answer_ET":"C","answers_community":["C (88%)","6%"],"isMC":true,"question_images":[],"answer":"C","answer_images":[],"topic":"1","url":"https://www.examtopics.com/discussions/google/view/91689-exam-professional-cloud-developer-topic-1-question-172/","question_id":82,"discussion":[{"timestamp":"1702963560.0","upvote_count":"9","poster":"micoams","comments":[{"comment_id":"753254","content":"Agree that Cloud Logging will be better for search.","timestamp":"1703247060.0","upvote_count":"1","poster":"zellck"}],"content":"Selected Answer: C\nThe requirements say that the logs should be easily searchable. This is not easily achieved in Cloud Storage, so that eliminates A,B and D.\n\nThat leaves C and the valid option.\n\nNote, that it's possible to configure Cloud Logging with a custom retention period.\nhttps://cloud.google.com/logging/docs/buckets#custom-retention","comment_id":"749486"},{"timestamp":"1734896760.0","upvote_count":"1","poster":"dneves","comment_id":"1330543","content":"Selected Answer: A\nAnswer A. Cloud Storage with bucket lock:\n\nEnsures immutability\nMeets compliance needs\nCan't be overridden\nSimple configuration\n\nhttps://cloud.google.com/storage/docs/bucket-lock"},{"content":"Selected Answer: C\nC is correct.","timestamp":"1727071980.0","comment_id":"1014696","upvote_count":"1","poster":"__rajan__"},{"poster":"purushi","timestamp":"1722968280.0","comment_id":"974141","content":"Selected Answer: C\nTricky question.\nEasily searchable is the key here.\nCloud logging supports retaining the logs between 1 to 3650 (10 years max) and we can set custom retention period on the cloud logs.","upvote_count":"1"},{"comment_id":"769815","poster":"telp","timestamp":"1704745860.0","content":"Selected Answer: C\nC is the correct answer because Cloud Logging to retain logs between 1 day and 3650 days","upvote_count":"1"},{"poster":"zellck","comment_id":"753255","timestamp":"1703247120.0","upvote_count":"2","content":"Selected Answer: C\nC is the correct answer instead.\n\nhttps://cloud.google.com/logging/docs/routing/overview#logs-retention\nCloud Logging retains logs according to retention rules applying to the log bucket type where the logs are held.\n\nYou can configure Cloud Logging to retain logs between 1 day and 3650 days. Custom retention rules apply to all the logs in a bucket, regardless of the log type or whether that log has been copied from another location."},{"comment_id":"753218","poster":"TNT87","content":"https://cloud.google.com/logging/docs/audit/best-practices#custom-retention\nhttps://cloud.google.com/logging/docs/central-log-storage\nLogs must be searchable as required by the question. point number 4 for the second link above supports that.\nAnswer C","upvote_count":"1","timestamp":"1703243880.0"},{"timestamp":"1702645320.0","comment_id":"746089","poster":"zellck","content":"Selected Answer: B\nB is the answer.","upvote_count":"1"}],"timestamp":"2022-12-15 14:02:00","answer_description":"","question_text":"You manage your company's ecommerce platform's payment system, which runs on Google Cloud. Your company must retain user logs for 1 year for internal auditing purposes and for 3 years to meet compliance requirements. You need to store new user logs on Google Cloud to minimize on-premises storage usage and ensure that they are easily searchable. You want to minimize effort while ensuring that the logs are stored correctly. What should you do?","choices":{"A":"Store the logs in a Cloud Storage bucket with bucket lock turned on.","D":"Store the logs in a Cloud Storage bucket with a 1-year retention period. After 1 year, move the logs to another bucket with a 2-year retention period.","B":"Store the logs in a Cloud Storage bucket with a 3-year retention period.","C":"Store the logs in Cloud Logging as custom logs with a custom retention period."},"unix_timestamp":1671109320},{"id":"AABniNC7bi5HD28vChG1","topic":"1","exam_id":7,"answers_community":["AB (74%)","AE (26%)"],"answer_ET":"AB","question_images":[],"question_id":83,"question_text":"Your company has a new security initiative that requires all data stored in Google Cloud to be encrypted by customer-managed encryption keys. You plan to use Cloud Key Management Service (KMS) to configure access to the keys. You need to follow the \"separation of duties\" principle and Google-recommended best practices. What should you do? (Choose two.)","answer_images":[],"choices":{"C":"Provision Cloud KMS in the project where the keys are being used.","D":"Grant the roles/cloudkms.admin role to the owner of the project where the keys from Cloud KMS are being used.","A":"Provision Cloud KMS in its own project.","E":"Grant an owner role for the Cloud KMS project to a different user than the owner of the project where the keys from Cloud KMS are being used.","B":"Do not assign an owner to the Cloud KMS project."},"url":"https://www.examtopics.com/discussions/google/view/91688-exam-professional-cloud-developer-topic-1-question-173/","answer":"AB","discussion":[{"timestamp":"1703083440.0","content":"Selected Answer: AB\nAB should be correct instead.\n\nhttps://cloud.google.com/kms/docs/separation-of-duties#using_separate_project\nInstead, to allow for a separation of duties, you could run Cloud KMS in its own project, for example your-key-project. Then, depending on the strictness of your separation requirements, you could either:\n- (recommended) Create your-key-project without an owner at the project level, and designate an Organization Admin granted at the organization-level. Unlike an owner, an Organization Admin can't manage or use keys directly. They are restricted to setting IAM policies, which restrict who can manage and use keys. Using an organization-level node, you can further restrict permissions for projects in your organization.","comment_id":"751029","upvote_count":"5","poster":"zellck"},{"upvote_count":"2","comment_id":"1014700","content":"Selected Answer: AB\nAB is correct.","timestamp":"1727072160.0","comments":[{"comment_id":"1014703","poster":"__rajan__","content":"AE is correct as E provide separation of duty.","upvote_count":"2","timestamp":"1727072400.0"}],"poster":"__rajan__"},{"comment_id":"797165","timestamp":"1706974680.0","content":"Selected Answer: AE\nTo follow Google-recommended best practices, I would recommend choosing options A and E:\n\nA. Provision Cloud KMS in its own project - this helps to ensure that the management of encryption keys is isolated and separate from other projects in your Google Cloud organization.\n\nE. Grant an owner role for the Cloud KMS project to a different user than the owner of the project where the keys from Cloud KMS are being used - this follows the \"separation of duties\" principle and helps to ensure that the management of encryption keys is not tied to the project where the keys are being used.","upvote_count":"3","poster":"mrvergara"},{"content":"Selected Answer: AB\nAnswer A, B","upvote_count":"3","timestamp":"1703611020.0","poster":"TNT87","comment_id":"757676"},{"timestamp":"1702964340.0","upvote_count":"4","poster":"micoams","comments":[{"content":"For E, the owner of the KMS project is different from the project where keys from Cloud KMS is used.","timestamp":"1703083140.0","poster":"zellck","comment_id":"751024","upvote_count":"1"},{"upvote_count":"4","content":"After reading the documentation again, agree with you on AB.\n\nhttps://cloud.google.com/kms/docs/separation-of-duties#using_separate_project\n(recommended) Create your-key-project without an owner at the project level, and designate an Organization Admin granted at the organization-level. Unlike an owner, an Organization Admin can't manage or use keys directly. They are restricted to setting IAM policies, which restrict who can manage and use keys. Using an organization-level node, you can further restrict permissions for projects in your organization.","comment_id":"751027","poster":"zellck","timestamp":"1703083320.0"}],"comment_id":"749491","content":"Selected Answer: AB\nAs per the docs, https://cloud.google.com/kms/docs/separation-of-duties#using_separate_project\n\n\n1. The KMS should be in its own project\n2. Ideally, you should not assign an owner to the KMS project"},{"timestamp":"1702645260.0","upvote_count":"2","content":"Selected Answer: AE\nAE is the answer.\n\nhttps://cloud.google.com/kms/docs/separation-of-duties#using_separate_project\nCloud KMS could be run in an existing project, for example your-project, and this might be sensible if the data being encrypted with keys in Cloud KMS is stored in the same project.\n\nHowever, any user with owner access on that project is then also able to manage (and perform cryptographic operations with) keys in Cloud KMS in that project. This is because the keys themselves are owned by the project, of which the user is an owner.\n\nInstead, to allow for a separation of duties, you could run Cloud KMS in its own project, for example your-key-project.","comment_id":"746086","poster":"zellck"}],"isMC":true,"answer_description":"","timestamp":"2022-12-15 14:01:00","unix_timestamp":1671109260},{"id":"pFWCgsHiESs8OIinqMLw","timestamp":"2022-12-15 13:54:00","question_text":"You need to migrate a standalone Java application running in an on-premises Linux virtual machine (VM) to Google Cloud in a cost-effective manner. You decide not to take the lift-and-shift approach, and instead you plan to modernize the application by converting it to a container. How should you accomplish this task?","answer_ET":"D","topic":"1","answers_community":["D (88%)","13%"],"question_images":[],"answer":"D","choices":{"A":"Use Migrate for Anthos to migrate the VM to your Google Kubernetes Engine (GKE) cluster as a container.","C":"Use Migrate for Compute Engine to migrate the VM to a Compute Engine instance, and use Cloud Build to convert it to a container.","D":"Use Jib to build a Docker image from your source code, and upload it to Artifact Registry. Deploy the application in a GKE cluster, and test the application.","B":"Export the VM as a raw disk and import it as an image. Create a Compute Engine instance from the Imported image."},"answer_images":[],"exam_id":7,"unix_timestamp":1671108840,"url":"https://www.examtopics.com/discussions/google/view/91687-exam-professional-cloud-developer-topic-1-question-174/","discussion":[{"poster":"anshad666","timestamp":"1728485520.0","comment_id":"1295199","content":"Selected Answer: D\nhttps://cloud.google.com/java/getting-started/jib","upvote_count":"1"},{"content":"Selected Answer: D\nJib is a tool that builds Docker images from Java code without the need for a Dockerfile. This makes it easy to containerize Java applications, even if you don't have any experience with Docker.","upvote_count":"2","poster":"__rajan__","timestamp":"1695450180.0","comment_id":"1014705"},{"upvote_count":"2","poster":"purushi","comment_id":"974147","timestamp":"1691346780.0","content":"Selected Answer: D\nGoing for D for the below reasons:\n- Cost effective way\n- Modernize the application by converting it to a container"},{"comment_id":"922856","content":"Selected Answer: A\nThis seems to be exactly the situation described in this tutorial:\nhttps://cloud.google.com/migrate/containers/docs/migrating-monolith-vm-overview-setup\nSo I think that option A is correct","upvote_count":"1","timestamp":"1686728160.0","comments":[{"timestamp":"1701866160.0","comment_id":"1089327","upvote_count":"1","content":"Indeed, but I think Alt A doesn't address the whole picture. Migrate for Anthos itself would not automatically containerize the Java app running on the Linux VM. Migrate for Anthos can package the VM as a Kubernetes pod, but the application within the VM remains unchanged in its original form. To containerize this application and make it fully compatible with GKE, additional steps - those described in Alt D - would be required.\nAlternative D is correct.","poster":"examprof"}],"poster":"phil_thain"},{"poster":"telp","content":"Selected Answer: D\nAnswer D\nhttps://cloud.google.com/blog/products/application-development/introducing-jib-build-java-docker-images-better","upvote_count":"1","comment_id":"770204","timestamp":"1673256840.0"},{"poster":"TNT87","upvote_count":"1","content":"Answer D\nhttps://cloud.google.com/blog/products/application-development/introducing-jib-build-java-docker-images-better","timestamp":"1671706020.0","comment_id":"753197"},{"upvote_count":"1","poster":"zellck","comment_id":"746083","content":"Selected Answer: D\nD is the answer.\n\nhttps://cloud.google.com/blog/products/application-development/introducing-jib-build-java-docker-images-better","timestamp":"1671108840.0"}],"answer_description":"","isMC":true,"question_id":84},{"id":"U1j1U5Wsl64IdTXzmrj9","unix_timestamp":1671108660,"question_images":[],"discussion":[{"timestamp":"1687536300.0","comment_id":"754404","upvote_count":"12","content":"Selected Answer: C\nA is incorrect, because Cloud Storage FUSE does not support concurrency and file locking.\nB is incorrect, because a persistent disk PersistentVolume is not read-write-many. It can only be read-write once or read-many.\nC is correct, because itâ€™s the only managed, supported read-write-many storage option available for file-system access in Google Kubernetes Engine.\nD is incorrect, because the ConfigMap cannot be written to from the Pods.\n\nhttps://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes\nhttps://cloud.google.com/filestore/docs/accessing-fileshares\nhttps://cloud.google.com/storage/docs/gcs-fuse","poster":"x_cath","comments":[{"comment_id":"1348080","content":"That's correct. Configmap can not be written by application so D is not a correct solution.","timestamp":"1738087500.0","poster":"root_1234","upvote_count":"1"}]},{"comments":[{"poster":"pico","upvote_count":"1","content":"In this case the configuration file will be both read and written by the instances, so D is not the answer","comment_id":"1226798","timestamp":"1733678340.0"}],"upvote_count":"1","timestamp":"1711182420.0","comment_id":"1014708","content":"Selected Answer: D\nConfigMaps are Kubernetes objects that allow you to store configuration data in a key-value format. ConfigMaps are immutable, which means that they cannot be changed once they are created. This makes them ideal for storing configuration data that needs to be shared between multiple Pods.","poster":"__rajan__"},{"comment_id":"974149","timestamp":"1707252060.0","poster":"purushi","upvote_count":"1","content":"Selected Answer: D\nConfigMap is the usual way to store application configurations those runs under the cluster. I donot understand why many of you are saying C. The question is asking us to how we are going to manage configuration data in a GKE environment."},{"upvote_count":"2","comment_id":"753227","content":"Selected Answer: C\nC is the correct answer instead.\n\nhttps://kubernetes.io/docs/concepts/storage/volumes/#nfs\nAn nfs volume allows an existing NFS (Network File System) share to be mounted into a Pod. Unlike emptyDir, which is erased when a Pod is removed, the contents of an nfs volume are preserved and the volume is merely unmounted. This means that an NFS volume can be pre-populated with data, and that data can be shared between pods. NFS can be mounted by multiple writers simultaneously.","poster":"zellck","timestamp":"1687426260.0"},{"upvote_count":"3","comment_id":"753195","content":"Selected Answer: C\nAnswer C \nAn nfs volume allows an existing NFS (Network File System) share to be mounted into a Pod. Unlike emptyDir, which is erased when a Pod is removed, the contents of an nfs volume are preserved and the volume is merely unmounted. This means that an NFS volume can be pre-populated with data, and that data can be shared between pods","timestamp":"1687423260.0","poster":"TNT87"},{"poster":"Underverse","timestamp":"1687282980.0","comment_id":"751408","upvote_count":"3","comments":[{"upvote_count":"1","comment_id":"753226","poster":"zellck","timestamp":"1687426200.0","content":"Agree with C that a NFS will be required."}],"content":"Selected Answer: C\nGenerally ConfigMaps (D) are the right choice to store pod config-files, but: They are read-only, which does not match what is asked for here. If, as stated in the question, the application-parts need to be able to also write to that Configfile that should be on a shared file system, the only valid choice is a NFS PV."},{"poster":"zellck","comment_id":"746081","content":"Selected Answer: D\nD is the answer.\n\nhttps://cloud.google.com/kubernetes-engine/docs/concepts/configmap\nConfigMaps bind non-sensitive configuration artifacts such as configuration files, command-line arguments, and environment variables to your Pod containers and system components at runtime.\n\nA ConfigMap separates your configurations from your Pod and components, which helps keep your workloads portable. This makes their configurations easier to change and manage, and prevents hardcoding configuration data to Pod specifications.","upvote_count":"2","timestamp":"1686826260.0"}],"answer_description":"","question_id":85,"answer_ET":"C","isMC":true,"topic":"1","question_text":"Your organization has recently begun an initiative to replatform their legacy applications onto Google Kubernetes Engine. You need to decompose a monolithic application into microservices. Multiple instances have read and write access to a configuration file, which is stored on a shared file system. You want to minimize the effort required to manage this transition, and you want to avoid rewriting the application code. What should you do?","choices":{"D":"Create a new ConfigMap and volumeMount to store the contents of the configuration file.","B":"Create a new persistent disk, and mount the volume as a shared PersistentVolume.","C":"Create a new Filestore instance, and mount the volume as an NFS PersistentVolume.","A":"Create a new Cloud Storage bucket, and mount it via FUSE in the container."},"exam_id":7,"url":"https://www.examtopics.com/discussions/google/view/91686-exam-professional-cloud-developer-topic-1-question-175/","answers_community":["C (83%)","D (17%)"],"answer_images":[],"timestamp":"2022-12-15 13:51:00","answer":"C"}],"exam":{"provider":"Google","name":"Professional Cloud Developer","numberOfQuestions":338,"isBeta":false,"isMCOnly":false,"isImplemented":true,"id":7,"lastUpdated":"11 Apr 2025"},"currentPage":17},"__N_SSP":true}