{"pageProps":{"questions":[{"id":"TAwLBnzY5WHqB8b38G8A","discussion":[{"poster":"Sandesh24","timestamp":"1740844980.0","upvote_count":"1","content":"Selected Answer: C\nEven though you have granted the Cloud SQL Client role to the Cloud Run service account, the connection can still fail if the Cloud SQL Admin API is not enabled in the project where your Cloud Run service resides. For cross-project connections, Google Cloud recommends that the Cloud SQL Admin API be enabled in both projects (the one hosting Cloud SQL and the one running Cloud Run) so that proper metadata and instance connection details can be retrieved.\n • Option A: The Cloud SQL Client role already includes the necessary cloudsql.instances.connect permission.\n • Option B: There’s no indication that you are hitting an API quota issue.\n • Option D: Migrating the Cloud SQL instance is unnecessary and not in line with best practices for cross-project communication.\n\nThus, enabling the Cloud SQL Admin API in both projects resolves the connectivity issue.","comment_id":"1363628"}],"answer_images":[],"answer":"C","unix_timestamp":1740844980,"answer_ET":"C","answer_description":"","question_images":[],"answers_community":["C (100%)"],"question_id":266,"timestamp":"2025-03-01 17:03:00","topic":"1","choices":{"A":"Add the cloudsql.instances.connect IAM permission to the Cloud Run service account.","C":"Enable the Cloud SQL Admin API in both projects.","B":"Request additional API quota for Cloud SQL Auth Proxy,","D":"Migrate the Cloud SQL instance into the same project as the Cloud Run service."},"isMC":true,"question_text":"You have a Cloud Run service that needs to connect to a Cloud SQL instance in a different project. You provisioned the Cloud Run service account with the Cloud SQL Client IAM role on the project that is hosting Cloud SQL. However, when you test the connection, the connection fails. You want to fix the connection failure while following Google-recommended practices. What should you do?","exam_id":7,"url":"https://www.examtopics.com/discussions/google/view/157358-exam-professional-cloud-developer-topic-1-question-351/"},{"id":"56Gr7DDoUeBFmWwGKmVD","choices":{"A":"Each developer commits their code to the main branch before each product release, conducts testing, and rolls back if integration issues are detected.","B":"Each group of developers copies the repository, commits their changes to their repository, and merges their code into the main repository before each product release.","C":"Each developer creates a branch for their own work, commits their changes to their branch, and merges their code into the main branch daily.","D":"Each group of developers creates a feature branch from the main branch for their work, commits their changes to their branch, and merges their code into the main branch before each major release."},"answer_description":"","unix_timestamp":1740042240,"question_id":267,"timestamp":"2025-02-20 10:04:00","answer":"C","question_text":"You are a developer at a large organization. Your team uses Git for source code management (SCM). You want to ensure that your team follows Google-recommended best practices to manage code to drive higher rates of software delivery. Which SCM process should your team use?","exam_id":7,"answers_community":["C (100%)"],"isMC":true,"topic":"1","url":"https://www.examtopics.com/discussions/google/view/156850-exam-professional-cloud-developer-topic-1-question-353/","discussion":[{"upvote_count":"1","poster":"Sandesh24","comment_id":"1363642","timestamp":"1740846720.0","content":"Selected Answer: C\nGoogle-recommended best practices for source code management emphasize trunk-based development. In this approach, each developer works on a feature branch for their own work and merges their changes into the main branch frequently (ideally daily). This frequent integration minimizes merge conflicts, improves visibility of changes, and promotes continuous integration and delivery.\n • Option A: Committing directly to the main branch only before releases increases the risk of integration issues and delays feedback.\n • Option B: Copying the repository and merging before each product release introduces unnecessary complexity and delays integration.\n • Option D: Merging feature branches only before major releases can lead to large, disruptive changes and integration problems.\n\nThus, Option C aligns best with the practice of frequent integration and continuous delivery, driving higher rates of software delivery and reducing integration risks."},{"upvote_count":"1","timestamp":"1740042240.0","content":"Selected Answer: C\nAgree with C","poster":"09bd94b","comment_id":"1359182"}],"answer_images":[],"question_images":[],"answer_ET":"C"},{"id":"JlUBTaUZfQAbQh3oDpGF","question_id":268,"answers_community":["B (100%)"],"discussion":[{"upvote_count":"15","comment_id":"98293","content":"The referenced article shows that the correct answer is B)\n\"The migration is done feature by feature, avoiding a large-scale migration event and its associated risks\"","timestamp":"1606667940.0","poster":"emmet"},{"poster":"santoshchauhan","comment_id":"1168341","content":"Selected Answer: B\nB. Replace the application's features with appropriate microservices in phases.\n\nWhen transitioning from a monolithic application to a microservices architecture, it is generally best to do it incrementally, rather than all at once. This allows you to break down the application into smaller, manageable pieces and make sure each piece is functioning correctly before moving on to the next. It minimizes risk, allows for easier troubleshooting, and reduces the impact on the business because you can gradually shift traffic to the new services as they are tested and deployed.","timestamp":"1725734040.0","comments":[{"comment_id":"1168342","timestamp":"1725734100.0","upvote_count":"2","content":"Here's why the other options are less suitable:\n\nA. Deploying the application to Compute Engine with autoscaling does not change the architecture from monolithic to microservices. It may help with some scaling issues but does not achieve the goal of re-architecting the application.\n\nC. Refactoring the entire monolithic application into microservices in a single effort can be very risky. It can introduce complex issues that are hard to troubleshoot, and if something goes wrong, it could impact the entire business.\n\nD. Building a new application separate from the monolith and replacing it once complete is another approach, but it can be less efficient than replacing in phases. It requires a big-bang cutover, which can be risky. Phased approaches allow for gradual cutover and testing in production with real users, which can lead to a more reliable outcome.","poster":"santoshchauhan"}],"upvote_count":"1"},{"comment_id":"1143277","timestamp":"1723023060.0","content":"Selected Answer: B\nOption B is most logical in this situation.","upvote_count":"1","poster":"sankyboy"},{"comment_id":"1011097","content":"Selected Answer: B\nOption B is most logical in this situation.","timestamp":"1710842880.0","upvote_count":"1","poster":"__rajan__"},{"upvote_count":"1","poster":"maxdanny","content":"Selected Answer: B\nhttps://cloud.google.com/architecture/microservices-architecture-refactoring-monoliths","timestamp":"1708779960.0","comment_id":"989114"},{"content":"Option B is the best choice because it allows you to gradually replace the features of the monolithic application with microservices, minimizing the impact on the business. This approach also allows you to test and validate each microservice before fully integrating it into the application.","upvote_count":"1","poster":"omermahgoub","comment_id":"768316","comments":[{"poster":"omermahgoub","comment_id":"768319","upvote_count":"1","content":"Option A is not a good choice because it does not address the need to refactor the application into a microservices model. Autoscaling may help with resource management, but it does not address the underlying architecture of the application.","timestamp":"1688708880.0"}],"timestamp":"1688708880.0"},{"content":"Def B, how small is this monolith that it can be converted in 1 day! In addition to the fact that undoubtedly the app will break with this approach.","timestamp":"1679998620.0","comment_id":"681567","poster":"[Removed]","upvote_count":"1"},{"poster":"tomato123","timestamp":"1676878740.0","content":"Selected Answer: B\nB is correct","comment_id":"649197","upvote_count":"3"},{"upvote_count":"3","comment_id":"624484","timestamp":"1672306080.0","content":"Selected Answer: B\nI vote B. Migrating a monolithic service is best when done feature by feature.","poster":"cloud_enth0325"},{"content":"Selected Answer: B\nB is the correct. You don't want to replace the monolithic application in one go as C suggests which kind of defeats the purpose.","timestamp":"1670669100.0","upvote_count":"2","poster":"X627","comment_id":"614427"},{"comment_id":"544701","poster":"TesterMctester","content":"B strangler pattern","upvote_count":"4","timestamp":"1660141800.0"},{"upvote_count":"1","poster":"herocc","content":"B is right one, refactor with multiple phases to minimize impact.","comment_id":"527333","timestamp":"1658212980.0"},{"upvote_count":"2","timestamp":"1640572920.0","poster":"syu31svc","content":"Best answer is B here\n\nA is completely wrong\nC and D can be done but the amount of risk involved can be too great","comment_id":"391643"},{"comment_id":"286618","content":"it should be B","timestamp":"1628486880.0","upvote_count":"1","poster":"navidlaji"},{"content":"B is correct answer here.","upvote_count":"1","poster":"saurabh1805","timestamp":"1620502800.0","comment_id":"215544"}],"choices":{"D":"Build a new application with the appropriate microservices separate from the monolith and replace it when it is complete.","A":"Deploy the application to Compute Engine and turn on autoscaling.","C":"Refactor the monolithic application with appropriate microservices in a single effort and deploy it.","B":"Replace the application's features with appropriate microservices in phases."},"isMC":true,"exam_id":7,"timestamp":"2020-05-29 16:39:00","url":"https://www.examtopics.com/discussions/google/view/21589-exam-professional-cloud-developer-topic-1-question-36/","unix_timestamp":1590763140,"answer":"B","answer_ET":"B","question_images":[],"question_text":"You want to re-architect a monolithic application so that it follows a microservices model. You want to accomplish this efficiently while minimizing the impact of this change to the business.\nWhich approach should you take?","topic":"1","answer_images":[],"answer_description":""},{"id":"t1hg5xXi47Com0fx0Btd","discussion":[{"upvote_count":"1","poster":"09bd94b","comment_id":"1365805","content":"Selected Answer: D\nI see D as a more comprehensive solution than A","timestamp":"1741249860.0"},{"poster":"jlr1973","upvote_count":"1","timestamp":"1736861160.0","content":"Selected Answer: A\nVPC Serverless access connector is needed so that Cloud Run can reach the VPC.\nWithout configuring either PSA or PSC, your Cloud Run service will not be able to reach the Cloud SQL instance because there will be no network path between them.","comment_id":"1340366"},{"poster":"jeetajit02","comment_id":"1339236","timestamp":"1736614020.0","content":"Selected Answer: D\nThe answer should be D","upvote_count":"2"}],"answer_images":[],"answer":"D","unix_timestamp":1736614020,"answer_ET":"D","question_images":[],"answer_description":"","answers_community":["D (75%)","A (25%)"],"question_id":269,"timestamp":"2025-01-11 17:47:00","topic":"1","choices":{"A":"Create a Private Service Connect endpoint on your network. Create a Serverless VPC Access connector on your project. Use Cloud SQL Language Connectors to create an internal connection.","C":"Configure private services access on your project. In Cloud Run, create a Cloud SQL connection. Use Cloud SQL Language Connectors to interact with the database.","B":"Configure VPC Network Peering between both networks. In Cloud Run, create a Cloud SQL connection that uses the internal IP. Use Cloud SQL Language Connectors to interact with the database.","D":"Create a subnet on your VPC. Create a Serverless VPC Access connector on your project using the new subnet. In Cloud Run, create a Cloud SQL connection. Use Cloud SQL Language Connectors to interact with the database."},"isMC":true,"question_text":"You are responsible for developing a new ecommerce application that is running on Cloud Run. You need to connect your application to a Cloud SQL database that is in a separate project. This project is on an isolated network dedicated to multiple databases without a public IP. You need to connect your application to this database. What should you do?","exam_id":7,"url":"https://www.examtopics.com/discussions/google/view/154407-exam-professional-cloud-developer-topic-1-question-361/"},{"id":"a9rRVJd8xkUfcm2IhJt8","question_id":270,"answer_description":"","question_images":[],"unix_timestamp":1590763320,"topic":"1","url":"https://www.examtopics.com/discussions/google/view/21590-exam-professional-cloud-developer-topic-1-question-37/","exam_id":7,"question_text":"Your existing application keeps user state information in a single MySQL database. This state information is very user-specific and depends heavily on how long a user has been using an application. The MySQL database is causing challenges to maintain and enhance the schema for various users.\nWhich storage option should you choose?","answer_ET":"D","answer_images":[],"answer":"D","answers_community":["D (100%)"],"choices":{"B":"Cloud Storage","D":"Cloud Datastore/Firestore","A":"Cloud SQL","C":"Cloud Spanner"},"timestamp":"2020-05-29 16:42:00","isMC":true,"discussion":[{"poster":"emmet","comments":[{"poster":"syu31svc","timestamp":"1624754700.0","upvote_count":"1","comment_id":"391645","content":"\"Datastore is ideal for applications that rely on highly available structured data at scale. You can use Datastore to store and query all of the following types of data:\n\nProduct catalogs that provide real-time inventory and product details for a retailer.\nUser profiles that deliver a customized experience based on the user’s past activities and preferences.\nTransactions based on ACID properties, for example, transferring funds from one bank account to another.\""}],"content":"Question sais that there are challenges to maintain and enhance schema, so schemaless DB is more preferable, moreover google mention that Datastore/Firestore is good for users profiles (https://cloud.google.com/datastore/docs/concepts/overview#what_its_good_for)\nAnswer: D)","upvote_count":"19","comment_id":"98294","timestamp":"1590763320.0"},{"content":"Selected Answer: D\nResposta D","poster":"fbatag","timestamp":"1719623820.0","comment_id":"1238978","upvote_count":"1"},{"poster":"santoshchauhan","content":"Selected Answer: D\nD. Cloud Datastore/Firestore\n\nFor user-specific state information that varies significantly and requires a schema that can evolve over time, a NoSQL database like Cloud Datastore or Firestore is typically more appropriate. These databases provide a flexible schema, which allows you to easily make changes as the application evolves and user requirements become more complex.","timestamp":"1709843940.0","upvote_count":"1","comment_id":"1168343"},{"content":"Selected Answer: D\nThe last sentence subtly implies a schema-enforced database is not the right solution for this use case.","comment_id":"1148990","timestamp":"1707812520.0","poster":"theseawillclaim","upvote_count":"1"},{"comment_id":"1011098","timestamp":"1695111060.0","poster":"__rajan__","upvote_count":"1","content":"Selected Answer: D\nSince we need a flexible schema we can use Datastore/Firestore"},{"comment_id":"773464","upvote_count":"3","timestamp":"1673529480.0","poster":"zevexWM","content":"Selected Answer: D\nThe question is a bit misleading. If its asking to keep a MySQL storage option then Cloud SQL or Spanner are the only options. However, assuming that they want to move away from schema and also the need for stateful DB I would go for Datastore/Firestore."},{"upvote_count":"1","content":"Out of the options provided, Cloud Datastore or Cloud Firestore would be the best choice for storing user state information that is very user-specific and depends heavily on how long a user has been using an application. This is because both Cloud Datastore and Cloud Firestore are NoSQL document databases designed for storing, retrieving, and managing semi-structured data at scale. They are well-suited for storing complex, hierarchical data structures and can handle a high volume of read and write operations. Additionally, Cloud Datastore and Cloud Firestore offer strong consistency and automatic scaling, which can help your application handle a high volume of users without requiring significant manual effort to maintain and enhance the schema.","comments":[{"timestamp":"1673077920.0","poster":"omermahgoub","comment_id":"768324","upvote_count":"1","content":"Cloud Storage is not suitable for storing user state information as it is an object storage service that is not designed for storing structured data."}],"comment_id":"768322","timestamp":"1673077860.0","poster":"omermahgoub"},{"comment_id":"680883","content":"Option D","upvote_count":"1","poster":"subesingh","timestamp":"1664290260.0"},{"content":"Selected Answer: D\nhttps://cloud.google.com/datastore/docs/concepts/overview#what_its_good_for -> \"User profiles that deliver a customized experience based on the user’s past activities and preferences\".\nAnswer id D.","poster":"brunoguzzo18","timestamp":"1661824020.0","comment_id":"653738","upvote_count":"2"},{"timestamp":"1660973940.0","content":"Selected Answer: D\nD is correct","poster":"tomato123","comment_id":"649198","upvote_count":"3"},{"content":"D for sure","comment_id":"588863","timestamp":"1650476460.0","poster":"crassio12","upvote_count":"1"},{"content":"D is right one.","poster":"herocc","timestamp":"1642581960.0","comment_id":"527334","upvote_count":"3"},{"timestamp":"1641636960.0","comment_id":"519448","poster":"ParagSanyashiv","upvote_count":"3","content":"Selected Answer: D\nD is the answer"},{"upvote_count":"2","content":"D is correct answer","timestamp":"1604871900.0","comment_id":"215545","poster":"saurabh1805"}]}],"exam":{"name":"Professional Cloud Developer","numberOfQuestions":338,"isImplemented":true,"provider":"Google","id":7,"isMCOnly":false,"isBeta":false,"lastUpdated":"11 Apr 2025"},"currentPage":54},"__N_SSP":true}