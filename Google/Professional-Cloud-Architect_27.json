{"pageProps":{"questions":[{"id":"fpbKCP95cFzYl237ww5v","answers_community":["B (63%)","D (36%)","1%"],"exam_id":4,"answer":"B","topic":"1","timestamp":"2019-12-17 22:17:00","question_id":131,"question_text":"You created a pipeline that can deploy your source code changes to your infrastructure in instance groups for self-healing. One of the changes negatively affects your key performance indicator. You are not sure how to fix it, and investigation could take up to a week.\nWhat should you do?","url":"https://www.examtopics.com/discussions/google/view/10522-exam-professional-cloud-architect-topic-1-question-36/","unix_timestamp":1576617420,"question_images":[],"answer_description":"","isMC":true,"discussion":[{"comment_id":"434439","comments":[{"content":"The question itself looks the madeup. Not a real scenario ...\"You created a pipeline that can deploy your source code changes to your infrastructure in instance groups for self-healing. One of the changes negatively affects your key performance indicator. \" How a self healing code is affecting KPI. What was KPI, we dont know. Was the self healing done? we dont know. Dont know who make this questions. Even if we go whatever they try to ask, with options available, B is safest. However this option is just answer to any troubleshooting step. I m not convinced for the person who wrote this question","upvote_count":"3","poster":"ashishdwi007","comment_id":"1129514","timestamp":"1706013840.0"}],"poster":"amxexam","upvote_count":"77","content":"Let's go with option elimination\n\nA. Log in to a server, and iterate on the fix locally\n>> Long step, hence eliminate\n\nB. Revert the source code change and rerun the deployment pipeline\n>> This revert will be logged in the source repo. Will go with this way although D also is correct.\n\nC. login to the servers with the bad code change, and swap in the previous code\n>> C is manually doing what can be automatically done by B and C, hence eliminate.\n\nD. Change the instance group template to the previous one and delete all instances\n>> This is similar to B but why manually do something which is automated. Hence eliminate. But is also correct. But B is better from code lifecycle perspective.\n\nHence B","timestamp":"1630230300.0"},{"upvote_count":"62","timestamp":"1596736620.0","poster":"ewredtrfygi","comment_id":"152101","comments":[{"timestamp":"1604235180.0","comment_id":"210442","upvote_count":"21","poster":"mexblood1","content":"If you can deploy your source code changes to the infrastructure in instance group for self-healing, it means you're not using Manage Instance Groups. Otherwise you would be creating a new template with the code changes. Further more, you would not delete instances on a MIG, you would be rolling out the previous template again in a controlled manner using maxsurge, maxunavailable, etc. For those reasons I'll choose B."},{"upvote_count":"2","poster":"AmitAr","comment_id":"607234","content":"B. keyword is \"self-healing\" not \"auto-healing\" - which means MIG not used. So correct answer is B","timestamp":"1653484860.0"},{"poster":"Bill831231","content":"seems with approach, there will be a mismatch in pipeline","comment_id":"464144","upvote_count":"4","timestamp":"1634563260.0"},{"comments":[{"poster":"Davidik79","comment_id":"572246","timestamp":"1647868980.0","content":"\"....One of the changes has impacted negatively your PKI\". Why is the question about pipeline? It is about how to do investigations and keep your PKI at the proper SLA/SLO.","upvote_count":"1"}],"timestamp":"1642529220.0","content":"If you change manually the template.. why are using pipelines? B is the best answer because is automated!!! Why Google will be interested to vote the wrong answers??? They want more professionals with GCP certifications!!!!","poster":"Meyucho","comment_id":"526892","upvote_count":"7"}],"content":"Too many responses saying B is the answer - I wonder if GCP pays people to provide the wrong answers on this website. It's clearly D, MIG templates support versioning, they were created to solve this exact problem. You simply select the previous template version, set that as the new deployment, and it will roll back the KPI depriving deployment and roll out the previous working deployment. The only part of D I don't like is the \"terminate all instances\" since you should engage in a rolling deployment, but if it's not a live website I suppose that would be fine.\nhttps://cloud.google.com/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups"},{"comment_id":"1347299","timestamp":"1737965520.0","content":"Selected Answer: B\nIf you have a pipeline that deploys, changing the deployment manually is an anti-pattern - it causes the code in the repo to be inconsistent with the code that runs. Fix forward is not an option (\"investigation can take a week\") so revert source code change is the only possibility.","upvote_count":"1","poster":"user263263"},{"poster":"Ekramy_Elnaggar","comment_id":"1314150","content":"Selected Answer: B\n1. Quickest path to recovery: Reverting the code change that caused the performance degradation is the fastest way to restore your key performance indicator (KPI) to its previous level. Your pipeline is designed to automate deployments, so re-deploying the known good version should be straightforward.\n\n2. Minimizes downtime: While investigating the issue is important, it can take time. Reverting first minimizes the duration of the negative impact on your KPI.\n\n3. Clean and controlled: This approach avoids making ad-hoc changes directly on servers (options A and C), which can lead to inconsistencies and make it harder to track the problem's source.\n\n4. Maintains instance group integrity: Option D involves deleting instances, which can disrupt services and lead to unnecessary re-creation of resources.","timestamp":"1731955680.0","upvote_count":"2"},{"timestamp":"1731220620.0","poster":"sim7243","comment_id":"1309314","content":"option B","upvote_count":"1"},{"content":"Selected Answer: B\nAgree with B","comment_id":"1189139","poster":"dija123","timestamp":"1712213340.0","upvote_count":"1"},{"upvote_count":"3","poster":"lisabisa","content":"D is infrastructure change. \nB is application change. \nSo B is correct.","comment_id":"1162165","timestamp":"1709175660.0"},{"comment_id":"1122663","timestamp":"1705248900.0","upvote_count":"1","content":"D\nThe question is talking abt MIG and you can revert Inst Template same as B. Since this is about MIG's I will choose D","poster":"kip21"},{"content":"Selected Answer: D\nD. This is a question about instance groups and so modifying templates should be what we're looking for.","comment_id":"1105540","timestamp":"1703538000.0","upvote_count":"1","poster":"adoyt"},{"poster":"simiramis221","content":"This a B for sure","upvote_count":"1","comment_id":"1100449","timestamp":"1702975980.0"},{"comment_id":"1025710","upvote_count":"2","content":"Selected Answer: B\nThe popped up with source code changes, hence reverting the change and deployment will solve the issue.\n\nB. Revert the source code change, and rerun the deployment pipeline","timestamp":"1696512900.0","poster":"AdityaGupta"},{"content":"D is incorrect:\n - MIG instance group template is immutable, there is no version concept. The context never mentioned that team created multiple instance group templates.\n - Software code change might not all ended up in the instance group templates, it depends on how the deployment pipeline is configured. \n\nRegardless, B is a best practices, ensure that your infrastructure is synced with your source control system.","poster":"yilexar","timestamp":"1695772140.0","upvote_count":"1","comment_id":"1018280"},{"timestamp":"1694760480.0","comment_id":"1008194","upvote_count":"2","poster":"rusll","content":"Selected Answer: D\nYou don't need to touch your code, just deploy and older version and fix the code, then deploy the fixed version"},{"timestamp":"1692009840.0","content":"Selected Answer: D\nThe most secure option is D\nRevert a source code change could be complex (if change was made in various components)","comment_id":"980699","poster":"jalberto","upvote_count":"2"},{"upvote_count":"2","comment_id":"930198","content":"Selected Answer: B\nBecause the question starting from source code","poster":"chrismar","timestamp":"1687414320.0"},{"timestamp":"1686221040.0","content":"Selected Answer: B\nby bard:\nThe correct answer is B. Revert the source code change, and rerun the deployment pipeline.","poster":"oriori123123","upvote_count":"1","comment_id":"918145"},{"content":"B. \nThe keyword here is source code not VM configuration. If it was the later then instance group templates is the answer. But in this case simply rollback your source code change and rerun to last workable version. Simples!","poster":"JohnWick2020","comment_id":"912915","timestamp":"1685719860.0","upvote_count":"2"}],"answer_ET":"B","answer_images":[],"choices":{"C":"Log into the servers with the bad code change, and swap in the previous code","D":"Change the instance group template to the previous one, and delete all instances","A":"Log in to a server, and iterate on the fox locally","B":"Revert the source code change, and rerun the deployment pipeline"}},{"id":"XJ1v2ZAIBx8fAXzclxtN","choices":{"B":"Multiple Organizations, one for each department","D":"A single Organization with multiple projects, each with a central owner","A":"Multiple Organizations with multiple Folders","C":"A single Organization with Folders for each department"},"answer_ET":"C","question_images":[],"isMC":true,"topic":"1","exam_id":4,"url":"https://www.examtopics.com/discussions/google/view/7208-exam-professional-cloud-architect-topic-1-question-37/","answer":"C","answer_description":"","answers_community":["C (100%)"],"answer_images":[],"unix_timestamp":1572022080,"discussion":[{"poster":"AWS56","comments":[{"upvote_count":"1","poster":"CamiloJrJr","content":"https://cloud.google.com/architecture/identity/best-practices-for-planning#use_organizations_to_delineate_administrative_authority","timestamp":"1732350480.0","comment_id":"1316603"},{"comment_id":"696562","timestamp":"1665953460.0","poster":"AzureDP900","upvote_count":"2","content":"C is recommended approach"}],"timestamp":"1574259720.0","content":"https://cloud.google.com/docs/enterprise/best-practices-for-enterprise-organizations\n\nI will stick with C","upvote_count":"27","comment_id":"23048"},{"comment_id":"681938","upvote_count":"7","timestamp":"1664384220.0","content":"The reason it isn't D is that a Dept modelled as a project puts a massive constraint on the dept that they can only have a single project, it's likely a department will want many projects.","poster":"BiddlyBdoyng"},{"content":"Selected Answer: C\n1. Centralized Control: A single organization provides a central point for managing all your Google Cloud resources and IAM policies. This simplifies administration and ensures consistency across your organization.\n\n2. Independent Department Management: Folders allow you to group projects within your organization and delegate administrative control to different departments. Each department can manage its own IAM policies within its assigned folder, providing the necessary independence.\n\n3. Hierarchical Structure: Folders provide a hierarchical structure for organizing your resources. You can create sub-folders within departments for further granularity and control.\n\n4. Efficient Resource Management: This structure makes it easier to manage resources, track costs, and enforce security policies across your organization.","timestamp":"1731955980.0","upvote_count":"4","poster":"Ekramy_Elnaggar","comment_id":"1314154"},{"upvote_count":"1","content":"B","comment_id":"1295852","timestamp":"1728626280.0","poster":"Shasha1"},{"poster":"vyomkeshbakshi","timestamp":"1689385920.0","content":"Selected Answer: C\nClearly C","upvote_count":"1","comment_id":"951940"},{"upvote_count":"1","content":"Selected Answer: C\nIs obviously C","comment_id":"909059","timestamp":"1685338320.0","poster":"red_panda"},{"content":"C. A single Organization with Folders for each department\n\nTo control IAM policies for different departments independently but centrally, you should create a single organization and use folders to organize the policies for each department. This approach allows you to centralize the management of IAM policies for all departments within a single organization, while also allowing you to set up different policies for each department as needed.\n\nOption A, multiple organizations with multiple folders, would not be an effective solution because it would create unnecessary complexity and make it more difficult to centralize the management of IAM policies. Option B, multiple organizations, one for each department, would also not be an effective solution because it would create unnecessary complexity and make it more difficult to centralize the management of IAM policies. Option D, a single organization with multiple projects, each with a central owner, would not be an effective solution because it would not allow you to set up different policies for each department as needed.","timestamp":"1671608760.0","upvote_count":"2","poster":"omermahgoub","comment_id":"751984"},{"content":"C. It's a best practice and I've done this with my previous and current company :)","poster":"MarcoEscanor","timestamp":"1666290300.0","comment_id":"700200","upvote_count":"3"},{"content":"Selected Answer: C\n.............","comment_id":"683268","upvote_count":"1","timestamp":"1664518740.0","poster":"Prashant2022"},{"content":"C single org and multiple folders","comment_id":"675870","timestamp":"1663834080.0","poster":"holerina","upvote_count":"1"},{"timestamp":"1648838520.0","upvote_count":"1","comment_id":"579629","content":"Selected Answer: C\nC is the right answer","poster":"cmamiusa"},{"upvote_count":"1","comment_id":"577042","content":"Selected Answer: C\nWill go for C","timestamp":"1648493100.0","poster":"mygcpjourney2712"},{"upvote_count":"2","content":"Go for C","timestamp":"1638611220.0","comment_id":"493624","poster":"haroldbenites"},{"content":"C is the right answer","comment_id":"488277","timestamp":"1638030600.0","poster":"vincy2202","upvote_count":"1"},{"upvote_count":"1","poster":"nansi","timestamp":"1632545700.0","content":"C shall be the correct answer","comment_id":"451232"},{"timestamp":"1629326700.0","content":"C. Seems to be best practice (cf AWS56). And I believe that D should be excluded because it says \"Project owner\" - it is not best practice since it's a basic role + it's not even stated as a requisite","upvote_count":"1","comment_id":"427103","poster":"rikoko"},{"content":"C. A single Organization with Folders for each department","comment_id":"361022","timestamp":"1621401240.0","poster":"victory108","upvote_count":"3"},{"content":"C is correct","upvote_count":"1","comment_id":"354880","timestamp":"1620751080.0","poster":"un"},{"upvote_count":"1","poster":"Ausias18","comment_id":"324723","timestamp":"1617165600.0","content":"Answer is C"},{"content":"C is ok","comment_id":"324264","poster":"lynx256","upvote_count":"2","timestamp":"1617108180.0"},{"upvote_count":"4","comment_id":"229508","poster":"JCGO","timestamp":"1606552500.0","content":"C for sure. IAM can be applied to folder level. https://cloud.google.com/resource-manager/docs/creating-managing-folders"},{"content":"C is more meaningful","comment_id":"179531","timestamp":"1600114140.0","upvote_count":"2","poster":"AshokC"},{"poster":"Gobblegobble","comment_id":"126750","upvote_count":"1","timestamp":"1593943200.0","comments":[{"timestamp":"1598643900.0","upvote_count":"1","poster":"dayody","content":"the answer is C","comment_id":"168710"}],"content":"D is right answer"},{"comment_id":"117197","content":"C is fine","timestamp":"1592898900.0","poster":"mlantonis","upvote_count":"3"},{"timestamp":"1592636520.0","content":"C is the correct answer","poster":"Tushant","upvote_count":"3","comment_id":"114540"},{"poster":"gfhbox0083","upvote_count":"3","comment_id":"106530","timestamp":"1591770780.0","content":"C, for sure"},{"timestamp":"1591107300.0","comment_id":"100904","upvote_count":"3","poster":"Nirms","content":"C is the correct answer"},{"poster":"Ziegler","upvote_count":"3","comment_id":"98453","content":"C is correct","timestamp":"1590781080.0"},{"comment_id":"97330","timestamp":"1590650280.0","content":"Final Decision to go with Option C","poster":"AD2AD4","upvote_count":"2"},{"content":"C is the answer","poster":"gcp_aws","timestamp":"1590084720.0","comment_id":"93551","upvote_count":"3"},{"content":"agree with C","timestamp":"1589679840.0","poster":"laksg","upvote_count":"3","comment_id":"90261"},{"content":"C..Organization -> Folders -> Projects -> Resources. Best way is to have single Organization and then have multiple folders for each department","poster":"PRC","timestamp":"1586937240.0","upvote_count":"3","comment_id":"74769"},{"poster":"2g","content":"answer: C","upvote_count":"1","comment_id":"44745","timestamp":"1580391420.0"},{"content":"C is it","timestamp":"1579198440.0","comment_id":"39819","upvote_count":"2","poster":"sri007"},{"comment_id":"32771","timestamp":"1577364540.0","content":"Ans C -- \"Next in the hierarchy are folders. You can use folders to isolate requirements for different departments and teams in the parent organization\"\nhttps://cloud.google.com/docs/enterprise/best-practices-for-enterprise-organizations","upvote_count":"2","poster":"MyPractice"},{"comment_id":"29577","upvote_count":"2","content":"Agreed with C. Single organization can help control multiple departments represented by folder centrally through organization policies.","poster":"aviv","timestamp":"1576334280.0"},{"comments":[{"poster":"tartar","timestamp":"1596696300.0","content":"C is ok","comment_id":"151748","upvote_count":"2"},{"content":"Projects are subsets of folders, hence C is matching all the needs : \ncentralized policies at organization level \ngiving access at folder levels for departments\nallowing department's folder owners to manage the project level's access policies\n\nhttps://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy","upvote_count":"2","poster":"Alekshar","comment_id":"298875","timestamp":"1614241860.0"},{"poster":"nitinz","upvote_count":"2","content":"C, you can have only one ORG. Best practice Org -> Folder -> Project","comment_id":"303632","timestamp":"1614896820.0"}],"poster":"Eroc","comment_id":"17408","timestamp":"1572022080.0","upvote_count":"3","content":"Answer should be D, A and B are not centrally managed. Option D offers more agility to the departments than option C... in other terms they'd be able to do more on the GCP than just having folders. The IAM policies can be managed at the organization level and granted to each project. Each project could then create there own"}],"timestamp":"2019-10-25 18:48:00","question_id":132,"question_text":"Your organization wants to control IAM policies for different departments independently, but centrally.\nWhich approach should you take?"},{"id":"ipL4kFa2dI2PRCWKOOkp","answer_description":"","answer_images":[],"discussion":[{"upvote_count":"24","timestamp":"1572022920.0","poster":"Eroc","comment_id":"17409","comments":[{"comments":[{"content":"Where do you go? when we need you for other questions. Plz ans other q's if you have time","timestamp":"1634089260.0","poster":"Urban_Life","comment_id":"461327","upvote_count":"2"}],"content":"B is ok","timestamp":"1596696420.0","poster":"tartar","upvote_count":"9","comment_id":"151750"},{"timestamp":"1614896880.0","content":"B, SHA1 Digest error in the first line in the error code. With Java errors, always focus on the first line in the error code, rest of the lines are garbage **mostly**.","poster":"nitinz","upvote_count":"19","comment_id":"303635"}],"content":"Signing the JAR files grants it permissions. (https://docs.oracle.com/javase/tutorial/deployment/jar/signindex.html)"},{"timestamp":"1671609300.0","upvote_count":"14","content":"The most likely cause of the error is that one of the JAR files in your application has been tampered with or is corrupt. The SHA1 digest error indicates that the JAR file's signature does not match the expected value, which could be due to tampering or corruption.\n\nTo fix the issue, you should try uploading missing JAR files and redeploying your application. If the issue persists, you may need to digitally sign all of your JAR files and redeploy your application to ensure that the signatures are valid. You should not try to recompile the Cloaked","poster":"omermahgoub","comment_id":"751990"},{"content":"Selected Answer: B\n1. JAR signing and integrity: Digitally signing your JAR files ensures their authenticity and integrity. It adds a digital signature that verifies the origin and confirms that the file hasn't been tampered with. This is crucial for security and prevents issues like the SHA1 digest error you're encountering.\n\n2. App Engine requirement: Google App Engine enforces JAR signing for security reasons. All deployed applications must have properly signed JAR files.","poster":"Ekramy_Elnaggar","upvote_count":"4","timestamp":"1731956160.0","comment_id":"1314155"},{"comment_id":"1309470","upvote_count":"1","poster":"chrissamharris","content":"Selected Answer: A\nA SHA1 digest error during the deployment of a Java application to Google App Engine (GAE) typically indicates an issue with the integrity of your JAR files. This error can arise due to corrupted, modified, or missing JAR files that are essential for your application to run correctly.","timestamp":"1731247080.0"},{"comment_id":"1162192","content":"Selected Answer: A\nA missing JAR (Java ARchive) file indicates a problem with the code to be deployed.\nB Digitally signing all of your JAR files indicates a problem with the signature.\nA is better","poster":"lisabisa","timestamp":"1709177340.0","upvote_count":"3"},{"content":"Selected Answer: B\n\"JavaVerifier.Java.428\" is the key here","upvote_count":"2","timestamp":"1696514040.0","comment_id":"1025733","poster":"AdityaGupta"},{"timestamp":"1692711480.0","poster":"SantoshPanigrahi","upvote_count":"1","comment_id":"987474","content":"Selected Answer: B\nB is the correct answer."},{"upvote_count":"2","comments":[{"comment_id":"1224878","content":"Corrupted or incomplete. But not missing.","upvote_count":"2","timestamp":"1717607460.0","poster":"tocsa"}],"timestamp":"1678867800.0","content":"Selected Answer: A\nA. Upload missing JAR files and redeploy your application.\n\nThe error message indicates that there is a problem with the SHA1 digest for the \"com/altostrat/cloakedservlet.class\" file. This can be caused by a corrupted or incomplete JAR file. Therefore, the best course of action is to upload any missing JAR files and redeploy the application.","poster":"JC0926","comment_id":"839657"},{"content":"B is correct","timestamp":"1668278940.0","poster":"Racinely","upvote_count":"1","comment_id":"716871"},{"comment_id":"693910","content":"Selected Answer: B\nOk B but how is this question related to a GCP exam? I guess a google search will be faster than reading the theory around Java (unless you are a developer).","comments":[{"poster":"zr79","content":"have you done any Azure exams? you will thank Google","timestamp":"1665980700.0","comment_id":"696805","upvote_count":"5"},{"poster":"AzureDP900","content":"nothing to do with GCP however basic troubleshooting skills required as a DevOps or Architect, B is fine","comment_id":"696564","upvote_count":"3","comments":[{"comment_id":"765201","content":"I see your point, but for basic troubleshooting of apps, i will usually have access to google (aka stackoverflow homepage). This could have been a cloud developer question that they repurposed.","poster":"[Removed]","timestamp":"1672802160.0","upvote_count":"1"}],"timestamp":"1665953640.0"}],"upvote_count":"7","timestamp":"1665666060.0","poster":"minmin2020"},{"comment_id":"675874","upvote_count":"1","poster":"holerina","timestamp":"1663834320.0","content":"B is the right answer"},{"poster":"avinashvidyarthi","content":"Selected Answer: B\nB is Correct!","comment_id":"601464","upvote_count":"1","timestamp":"1652512440.0"},{"comment_id":"596133","content":"B is the right answer","upvote_count":"1","poster":"Munna19","timestamp":"1651511520.0"},{"timestamp":"1640432820.0","content":"B is the correct answer","upvote_count":"2","poster":"vincy2202","comment_id":"509085"},{"upvote_count":"1","poster":"duocnh","content":"Selected Answer: B\nvote B","comment_id":"489492","timestamp":"1638142980.0"},{"comment_id":"481562","poster":"TheCloudBoy77","content":"Selected Answer: B\nB is correct answer","upvote_count":"1","timestamp":"1637317260.0"},{"comment_id":"402293","timestamp":"1625787360.0","content":"Option B. Digitally sign all of your JAR files and redeploy your application","upvote_count":"1","poster":"bala786"},{"timestamp":"1625741040.0","content":"Answer is B","comment_id":"401799","upvote_count":"1","poster":"MamthaSJ"},{"timestamp":"1621405500.0","comment_id":"361079","poster":"victory108","upvote_count":"3","content":"B. Digitally sign all of your JAR files and redeploy your application"},{"upvote_count":"1","comment_id":"354890","timestamp":"1620752340.0","content":"B is correct","poster":"un"},{"comment_id":"324724","poster":"Ausias18","upvote_count":"2","content":"Answer is B","timestamp":"1617165660.0"},{"upvote_count":"1","timestamp":"1613338620.0","poster":"IamFleur","content":"B for sure","comment_id":"290525"},{"upvote_count":"1","poster":"dlzhang","content":"Obviously, it is a security issue and neither A or C is trying to fix the problem.","timestamp":"1610252100.0","comment_id":"263641"},{"timestamp":"1600131240.0","poster":"AshokC","comment_id":"179588","content":"Answer: B","upvote_count":"1"},{"timestamp":"1597941780.0","poster":"wiqi","upvote_count":"1","content":"There is a very old thread of similar issue....\nhttps://bugs.launchpad.net/play/+bug/594316\n\nLooks to me signing issue. So would go with B","comment_id":"162359"},{"comment_id":"126343","content":"The stacktrace shows a JarVerifier class present.\nSo Answer is B","upvote_count":"2","poster":"OnomeOkuma","timestamp":"1593885240.0"},{"poster":"mlantonis","upvote_count":"2","comment_id":"117216","timestamp":"1592899680.0","content":"B is correct"},{"content":"B is the correct answer","timestamp":"1592637120.0","comment_id":"114550","poster":"Tushant","upvote_count":"2"},{"poster":"gfhbox0083","upvote_count":"2","content":"B, for sure","comment_id":"106539","timestamp":"1591771920.0"},{"poster":"Nirms","comment_id":"100928","timestamp":"1591109220.0","upvote_count":"1","content":"B is the correct answer"},{"content":"B is correct","poster":"Ziegler","comment_id":"98456","upvote_count":"2","timestamp":"1590781320.0"},{"poster":"AD2AD4","upvote_count":"2","timestamp":"1590738300.0","content":"Final Decision to go with Option B","comment_id":"98097"},{"poster":"gcp_aws","timestamp":"1590084780.0","content":"B is the answer","upvote_count":"2","comment_id":"93552"},{"timestamp":"1580391420.0","comment_id":"44746","poster":"2g","upvote_count":"2","content":"answer: B"}],"question_images":["https://www.examtopics.com/assets/media/exam-media/04339/0009300001.png"],"question_text":"You deploy your custom Java application to Google App Engine. It fails to deploy and gives you the following stack trace.\nWhat should you do?\n//IMG//","answer":"B","topic":"1","answer_ET":"B","url":"https://www.examtopics.com/discussions/google/view/7209-exam-professional-cloud-architect-topic-1-question-38/","question_id":133,"exam_id":4,"timestamp":"2019-10-25 19:02:00","isMC":true,"unix_timestamp":1572022920,"choices":{"C":"Recompile the CLoakedServlet class using and MD5 hash instead of SHA1","A":"Upload missing JAR files and redeploy your application.","B":"Digitally sign all of your JAR files and redeploy your application"},"answers_community":["B (74%)","A (26%)"]},{"id":"oKNZ9mVXtDQT9rRVv3k3","isMC":true,"answers_community":["C (80%)","D (20%)"],"question_images":[],"question_text":"You are designing a mobile chat application. You want to ensure people cannot spoof chat messages, by providing a message were sent by a specific user.\nWhat should you do?","answer_ET":"C","discussion":[{"content":"I am not sure about this one. D works if SSL client authentication is enabled.\nC works as well if client encrypts message with private key and server decrypt with public key.\nI prefer C.","upvote_count":"38","comment_id":"16928","comments":[{"poster":"JoeShmoe","comment_id":"21554","timestamp":"1573743900.0","upvote_count":"5","content":"Agree with C"},{"poster":"asfar","comment_id":"39157","upvote_count":"5","content":"I agree with C on this one.","timestamp":"1579045140.0"}],"poster":"KouShikyou","timestamp":"1571828100.0"},{"upvote_count":"14","timestamp":"1613643840.0","content":"Encrypting each block and tagging each message at the client side is an overhead on the application. Best method which has been adopted since years is contacting SSL provider and use public certificate to encrypt the traffic between client and server. \n\nD is correct","comment_id":"293276","comments":[{"comment_id":"526907","poster":"Meyucho","upvote_count":"1","timestamp":"1642529880.0","content":"If you use server public key you aren't meeting the goal. Don't miss the \"for specific user\" in the statement"},{"comments":[{"timestamp":"1614681480.0","comments":[{"upvote_count":"1","timestamp":"1701100080.0","content":"Can you explain why you think this?","poster":"stefanop","comment_id":"1081725"}],"upvote_count":"2","comment_id":"301910","content":"thanks for your insight! C is correct.","poster":"Tobbe"},{"timestamp":"1617265560.0","comment_id":"325641","content":"I cannot agree with you. Before one be able to pretend to be someone else, he should know his (someone's) password on the Chat Server...","poster":"lynx256","upvote_count":"1"},{"timestamp":"1627893000.0","upvote_count":"4","poster":"PeppaPig","content":"SSL doesn't use server's public key to encrypt data. This is definitely wrong. Please read SSL specs. SSL uses a separate session key for message encryption. This session key is temporary and will be rotated for every single session.","comment_id":"418605"}],"timestamp":"1614243180.0","comment_id":"298882","poster":"Alekshar","upvote_count":"6","content":"If you use the server's public certificate to encrypt your data you only ensure the right server is the only one to read you. \n\nBut anyone can use the same encryption key as you did and pretend to be you. Hence it does not solve our authentication problematic"}],"poster":"Tobbe"},{"timestamp":"1738564020.0","upvote_count":"1","poster":"hpf97","content":"Selected Answer: C\nA : a tag can be spoofed by anybody\nB : so for a shared key\nD : can only secure the communication but ensure the sender's identity\nC : good answer","comment_id":"1350763"},{"upvote_count":"3","poster":"Ekramy_Elnaggar","comment_id":"1314166","content":"Selected Answer: C\n1. Digital Signatures and Non-Repudiation: PKI provides the foundation for digital signatures. When a user sends a message, it's encrypted with their private key. The recipient can then use the sender's public key to decrypt it. This ensures:\n - Authenticity: The message truly originated from the claimed sender.\n - Non-repudiation: The sender cannot deny sending the message.\n - Integrity: The message hasn't been tampered with in transit.\n\n2. How it prevents spoofing: Since only the sender has access to their private key, no one else can create a message that would decrypt correctly with their public key. This effectively prevents spoofing.","timestamp":"1731956760.0"},{"upvote_count":"4","comment_id":"1224251","poster":"Chojrak","timestamp":"1717524360.0","content":"The \"C\" answer is either messed up on purpose, or somebody dumped it wrong. \n\nWhen you use PKI (Public Key Infrastructure), you encrypt using a _public_ key of the recipient, and the recipient decrypts using their _private_ key. Sample reference that this is correct: https://www.keyfactor.com/education-center/what-is-pki/\n\nOn the contrary, when a messages is _digitally signed_, the originator is using their _private_ key to sign the message, and the recipient is verifying it using _public key_ of the _originator_.\n\nI still don't know which answer would I choose on the actual exam."},{"poster":"yas_cloud","timestamp":"1706800440.0","comment_id":"1137723","content":"Option A is not secure because anyone who intercepts the message could modify the user identifiers. Option B does not provide a way to verify the sender’s identity. Option D is important for securing the connection between the client and server, but it does not prevent message spoofing by itself.\nHence C.","upvote_count":"1"},{"content":"Selected Answer: C\nI was considering D, but nope, C:\nhttps://support.google.com/messages/answer/10262381#:~:text=your%20device%20and%20the%20device%20you%20message","upvote_count":"1","comment_id":"1078794","poster":"02fc23a","timestamp":"1700772840.0"},{"poster":"_kartik_raj","upvote_count":"1","comment_id":"1055078","comments":[{"upvote_count":"1","comment_id":"1069491","timestamp":"1699891560.0","comments":[{"timestamp":"1701100140.0","content":"Why? Can you explain that?","poster":"stefanop","upvote_count":"1","comment_id":"1081726"}],"poster":"ArtistS","content":"Thanks for your explanation, so I choose C....."}],"timestamp":"1698375540.0","content":"Answer : D\nLet me clarify , what PKI is saying i think first the answer is D , reason , Just understand what it says , i.e. option c - Using PKI to encrypt messages using the originating user's private key, now couple people are saying that it is good and then the server will decrypt the msg using public key, but can't you see anyone in the whole world will be able to see the messages as public key is available publicly. ideally what should have been the solution, Using the public key of receiver the messages should have been encrypted then the receiver would have decrypted using his private key, which absolutely makes sense, Talking about ssl i think its one of the widely used secure tech for communication between client and server"},{"upvote_count":"4","timestamp":"1696514340.0","comment_id":"1025735","poster":"AdityaGupta","content":"Selected Answer: C\nOption C - Use public key infrastructure (PKI) to encrypt the message client-side using the originating user's private key: Using PKI to encrypt messages using the originating user's private key provides end-to-end encryption, which means only the intended recipient can decrypt the message. This option also ensures that the message's authenticity is protected. If a malicious user changes the sender's name, the recipient will not be able to decrypt the message since it was not encrypted using the correct private key. This option is a strong method for securing chat messages."},{"comments":[{"upvote_count":"1","content":"But still, spoofing is not about reading data in clear but impersonating someone else. \nUsing D you can sign the message by confirming your identity.","poster":"stefanop","comment_id":"1081728","timestamp":"1701100200.0"}],"timestamp":"1689950100.0","upvote_count":"3","content":"C is wrong because private can only be used for signing, not encrypting. Public key is used for encrypting, private key is used for decrypting.","comment_id":"958610","poster":"patricklin1105"},{"upvote_count":"3","timestamp":"1688632080.0","content":"Selected Answer: C\nAs question is about ensuring a specific user sent a message, answer could not be D, which would ensure secure message transmission, but not message origin (which can only be done by using asymmetric key)","comments":[{"poster":"stefanop","upvote_count":"1","content":"So the sender is signing the message while encrypting it with the private key?","comment_id":"1081732","timestamp":"1701100320.0"}],"poster":"BigfootPanda","comment_id":"944437"},{"comment_id":"918149","upvote_count":"1","poster":"oriori123123","timestamp":"1686221460.0","content":"bard say D.\nand ChatGTP say C.."},{"upvote_count":"1","content":"Selected Answer: C\nI noticed this question in other tests and the suggested answer was C.","comment_id":"859861","poster":"ionescuandrei","timestamp":"1680522120.0"},{"comment_id":"839664","upvote_count":"4","timestamp":"1678868040.0","poster":"JC0926","content":"Selected Answer: C\nTo prevent message spoofing, it is important to ensure that messages cannot be altered or forged by anyone other than the originating user. One way to accomplish this is by using public key infrastructure (PKI) to encrypt messages using the originating user's private key."},{"poster":"omermahgoub","content":"To ensure that chat messages cannot be spoofed and that the messages are truly sent by a specific user, the best option would be to use public key infrastructure (PKI) to encrypt the message client side using the originating user's private key. This would allow the recipient to verify the authenticity of the message by using the originating user's public key to decrypt the message.\n\nOption A, tagging the message with the originating user identifier and the destination user, would not ensure the authenticity of the message, as it could potentially be forged by an attacker.","comments":[{"timestamp":"1671609420.0","upvote_count":"2","content":"Option B, encrypting the message using block-based encryption with a shared key, would also not ensure the authenticity of the message, as the shared key could potentially be compromised by an attacker.\n\nOption D, using a trusted certificate authority to enable SSL connectivity between the client application and the server, would help to secure the communication channel between the client and the server, but it would not necessarily ensure the authenticity of the chat messages themselves.\n\nOverall, using PKI and the originating user's private key to encrypt the message would be the most effective way to ensure the authenticity of the chat messages in your mobile chat application.","comment_id":"751992","poster":"omermahgoub"}],"comment_id":"751991","timestamp":"1671609420.0","upvote_count":"3"},{"content":"C is the answer, The requirement is the integrity of messages sent in CIA security (Confidentiality, Integrity, and Availability). For Confidentiality, using PublicKey of receiver, for Integrity, using PrivateKey of sender. D works in case of SSL client authentication.","comment_id":"731127","timestamp":"1669785660.0","upvote_count":"3","poster":"FateSpringfield"},{"comment_id":"716574","timestamp":"1668243120.0","upvote_count":"1","poster":"megumin","content":"Selected Answer: C\nC is ok"},{"content":"Selected Answer: C\nPKI uses X.509 certificates and Public Keys, where the key is used for end-to-end encrypted communication, so that both parties can trust each other and test their authenticity. PKI is mostly used in TLS/SSL to secure connections between the user and the server, while the user tests the server’s authenticity to make sure it’s not spoofed","upvote_count":"1","poster":"AjayPandit","comment_id":"711081","timestamp":"1667559540.0"},{"content":"C is the best\nA: Can be spoofed by amending the tags\nB: Shared key so can be spoofed\nC: Protects from start to end\nD: Encrypts the data in transit to the server. Attack possible on server","comment_id":"681947","poster":"BiddlyBdoyng","timestamp":"1664384520.0","upvote_count":"5"},{"timestamp":"1663834500.0","poster":"holerina","comment_id":"675877","content":"D is the right answer use SSL","upvote_count":"2"},{"comment_id":"664028","poster":"binisho123","timestamp":"1662671880.0","content":"\"Use public key infrastructure (PKI) to encrypt the message client side using the originating user's PRIVATE KEY\" How on earth can you encrypt with another party Private key???\nAnswer is D","upvote_count":"4"},{"timestamp":"1661943060.0","upvote_count":"4","poster":"aut0pil0t","comment_id":"655008","comments":[{"upvote_count":"1","content":"C is good in this scnario","poster":"AzureDP900","comment_id":"696566","timestamp":"1665953820.0"}],"content":"Selected Answer: C\nD will just ensure the traffic's confidentiality and no one interferes in the middle. It cannot verify the actual user's identity at the application level. If it is spoofed at the origin, D will just pass it along. Only a public/private key pair can act against spoofing an identity. D can supplement C though. Easy C."},{"timestamp":"1659556980.0","content":"SSL connection using Certificates provides secure communication channel between the client and server, thereby preventing anyone from tampering with the data being exchanged. D is the correct answer","comment_id":"642069","poster":"faagee01","upvote_count":"1"},{"poster":"Xumbegnows","upvote_count":"4","comments":[{"timestamp":"1662671820.0","content":"I am like \"DAA\"","poster":"binisho123","comment_id":"664027","upvote_count":"1"}],"content":"Selected Answer: D\nAs far as I understand, you don't encrypt data with your own private key in PKI. Instead you encrypt with the public key of your peer and the peer can decrypt with its private key since it knows them both. \nI believe D makes more sense.","comment_id":"609810","timestamp":"1654014720.0"},{"comment_id":"599331","content":"Selected Answer: D\nD as explained in my comment before .","timestamp":"1652140620.0","poster":"amxexam","upvote_count":"1"},{"content":"SSL ensures the integrity on the wire but short of proving the identity of a specific user. Hence will go with C","comment_id":"568553","timestamp":"1647365160.0","upvote_count":"1","poster":"slars2k"},{"comment_id":"545477","poster":"[Removed]","upvote_count":"3","content":"Selected Answer: C\nI got similar question on my exam.","timestamp":"1644611040.0"},{"poster":"Meyucho","timestamp":"1642529940.0","comment_id":"526909","content":"The question statement says \"for specific user\" so the only solution that is different for every user is using his private key to encrypt... So C is the correct answer.","upvote_count":"2"},{"content":"Selected Answer: C\nI vote C.\nThis is a problem with non-repudiation, which is one of the ways to use certificates.\nA,B These are incomplete.\nD A server certificate can only provide server authenticity","poster":"OrangeTiger","comment_id":"514423","timestamp":"1641024120.0","upvote_count":"2"},{"timestamp":"1640432880.0","poster":"vincy2202","upvote_count":"2","comment_id":"509086","content":"C is the correct answer"},{"comment_id":"504074","poster":"andeu","upvote_count":"2","timestamp":"1639812420.0","content":"Selected Answer: C\nAnswer C is correct"},{"comment_id":"500018","poster":"andeu","upvote_count":"2","timestamp":"1639314960.0","content":"Selected Answer: D\nCorrect Answer: D"},{"poster":"mgm7","upvote_count":"1","comments":[{"timestamp":"1639228140.0","upvote_count":"2","poster":"mgm7","comment_id":"499414","content":"Ooops, I read it wrong, the private key is on the client side. I wish there was a way to cancel ones comment."}],"timestamp":"1639227900.0","comment_id":"499412","content":"Selected Answer: D\nWho ever answers C, think about this: The private key should always be protected and never leave the owner."},{"comment_id":"495914","content":"Go for C (PKI).\nIn a book of google, with the same question , don´t appear the option D (SSL).","upvote_count":"1","poster":"haroldbenites","timestamp":"1638876000.0"},{"comment_id":"489493","upvote_count":"1","poster":"duocnh","content":"Selected Answer: C\nvote C","timestamp":"1638143040.0"},{"content":"Selected Answer: C\nCorrect answer is C","upvote_count":"1","timestamp":"1637317620.0","comment_id":"481563","poster":"TheCloudBoy77"},{"upvote_count":"1","timestamp":"1637217540.0","comment_id":"480480","poster":"Danny2021","content":"https://security.stackexchange.com/questions/81760/what-happens-when-encrypting-with-private-key . Why is this question related to GCP? It has nothing to do with GCP."},{"timestamp":"1635143160.0","comment_id":"467274","upvote_count":"1","poster":"MaxNRG","content":"C is correct because PKI requires that both the server and the client have signed certificates, validating both the client and the server.\nD is not correct because SSL only requires the server to have a signed certificate and does not require validating the client."},{"poster":"unnikrisb","comment_id":"459560","upvote_count":"4","timestamp":"1633769220.0","content":"It's part of Google Practice Exam \nAnswer is C : because PKI requires that both the server and the client have signed certificates, validating both the client and the server."},{"content":"Answer is D. SSL Handshakes includes these general steps:\n\n- The server sends its public key.\n- The client encrypts setup info with that public key, and sends it back to the server.\n- The server decrypts the client's submission and uses it to derive a shared secret.\n- Further steps use that shared secret to set up the actual encryption to be used.\nSo the answer to this question is, since an imposter can't perform step 3 (since it doesn't have the private key) it can never move on to step 4. It doesn't have the shared secret, so it can't complete the handshake. SSL is the way to go.","comment_id":"441562","upvote_count":"2","poster":"pr2web","timestamp":"1631120460.0"},{"poster":"amxexam","comments":[{"content":"<<URL>> https://www.cryptomathic.com/news-events/blog/symmetric-key-encryption-why-where-and-how-its-used-in-banking","timestamp":"1631024100.0","comment_id":"440959","poster":"amxexam","upvote_count":"1"}],"upvote_count":"5","content":"Going against the tide\n\nWe are overthinking a simple problem, whose solution is widely available.\n\nLet's go with option elimination\n\nA. Tag messages are client-side with the originating user identifier and the destination user.\n>> If a user can spoof the user he is able to read the messages not intended for him (middle man) then he can spoof the tag as well. Hence let's eliminate the option.\n\nB. Encrypt the message client-side using block-based encryption with a shared key.\n>> As per this site <<URL>> is the correct use for the above scenario. But still won't as there are better alternatives available, hence eliminating.\n\nC. Use public key infrastructure (PKI) to encrypt the message client-side using the originating user's private key.\n>> Better than B as B is an old approach. This is nothing but option D being manually implemented.\n\nD. Use a trusted certificate authority to enable SSL connectivity between the client application and the server.\n>> This is a standard approach or widely used solution for the above case. Simply and really available solution.\n\nHence D","comment_id":"434499","timestamp":"1630233600.0"},{"timestamp":"1628955900.0","comment_id":"424843","poster":"PeppaPig","upvote_count":"1","content":"Another reason C is not correct is that encrypting messages with asymmetrical key (private+public) would be very slow in performance\nhttps://security.stackexchange.com/questions/105032/why-is-the-subjects-public-key-not-used-for-encryption-in-ssl"},{"poster":"PeppaPig","content":"C requires users to upload their public keys to the server, then server forwards public keys to the receiver which IMO is definitely NOT feasible.\nSSL/TLS includes message encryption through the session key, and that's good enough to prevent spoofing","comments":[{"comment_id":"441882","poster":"MikeB19","content":"I agree that would not be a good exp for users and thus the app would not be used. If I had to do this in teams or slack i would simply stop using the app","timestamp":"1631180700.0","upvote_count":"2"}],"comment_id":"418601","upvote_count":"3","timestamp":"1627892700.0"},{"upvote_count":"1","comment_id":"406669","poster":"kopper2019","timestamp":"1626315300.0","content":"hey guys new Qs posted as of July 12th, 2021, All 21 new Qs in Question #152"},{"poster":"k_grdn","timestamp":"1626202080.0","content":"D. You can't encrypt with somebody else's private key, they encrypt and supply the private key.","comment_id":"405644","upvote_count":"1"},{"timestamp":"1626157260.0","content":"D should be the correct answer. Though it is technically viable, it doesn't make sense to encrypt user messages with public key and decrypt them with private key. That takes too much computing power on a mobile device. It is not common in the real world. In addition, the design will require every mobile device to upload their public key before they can start the secure communication. That won't scale very well.","comment_id":"405193","upvote_count":"1","poster":"sha1pain"},{"timestamp":"1625787840.0","poster":"bala786","upvote_count":"1","content":"Agree with Option - C - PKI requires that both the server and the client have signed certificates, validating both the client and the server.","comment_id":"402294"},{"comment_id":"401801","upvote_count":"1","poster":"MamthaSJ","content":"Answer is C","timestamp":"1625741100.0"},{"timestamp":"1621405500.0","poster":"victory108","content":"C. Use public key infrastructure (PKI) to encrypt the message client side using the originating user's private key.","comment_id":"361078","upvote_count":"2"},{"upvote_count":"1","content":"C is correct","poster":"un","comment_id":"354897","timestamp":"1620753000.0"},{"poster":"Ausias18","timestamp":"1617685860.0","comment_id":"329291","content":"Answer is C","upvote_count":"1"},{"poster":"lynx256","content":"Taking above into account, C is NOT correct because it requires CLIENT to have private key, which seems extraordinary.\nWe first have to do D and then use B (B cannot be provided without D). \nHense, IMO, D is the correct answer.\nBut, as I wrote, I'm not an expert in this field so could someone comment my explanation ?","upvote_count":"1","timestamp":"1616690460.0","comment_id":"320377"},{"poster":"lynx256","content":"Ref: https://en.wikipedia.org/wiki/Transport_Layer_Security\nTLS is successor of SSL\nOnce the client and server have agreed to use TLS, they negotiate a stateful connection by using a handshaking procedure.\nThe protocols use a handshake with an asymmetric cipher to establish not only cipher settings but also a session-specific SHARED KEY with which further communication is encrypted using a symmetric cipher. \nDuring this handshake, the client and server agree on various parameters used to establish the connection's security:\n[...]\nThe server usually then provides identification in the form of a digital certificate. The certificate contains the server name, the trusted CERTIFICATE AUTHORITY (CA) that vouches for the authenticity of the certificate, and the SERVER'S public encryption key.\n(The client generates session keys used for the secure connection. this sentence is my redaction) \n[...]\nThis concludes the handshake and begins the secured connection, which is encrypted and decrypted with the session key until the connection closes.","timestamp":"1616690400.0","upvote_count":"2","comment_id":"320376"},{"timestamp":"1616688960.0","comment_id":"320356","upvote_count":"1","content":"I'm not an expert in this filed... I agree, C is strongest... but does this mean EVERY user have to has private key to take part in the chat ?","poster":"lynx256"},{"content":"Agree with C, PKI is well known for encryption.","poster":"cert2020","comment_id":"293715","upvote_count":"1","timestamp":"1613682000.0"},{"content":"Some more information about PKI... https://blog.finjan.com/what-is-public-key-infrastructure-pki-and-how-is-it-used-in-cyber-security/","comment_id":"290986","upvote_count":"1","timestamp":"1613394300.0","poster":"JBX2010"},{"content":"The described use-case is *authentication*. The right answer is *C*.\n\nA. Legible tagging of messages does not prove the authenticity of the sender. \nB. The encryption of messages with a shared key is a step in the right direction. But the encryption cannot solve the authentication problem unless there is an authority that the parties both trust.\n*C*.Bingo. Public key infrastructure (PKI) is exactly about the authentication problem. It uses public-key encryption both for, well, encryption and authentication.\nD. SSL connectivity with the server addresses the authentication problem as well, but not between 2 users.","upvote_count":"3","comment_id":"278691","timestamp":"1611851580.0","poster":"egordoe"},{"timestamp":"1611790680.0","content":"Signing is what prevents spoofing, not encryption","comment_id":"278125","upvote_count":"1","poster":"Rothmansua"},{"upvote_count":"2","poster":"bnlcnd","comment_id":"276544","timestamp":"1611631020.0","content":"To be honest, I think none of the answers are worded clearly and correclty.\nA/B is out.\nD: \"a trusted certificate authority to enable SSL connectivity\" - it can work if Mutual TLS is enabled. But the answer is not clear.\nC: PKI is mentioned. But that's it. It does not explain how the PKI is used. No implementation will use private key to encrypt data. private key is only used in the hand-shake process. After hand-shake, a mutually agreed, shared, symmetric encryption key is used for the communication."},{"poster":"HKim","comment_id":"269629","content":"The key point is \"providing a message were sent by a SPECIFIC user.\" D secures the message payload but will not help with spoofing prevention. B would work if not for the mention of shared key. With shared key, it is no better than D. Therefore, C is the only solution that would stop the spoofing.","upvote_count":"3","timestamp":"1610900460.0"},{"upvote_count":"1","poster":"delubi","comment_id":"253562","content":"I would opt for D. Just curious: Which official practice exam has this question?","timestamp":"1609095300.0"},{"comments":[{"poster":"Alekshar","comments":[{"content":"I cannot agree with you. Before one be able to pretend to be someone else, he should know his (someone's) password on the Chat Server...","poster":"lynx256","comment_id":"325639","upvote_count":"1","timestamp":"1617265500.0"}],"upvote_count":"2","timestamp":"1614243000.0","content":"TLS ensures the request has not been intercepted and modifed, it does not prevent someone to create a fake request pretending to be someone else.\nWhereas PKI guarantees the authenticity of the originating user.\n\n\"Nobody does that anywhere\" because nobody you think about cares that much about authenticity, it would not be the case if your application is between army leaders or other critical communication mechanism.","comment_id":"298880"}],"comment_id":"187379","content":"Exact same question is on the AWS exams. It's C, but I don't really know why. Nobody would ever do that. You'd use TLS and that's it. Nobody is going to use private keys on a chat server. Nobody does that anywhere, but they say it's C for both GCP and AWS.","poster":"kimberjdaw","upvote_count":"2","timestamp":"1601083680.0"},{"timestamp":"1600781820.0","poster":"AshokC","content":"Answer C","upvote_count":"1","comment_id":"184460"},{"poster":"AshokC","timestamp":"1600132380.0","content":"Answer: C","comment_id":"179591","upvote_count":"1"},{"comment_id":"141891","timestamp":"1595497860.0","poster":"nerdicbynature","content":"Answer should be D:\n\nIn my opinion, C only would be correct if it were: \"Use public key infrastructure (PKI) to encrypt the message client side using the originating user's PUBLIC key.\"\n\nAs answer D assures both integrity and authenticity.","upvote_count":"3"},{"content":"private key is used to decrypt messages meant for you, if you encrypt stuff with your own private key - no one will be able to decrypt it.","upvote_count":"4","comment_id":"134693","poster":"theWildOne","timestamp":"1594715400.0"},{"poster":"Tushant","upvote_count":"1","comment_id":"114552","timestamp":"1592637180.0","content":"C is the correct answer"},{"timestamp":"1592387940.0","upvote_count":"2","comment_id":"112330","content":"Practice Exam confirms C as the answer","poster":"syu31svc"},{"content":"C, for sure.\nUse public key infrastructure (PKI) to encrypt the message client side using the originating user's private key.","poster":"gfhbox0083","timestamp":"1592024940.0","upvote_count":"1","comment_id":"109180"},{"content":"C is the correct answer","poster":"Nirms","timestamp":"1591109400.0","upvote_count":"1","comment_id":"100931"},{"comment_id":"98458","poster":"Ziegler","content":"C is the correct answer","timestamp":"1590781440.0","upvote_count":"1"},{"poster":"AD2AD4","upvote_count":"4","comment_id":"97340","content":"Final Decision to go with Option C as per Official Practice Exam","timestamp":"1590651300.0"},{"comment_id":"93578","poster":"gcp_aws","content":"I will go with C..","upvote_count":"1","timestamp":"1590089940.0"},{"timestamp":"1589679960.0","poster":"laksg","comment_id":"90262","content":"Agree C","upvote_count":"1"},{"content":"This is called end-to-end encryption uses PKI...","timestamp":"1585266660.0","poster":"desertlotus1211","upvote_count":"1","comment_id":"68454"},{"timestamp":"1580391480.0","poster":"2g","content":"answer: C","comment_id":"44747","upvote_count":"2"},{"content":"C is the ans","upvote_count":"2","poster":"AWS56","comment_id":"37984","timestamp":"1578829080.0"},{"timestamp":"1576207860.0","upvote_count":"2","comment_id":"29201","poster":"jtrianaf","content":"Corrrect answer is C"},{"timestamp":"1576136940.0","comment_id":"28963","poster":"MrBog1","content":"it depends it is a p2p program or c/s application","upvote_count":"1"},{"timestamp":"1574788560.0","comment_id":"24645","upvote_count":"1","comments":[{"timestamp":"1585021020.0","comment_id":"67431","upvote_count":"3","content":"The way it's worded it's not mTLS, it's just using a certificate authority. So, it's not D, because it sounds like it's just for authenticating the server, not authenticating client. Therefore C.","poster":"YuriP"}],"content":"A is not correct because although this would encrypt the message, it does not validate either the client or the server.\n\nB is not correct because a malicious actor could spoof the user identifier and destination user information.\n\nC is not correct because SSL only requires the server to have a signed certificate and does not require validating the client.\n\nD is correct because PKI requires that both the server and the client have signed certificates, validating both the client and the server.","poster":"shandy"},{"upvote_count":"2","poster":"MeasService","content":"It should be D considering overhead with PKI explained in answer B","comment_id":"16234","timestamp":"1571576580.0","comments":[{"content":"C, Public Key Infrastructure (PKI) is best option. SSL Cert is part of PKI which is next option.","poster":"nitinz","timestamp":"1614897000.0","comment_id":"303636","upvote_count":"2"},{"upvote_count":"4","timestamp":"1596696480.0","comment_id":"151751","content":"C is ok","poster":"tartar"}]}],"exam_id":4,"answer":"C","question_id":134,"unix_timestamp":1571576580,"answer_images":[],"answer_description":"","url":"https://www.examtopics.com/discussions/google/view/6844-exam-professional-cloud-architect-topic-1-question-39/","topic":"1","choices":{"D":"Use a trusted certificate authority to enable SSL connectivity between the client application and the server.","C":"Use public key infrastructure (PKI) to encrypt the message client side using the originating user's private key.","B":"Encrypt the message client side using block-based encryption with a shared key.","A":"Tag messages client side with the originating user identifier and the destination user."},"timestamp":"2019-10-20 15:03:00"},{"id":"zwBcupfPO0nlWUPS6EEM","timestamp":"2019-10-23 19:30:00","answer":"A","answers_community":["A (100%)"],"answer_images":[],"question_images":["https://www.examtopics.com/assets/media/exam-media/04339/0007100001.png"],"question_text":"A news feed web service has the following code running on Google App Engine. During peak load, users report that they can see news articles they already viewed.\nWhat is the most likely cause of this problem?\n//IMG//","exam_id":4,"discussion":[{"timestamp":"1726852260.0","comment_id":"600967","content":"It's A. AppEngine spins up new containers automatically according to the load. During peak traffic, HTTP requests originated by the same user could be served by different containers. Given that the variable `sessions` is recreated for each container, it might store different data.\nThe problem here is that this Flask app is stateful. The `sessions` variable is the state of this app. And stateful variables in AppEngine / Cloud Run / Cloud Functions are problematic.\nA solution would be to store the session in some database (e.g. Firestore, Memorystore) and retrieve it from there. This way the app would fetch the session from a single place and would be stateless.","comments":[{"content":"Very well stated, jack. I just wanted to point, GAE is a webserver platform anyway, so making application stateless or stateful is up to the developer and has nothing to do with GAE. The issue is about session consistency. GAE spin new container if there's a need, and based on the code, the session is stored locally, this means, there's no consistency between container, and there's no grantee that the same container might serve the same user. Thank you Jack, very good explanation","poster":"omermahgoub","upvote_count":"15","timestamp":"1670911620.0","comment_id":"743644"}],"poster":"jackdbd","upvote_count":"121"},{"timestamp":"1573742340.0","poster":"JoeShmoe","upvote_count":"29","comment_id":"21539","content":"A is correct"},{"timestamp":"1738064700.0","upvote_count":"1","content":"Selected Answer: A\nUser session is not stored in a shared \"memory\" which could be used by all App Engine instances running the application.","comment_id":"1347869","poster":"hpf97"},{"upvote_count":"3","timestamp":"1731263880.0","poster":"Ekramy_Elnaggar","comments":[{"timestamp":"1732377000.0","upvote_count":"1","poster":"desertlotus1211","comment_id":"1316716","content":"how would you change the code?"}],"comment_id":"1309577","content":"Selected Answer: A\nAnswer is A. The session variable is local to just a single instance.\n\nHere's why:\n\n* App Engine Instances: Google App Engine automatically scales your application by creating multiple instances to handle incoming traffic. Each instance runs independently and has its own memory space.\n\n* Session Variable: In the provided code, the `sessions` variable is a simple Python dictionary stored in the memory of each instance. This means each instance has its own copy of the `sessions` data.\n\n* The Problem: When a user logs in, their viewed articles are stored in the `sessions` variable of the instance that handled their request. If subsequent requests from the same user are routed to a different instance, that instance won't have any record of the previously viewed articles, causing them to be displayed again."},{"content":"A\nThe most likely cause of the issue described in the code is that the session variable is local to just a single instance. In this code, the session variable is defined as a local dictionary within the Flask application. This means that it is not shared across different instances of the application and will not be persisted between requests. As a result, when the application is running on multiple instances, each instance will have its own local copy of the session variable, and users may see news articles that they have already viewed on other instances.","upvote_count":"4","comment_id":"751973","poster":"omermahgoub","timestamp":"1726907640.0","comments":[{"upvote_count":"2","content":"To fix this issue, you could consider using a persistent storage solution, such as Cloud Datastore or Cloud SQL, to store the session data in a way that is shared across all instances of the application. This would allow you to maintain a consistent view of the session data for each user across all instances of the application.\n\nOther potential causes for this issue, such as modifying the URL of the API to prevent caching or setting the HTTP Expires header to -1 to stop caching, are not related to the issue described in the code and would not likely address the problem.","comment_id":"751974","poster":"omermahgoub","timestamp":"1671608160.0"}]},{"content":"The most likely cause of the reported issue is that the session variable is local to just a single instance.\n\nIn the code provided, the sessions variable is a dictionary that stores the viewed news articles for each user. However, this variable is only stored in memory on the instance that handles the request, and it is not shared between instances. Therefore, when a new request is handled by a different instance, it will not have access to the same session data, and the user may see previously viewed news articles.\n\nTo solve this problem, a shared session management system should be used that can be accessed by all instances. Google App Engine provides a few options for session management, such as using Memcache or Cloud Datastore to store the session data. By using a shared session management system, all instances can access the same session data, and users will not see previously viewed news articles.","poster":"Badri9898","upvote_count":"8","timestamp":"1726907640.0","comment_id":"854817"},{"poster":"kurili","timestamp":"1726460460.0","content":"A.The sessions dictionary is used to store user-specific data, such as which news articles have been viewed. This dictionary is created as an in-memory variable within the Flask app.\nIn a cloud environment, like Google App Engine, the application may be running on multiple instances, especially during peak loads. Since the sessions dictionary is stored in memory, it is local to each instance.\nThis means that if a user is routed to a different instance (due to load balancing), their session data will not be available on that new instance, causing the application to serve news articles they’ve already seen.","upvote_count":"1","comment_id":"1284460"},{"poster":"simonab23","content":"A is the right answer","comment_id":"789688","timestamp":"1674830280.0","upvote_count":"1"},{"content":"Where in the code does it show that the session variable is local to just a single instance?","comment_id":"762446","poster":"jay9114","upvote_count":"3","timestamp":"1672455000.0"},{"poster":"Amrit123_","comment_id":"750934","upvote_count":"1","content":"A is correct","timestamp":"1671543240.0"},{"timestamp":"1669462920.0","poster":"angelumesh","comment_id":"727477","upvote_count":"1","content":"Selected Answer: A\nstateful variable should be in firestore (redis)."},{"timestamp":"1668269280.0","poster":"Racinely","upvote_count":"1","comment_id":"716794","content":"I agree with ackdbd"},{"content":"Selected Answer: A\nA is the correct answer app becoming stateful and it should not be sin case of app engine, cloud run and functions","poster":"Mahmoud_E","timestamp":"1666451460.0","upvote_count":"1","comment_id":"701600"},{"comment_id":"693079","timestamp":"1665577680.0","content":"Selected Answer: A\nA. The session variable is local to just a single instance\nThe others are not relevant","poster":"minmin2020","upvote_count":"1"},{"poster":"sgofficial","timestamp":"1659209700.0","comment_id":"639791","content":"Thank you that was nice explanation","upvote_count":"2"},{"poster":"jay9114","upvote_count":"2","comment_id":"635693","content":"Where was this presented in the GCP Architecture training & labs?","timestamp":"1658595300.0"},{"poster":"backhand","timestamp":"1658536920.0","comment_id":"635393","content":"vote A\n- rule out C,D not thing to do with problem\n- rule out B, Q is not mention datastore","upvote_count":"2"},{"upvote_count":"1","poster":"nicoueron","timestamp":"1656315900.0","comment_id":"623132","content":"Selected Answer: A\nA of course, it's just a code pb here"},{"timestamp":"1653681600.0","content":"A seems correct","comment_id":"608189","upvote_count":"1","poster":"Superr"},{"upvote_count":"2","poster":"vincy2202","content":"Selected Answer: A\nA is the correct answer","comment_id":"508393","timestamp":"1640335320.0"},{"upvote_count":"1","poster":"haroldbenites","timestamp":"1638546300.0","content":"o for A","comment_id":"493208"},{"content":"Selected Answer: A\nvote A","comment_id":"489471","upvote_count":"1","timestamp":"1638141720.0","poster":"duocnh"},{"poster":"exam_war","upvote_count":"2","content":"I'll go with A","timestamp":"1635983460.0","comment_id":"472329"},{"content":"A is the correct answer","timestamp":"1624410420.0","comment_id":"388411","poster":"Papafel","upvote_count":"2"},{"comment_id":"360129","timestamp":"1621318020.0","poster":"victory108","content":"A. The session variable is local to just a single instance","upvote_count":"3"},{"comment_id":"359930","upvote_count":"1","poster":"Amber25","timestamp":"1621299540.0","content":"Answer A.\n\nDuring peak load it might be possible that Uttar connect through different session and since session is declared locally it will overwrite previous watched videos"},{"content":"I would choose \"B\" because in code \n\" news_articles = news.get_new_news (user, seasione [user]\n[\"viewed\"])\" \nlook like get back user already viewed news.","comment_id":"355113","upvote_count":"1","poster":"changronon","timestamp":"1620779820.0"},{"timestamp":"1620550020.0","comment_id":"352900","content":"A is correct","poster":"un","upvote_count":"1"},{"comment_id":"349773","upvote_count":"1","poster":"kumar2009","timestamp":"1620161460.0","content":"A is correct. There is nothing related to datastore here."},{"upvote_count":"1","timestamp":"1617078900.0","content":"Answer is A","comment_id":"323958","poster":"Ausias18"},{"timestamp":"1613343540.0","upvote_count":"1","comment_id":"290549","content":"I would go with Option \"A\". \nDon't see how Datastore came into discussion.","poster":"Joyjit_Deb"},{"upvote_count":"1","poster":"BobBui","comment_id":"278637","content":"A is correct","timestamp":"1611846840.0"},{"upvote_count":"1","comment_id":"239507","content":"A is correct","poster":"svjl","timestamp":"1607545560.0"},{"timestamp":"1601091540.0","content":"I think the answer is A.\n\nC, D is rule out, because of this statement \" During peak load, users report that they can see news articles they already viewed\". C & D got nothing to with peak load.\n\nLeft A and B.\nFrom the codes, I cannot conclude data store or any form of database is involved (unless you got the source code to the function that retrieve the data)\nSo, this rules out B.\n\nTherefore, I will pick A.","poster":"VedaSW","comments":[{"comment_id":"235997","poster":"willrof","upvote_count":"1","content":"i believe A as well, as it's directly related to peak load (thus, autoscaling), not an expert but I believe if B was the issue it would happen even when load are not at peak.","timestamp":"1607197800.0"}],"comment_id":"187406","upvote_count":"6"},{"upvote_count":"1","poster":"Viba","content":"https://stackoverflow.com/questions/46887869/google-app-engine-session-changes-between-instances","timestamp":"1601023140.0","comment_id":"186826"},{"timestamp":"1600092300.0","content":"A make sense","upvote_count":"1","comment_id":"179333","poster":"AshokC"},{"comment_id":"175714","timestamp":"1599551460.0","upvote_count":"1","content":"should not be overwritten in Cloud Datastore: App Engine includes an implementation of sessions, using the servlet session interface. The implementation stores session data in the App Engine datastore for persistence, and also uses memcache for speed. As with most other servlet containers, the session attributes that are set with `session.setAttribute()` during the request are persisted at the end of the request. \nwell, there're no setAttribute","poster":"olg"},{"comment_id":"175712","content":"should not be overwritten in Cloud Datastore: App Engine includes an implementation of sessions, using the servlet session interface. The implementation stores session data in the App Engine datastore for persistence, and also uses memcache for speed. As with most other servlet containers, the session attributes that are set with `session.setAttribute()` during the request are persisted at the end of the request. \nwell, there're no setAttribute","upvote_count":"2","poster":"olg","timestamp":"1599551340.0"},{"poster":"gkdinesh","content":"A is correct","comment_id":"174584","upvote_count":"2","timestamp":"1599398580.0"},{"timestamp":"1598543160.0","poster":"Kabiliravi","upvote_count":"1","comment_id":"167680","content":"A is correct"},{"timestamp":"1594602660.0","upvote_count":"3","content":"Correct is A","poster":"AS007","comment_id":"133389","comments":[{"comment_id":"139313","upvote_count":"1","timestamp":"1595237520.0","content":"A is more related to the \"peak load\" issue","poster":"ohcan"}]},{"timestamp":"1594032420.0","upvote_count":"1","comment_id":"127693","poster":"pupi08","content":"A is correct!"},{"upvote_count":"1","poster":"Gobblegobble","timestamp":"1593932040.0","comment_id":"126669","content":"A is right answer"},{"comment_id":"121744","comments":[{"timestamp":"1602675780.0","comment_id":"199745","content":"true, but the actual articles read are stored in sessions variable, which is local","upvote_count":"1","poster":"Mihai_"}],"timestamp":"1593333600.0","upvote_count":"1","content":"Value of user variable = users.get_current_user(), this method is accessing cloud datastore value. So those of you saying datastore is not in the picture, it actually is being called.","poster":"definepi314"},{"comment_id":"116642","content":"A is the correct","timestamp":"1592846340.0","upvote_count":"1","poster":"mlantonis"},{"poster":"Mimgq","comment_id":"115395","timestamp":"1592729100.0","content":"https://cloud.google.com/appengine/docs/standard/java/config/appref#static_cache_expiration The expiration time will be sent in the Cache-Control and Expires HTTP response headers, and therefore, the files are likely to be cached by the user's browser, as well as by intermediate caching proxy servers such as Internet Service Providers.","upvote_count":"1"},{"upvote_count":"1","content":"(A) is the correct answer. session variable is local to one instance of AppEngine. In case autoscalling kicks in, a new session variable is instantiated in a new instance.","poster":"Husein","timestamp":"1591690260.0","comment_id":"105777"},{"content":"I don't think A can be correct, as you never know which \"server\" you will use as app engine scales automatically while the number of requests are growing.","timestamp":"1591598880.0","upvote_count":"1","poster":"pf38120","comments":[{"timestamp":"1591599120.0","comment_id":"105084","upvote_count":"1","poster":"pf38120","content":"I would go to B as per the link mentined in the answer"}],"comment_id":"105081"},{"timestamp":"1591163040.0","comment_id":"101438","content":"Correct Answer is A","upvote_count":"1","poster":"Tushant"},{"content":"A is the correct answer","comment_id":"100807","poster":"Nirms","timestamp":"1591101480.0","upvote_count":"1"},{"content":"D seems correct ( disable cache)","comment_id":"99100","poster":"nrajesh","timestamp":"1590892500.0","upvote_count":"3"},{"comment_id":"98262","content":"A is the asnwer","timestamp":"1590761220.0","poster":"Ziegler","upvote_count":"2"},{"upvote_count":"2","comment_id":"97271","timestamp":"1590643500.0","poster":"AD2AD4","content":"Final Decision to go with Option A"},{"timestamp":"1590270060.0","upvote_count":"1","comment_id":"94583","content":"Agree A","poster":"Javed"},{"comments":[{"comments":[{"upvote_count":"1","content":"Finally someone who got the answer","timestamp":"1677765900.0","comment_id":"826960","poster":"MestreCholas"}],"comment_id":"141136","timestamp":"1595421360.0","content":"users.get_current_user() method is the User Python datastore class to be used as a datastore data type.\n(https://cloud.google.com/appengine/docs/standard/python/refdocs/modules/google/appengine/api/users#get_current_user) so therefore there is a datastore integration.\n\nHowever session info is kept locally on the 7th line with;\nsessions = {}\nand updated locally with the following line of code;\nsessions [user] [\"viewed\"] += [n[[\"id\"] for n in news_articles]\n\nSo session is kept locally on each GAE instance, answer is \"A\"","poster":"cetanx","upvote_count":"12"}],"poster":"clouddude","upvote_count":"6","content":"I'll go with A. There's not a lot of information here so...\nA seems the most reasonable because App Engine might be scaling due to load so the user might be going to a different instance which has a different copy of the sessions variable.\nB doesn't seem right because we have no info about the underlying datastore and there is no datastore referenced in the code.\nC doesn't seem right because changing the API path wouldn't accomplish anything since all the Flask requests currently get sent to the same code.\nD doesn't seem right because stopping caching wouldn't necessarily address this.","comment_id":"86239","timestamp":"1589059740.0"},{"upvote_count":"3","comment_id":"83877","poster":"rbrto","timestamp":"1588638360.0","content":"answer is A because there is no connection to Datastore"},{"poster":"Phane","timestamp":"1580844120.0","comments":[{"comment_id":"194385","timestamp":"1601998320.0","poster":"IsaB","content":"Never consider the answer written per default. Always check for the answer in the comments. Answers there seem random.","upvote_count":"3"}],"upvote_count":"2","comment_id":"46639","content":"Hi - Most people below \"A\" is the correct answer but per the site it's \"B\" so which one is correct?"},{"poster":"2g","content":"answer: A","timestamp":"1580389260.0","upvote_count":"5","comment_id":"44691"},{"upvote_count":"4","poster":"natpilot","content":"Correct answer is A.","timestamp":"1580021400.0","comment_id":"42784"},{"timestamp":"1578768000.0","poster":"AWS56","upvote_count":"11","content":"A is the answer","comment_id":"37803"},{"comment_id":"29508","timestamp":"1576314900.0","content":"Correct answer is A.\nOption B is wrong as there is no Datastore interaction.","poster":"aviv","upvote_count":"8"},{"upvote_count":"3","comments":[{"comment_id":"151036","timestamp":"1596618960.0","upvote_count":"11","content":"A is ok","poster":"tartar"}],"content":"The session variable is local to this python code, in order to set it with data from another code block you much import that code block and use it's data. Option \"B\" is implying the code was already imported at the top, which it was not.","comment_id":"17004","poster":"Eroc","timestamp":"1571851800.0"}],"unix_timestamp":1571851800,"answer_ET":"A","choices":{"B":"The session variable is being overwritten in Cloud Datastore","C":"The URL of the API needs to be modified to prevent caching","A":"The session variable is local to just a single instance","D":"The HTTP Expires header needs to be set to -1 stop caching"},"answer_description":"","question_id":135,"isMC":true,"url":"https://www.examtopics.com/discussions/google/view/7085-exam-professional-cloud-architect-topic-1-question-4/","topic":"1"}],"exam":{"numberOfQuestions":279,"isImplemented":true,"lastUpdated":"11 Apr 2025","name":"Professional Cloud Architect","isMCOnly":false,"id":4,"provider":"Google","isBeta":false},"currentPage":27},"__N_SSP":true}