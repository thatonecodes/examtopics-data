{"pageProps":{"questions":[{"id":"TheUOOJxW7QnwOT61ABa","answer_ET":"A","answer_description":"","exam_id":11,"url":"https://www.examtopics.com/discussions/google/view/130292-exam-professional-data-engineer-topic-1-question-289/","question_text":"You have data located in BigQuery that is used to generate reports for your company. You have noticed some weekly executive report fields do not correspond to format according to company standards. For example, report errors include different telephone formats and different country code identifiers. This is a frequent issue, so you need to create a recurring job to normalize the data. You want a quick solution that requires no coding. What should you do?","topic":"1","isMC":true,"answers_community":["A (81%)","D (19%)"],"choices":{"D":"Use BigQuery and GoogleSQL to normalize the data, and schedule recurring queries in BigQuery.","A":"Use Cloud Data Fusion and Wrangler to normalize the data, and set up a recurring job.","B":"Use Dataflow SQL to create a job that normalizes the data, and that after the first run of the job, schedule the pipeline to execute recurrently.","C":"Create a Spark job and submit it to Dataproc Serverless."},"question_images":[],"discussion":[{"timestamp":"1705166580.0","comment_id":"1121903","upvote_count":"8","content":"Selected Answer: A\nDefinitely A, cloud data fusion and wrangler to setup the clean up pipeline with no coding required","poster":"Matt_108"},{"upvote_count":"2","timestamp":"1736196480.0","comment_id":"1337358","content":"Selected Answer: D\nThe question say \"You want a quick solution that requires no coding.\". The data is in BQ, then is most easy normalize the data, and schedule recurring queries in BigQuery.","poster":"marlon.andrei"},{"upvote_count":"2","timestamp":"1721581140.0","poster":"987af6b","content":"Selected Answer: A\nA. Use Cloud Data Fusion and Wrangler to normalize the data, and set up a recurring job.\n\nExplanation\nNo Coding Required: Cloud Data Fusion's Wrangler offers a no-code interface for data transformation tasks. You can visually design data normalization workflows without writing any code.\nRecurring Jobs: Cloud Data Fusion allows you to schedule these data normalization tasks to run on a recurring basis, meeting your need for automation.","comment_id":"1252611"},{"comments":[{"upvote_count":"1","timestamp":"1721155320.0","content":"Why other options aren't as suitable:\n\nA. Cloud Data Fusion and Wrangler: While powerful, these tools might be overkill for a simple normalization task and could involve a steeper learning curve.\nB. Dataflow SQL: Dataflow is primarily for stream processing and might not be the most efficient for batch transformations on data already in BigQuery.\nC. Dataproc Serverless: This involves using a Spark job, which requires coding and might be more complex than necessary for this task.","comment_id":"1249160","poster":"carmltekai"}],"comment_id":"1249158","poster":"carmltekai","timestamp":"1721155260.0","content":"Selected Answer: D\nThe best solution here is D. Use BigQuery and GoogleSQL to normalize the data, and schedule recurring queries in BigQuery.\n\nHere's why:\n\n* No-code solution: BigQuery's built-in capabilities and GoogleSQL offer a no-code way to transform and standardize data. You can leverage functions like REGEXP_REPLACE to normalize phone numbers and FORMAT to ensure consistent formatting across fields.\n* Recurring jobs: BigQuery allows you to schedule queries to run regularly, which is perfect for maintaining data consistency over time.\n* Quick and efficient: BigQuery is designed for large-scale data processing, making it fast and efficient for normalization tasks.","upvote_count":"2"},{"timestamp":"1718620380.0","poster":"fitri001","content":"Selected Answer: A\nhttps://cloud.google.com/data-fusion/docs","upvote_count":"2","comment_id":"1231876"},{"upvote_count":"1","content":"As per chatGPT, Option D allows you to utilize BigQuery's SQL capabilities to write queries that normalize the data according to company standards.\nYou can then schedule these queries to run on a recurring basis using BigQuery's scheduled queries feature. This feature allows you to specify a schedule (e.g., weekly) for executing SQL queries automatically.\nThis approach requires no additional setup or coding outside of BigQuery, making it a quick and straightforward solution to address the issue of data normalization.","poster":"SohiniV","comment_id":"1158648","comments":[{"timestamp":"1708859580.0","content":"Any views on this ?","upvote_count":"1","comment_id":"1158649","poster":"SohiniV","comments":[{"comment_id":"1159597","comments":[{"poster":"jreale64","timestamp":"1710828780.0","upvote_count":"1","comment_id":"1177023","content":"While Cloud Data Fusion with Wrangler offers a visual interface for data wrangling, it requires setting up the environment and potentially writing code for ransformations. So it its not appropriate. I think D"}],"upvote_count":"6","content":"Wouldn't writing the SQL transformation be considered coding? The question specifically states that a solution requiring no coding is needed.","timestamp":"1708943340.0","poster":"RenePetersen"}]}],"timestamp":"1708859520.0"},{"comment_id":"1155704","content":"Selected Answer: A\nOption A","timestamp":"1708533300.0","upvote_count":"1","poster":"JyoGCP"},{"content":"Selected Answer: A\nCloud Data Fusion and Wrangler","comment_id":"1118387","timestamp":"1704877440.0","poster":"Sofiia98","upvote_count":"2"},{"comment_id":"1113523","content":"Selected Answer: A\nA. Use Cloud Data Fusion and Wrangler to normalize the data, and set up a recurring job.","timestamp":"1704363120.0","poster":"scaenruy","upvote_count":"2"}],"timestamp":"2024-01-04 11:12:00","question_id":211,"answer":"A","unix_timestamp":1704363120,"answer_images":[]},{"id":"4fmZcmFoKpqhXPs00L8y","exam_id":11,"url":"https://www.examtopics.com/discussions/google/view/17029-exam-professional-data-engineer-topic-1-question-29/","answer_images":[],"question_id":212,"question_images":[],"question_text":"Your company is streaming real-time sensor data from their factory floor into Bigtable and they have noticed extremely poor performance. How should the row key be redesigned to improve Bigtable performance on queries that populate real-time dashboards?","topic":"1","answer_description":"","answers_community":["D (100%)"],"isMC":true,"answer":"D","choices":{"D":"Use a row key of the form >#<sensorid>#<timestamp>.","A":"Use a row key of the form <timestamp>.","B":"Use a row key of the form <sensorid>.","C":"Use a row key of the form <timestamp>#<sensorid>."},"unix_timestamp":1584688080,"timestamp":"2020-03-20 08:08:00","answer_ET":"D","discussion":[{"upvote_count":"33","comment_id":"68555","poster":"[Removed]","timestamp":"1601193000.0","content":"Description: Best practices of bigtable states that rowkey should not be only timestamp or have timestamp at starting. It’s better to have sensorid and timestamp as rowkey"},{"upvote_count":"19","poster":"[Removed]","timestamp":"1600578480.0","content":"Answer D","comment_id":"66207"},{"upvote_count":"2","poster":"axantroff","comment_id":"1076375","content":"Selected Answer: D\nLooks like D is the best option\nReference: https://cloud.google.com/bigtable/docs/schema-design#time-based","comments":[{"upvote_count":"1","comment_id":"1212704","poster":"mark1223jkh","timestamp":"1731827040.0","content":"Thank you that is right."}],"timestamp":"1716294900.0"},{"timestamp":"1713788040.0","poster":"rtcpost","upvote_count":"2","comment_id":"1050538","content":"Selected Answer: D\nD. Use a row key of the form <sensorid>#<timestamp>.\n\nBy using the sensor ID as the prefix in the row key, you can achieve better distribution of data across Bigtable tablets. This can help balance the workload and prevent hotspots in the table. Additionally, placing the timestamp after the sensor ID allows you to perform range scans for a specific sensor and retrieve data efficiently within a time frame.\n\nOption C (using a row key of the form <timestamp>#<sensorid>) can work for some use cases but may not be as efficient for range scans when you want to retrieve data for a specific sensor within a time range.\n\nOption A (using a row key of the form <timestamp>) may lead to hotspots and inefficient range scans because it doesn't consider sensor IDs.\n\nOption B (using a row key of the form <sensorid>) is not optimal because it doesn't allow for efficient time-based filtering and could lead to uneven data distribution in Bigtable."},{"upvote_count":"1","timestamp":"1688497200.0","comment_id":"766085","poster":"AzureDP900","content":"D is right\nBest practices of bigtable states that rowkey should not be only timestamp or have timestamp at starting. It’s better to have sensorid and timestamp as rowkey.\n\nReference:\nhttps://cloud.google.com/bigtable/docs/schema-design"},{"timestamp":"1686653640.0","comment_id":"744018","poster":"Nirca","content":"Selected Answer: D\n#<sensorid>#<timestamp> ------> low cardinality # high cardinality \nThis is current Bigtable Best Practice (to avoid Hotspots on the inserts)","upvote_count":"5"},{"poster":"maxdataengineer","timestamp":"1680952500.0","upvote_count":"1","content":"Selected Answer: D\nDiscard:\nA -> timestamp unique id could not be unique in the case that sensors transmit data at the same time.\nB -> sensorId repeated id for messages coming from the same sensor\nC -> a bad performance choice\n\nD -> BEST CHOICE. Each time BigTable looks for data in a table it does a scan and sort operations. By starting each unique id by sensorId it will make it easier to group and sort data since it has the lowest cardinality\nhttps://cloud.google.com/bigtable/docs/schema-design#general-concepts","comment_id":"689230"},{"comment_id":"663153","timestamp":"1678260540.0","poster":"John_Pongthorn","content":"as I look at https://cloud.google.com/bigtable/docs/schema-design#row-keys\n asia#india#bangalore\n asia#india#mumbai\nthey didn't have # ahead of this first value.\nasia#india#bangalore OR #asia#india#bangalore\nAre both valid?","upvote_count":"2"},{"content":"ANSWER: D","timestamp":"1676913840.0","comment_id":"649479","upvote_count":"1","poster":"crisimenjivar"},{"timestamp":"1671190560.0","content":"Selected Answer: D\nAnswer is D","comment_id":"617190","poster":"som_420","upvote_count":"1"},{"content":"A. Use a row key of the form <timestamp>. \n---> Incorrect, because google says don't use a timestamp by itself or at the beginning of a row key.\nB. Use a row key of the form <sensorid>.\n--->Incorrect, because google says Include a timestamp as part of your row key.\nC. Use a row key of the form <timestamp>#<sensorid>.\n---> Incorrect, because google says don't use a timestamp by itself or at the beginning of a row key.\nD. Use a row key of the form >#<sensorid>#<timestamp>.\n---> Correct answer, because of option A,B,C reasons.\n - Timestamp isn't by itself, neither at the beginning.\n - Timestamp is included.\n\nReference: https://cloud.google.com/bigtable/docs/schema-design#row-keys","comment_id":"530873","poster":"samdhimal","upvote_count":"9","timestamp":"1658609520.0"},{"poster":"anji007","timestamp":"1649779020.0","upvote_count":"2","comment_id":"461146","content":"Ans: D"},{"poster":"sumanshu","timestamp":"1640542980.0","upvote_count":"9","comment_id":"391401","comments":[{"comment_id":"401851","timestamp":"1641648600.0","content":"A is not correct because this will cause most writes to be pushed to a single node (known as hotspotting)\nB is not correct because this will not allow for multiple readings from the same sensor as new readings will overwrite old ones.\nC is not correct because this will cause most writes to be pushed to a single node (known as hotspotting)\nD is correct because it will allow for retrieval of data based on both sensor id and timestamp but without causing hotspotting.","upvote_count":"7","poster":"sumanshu"}],"content":"Vote for 'D' - Store multiple delimited values in each row key. (But avoid starting with Timestamp)\n\n\"Row keys to avoid\"\nhttps://cloud.google.com/bigtable/docs/schema-design"},{"content":"Correct D","comment_id":"285009","timestamp":"1628265900.0","poster":"naga","upvote_count":"2"},{"poster":"NamitSehgal","upvote_count":"3","comment_id":"243362","comments":[{"comment_id":"531428","content":"reverse TS or hashing is not always first choice or better. never.","timestamp":"1658670660.0","upvote_count":"1","poster":"Tanzu"}],"timestamp":"1623649020.0","content":"Should be D\nReverse of timestamp even better but no options for that.\nAlso changing sensor ID if they are in sequential to hash or changing data to bits even better.\nIdea is not to use timestamp or sequential ID as first key."},{"timestamp":"1621155000.0","upvote_count":"3","comment_id":"220259","poster":"Radhika7983","content":"The correct answer is D. \nRefer to the link https://cloud.google.com/bigtable/docs/schema-design for Big table schema design.\n\nC is not the right answer becuase\nTimestamps\nIf you often need to retrieve data based on the time when it was recorded, it's a good idea to include a timestamp as part of your row key. Using the timestamp by itself as the row key is not recommended, as most writes would be pushed onto a single node. For the same reason, avoid placing a timestamp at the start of the row key.\n\nFor example, your application might need to record performance-related data, such as CPU and memory usage, once per second for a large number of machines. Your row key for this data could combine an identifier for the machine with a timestamp for the data (for example, machine_4223421#1425330757685)."},{"timestamp":"1619876520.0","content":"answer would be D to avoid hotspoting..","upvote_count":"2","poster":"arghya13","comment_id":"210571"},{"content":"correct: D\nwhy not C? Using the timestamp by itself as the row key is not recommended, as most writes would be pushed onto a single node. For the same reason, avoid placing a timestamp at the start of the row key. https://cloud.google.com/bigtable/docs/schema-design#row-keys","timestamp":"1608450240.0","comment_id":"114456","upvote_count":"4","poster":"ch3n6"}]},{"id":"NcevfAn4G5Uu7yjoLiQQ","discussion":[{"poster":"raaad","timestamp":"1720563180.0","upvote_count":"15","content":"Selected Answer: D\n- Exponential Backoff: This retry policy gradually increases the delay between retries, which helps to avoid overloading the consumer app. \n- Dead Lettering to a Different Topic: Configuring dead lettering sends messages that couldn't be processed after the specified number of delivery attempts (10 in this case) to a separate topic. This allows for handling of failed messages without interrupting the regular flow of new messages.\n- Maximum Delivery Attempts Set to 10: This setting ensures that the system retries each message up to 10 times before considering it a failure and moving it to the dead letter topic.","comment_id":"1117956"},{"upvote_count":"1","comment_id":"1337150","content":"Selected Answer: D\nhttps://cloud.google.com/pubsub/docs/subscription-overview\n\nD. Use exponential backoff as the subscription retry policy, and configure dead lettering to a different topic with maximum delivery attempts set to 10.\nExponential Backoff: This retry policy helps to avoid overloading the consumer app by gradually increasing the time between retries, which is more efficient than immediate redelivery.\nDead Lettering: Configuring dead lettering to a different topic ensures that messages that cannot be processed after the maximum number of retries (10 in this case) are stored separately. This allows you to handle these messages later without losing any data.\nReliability: This configuration ensures that your messaging system is reliable and can handle temporary downtime of the consumer app while maintaining data integrity","timestamp":"1736168520.0","poster":"Pime13"},{"poster":"JyoGCP","upvote_count":"1","comment_id":"1155709","content":"Selected Answer: D\nOption D","timestamp":"1724251380.0"},{"timestamp":"1720884300.0","upvote_count":"1","comment_id":"1121905","poster":"Matt_108","content":"Selected Answer: D\nOption D - agree with other comments explanation"},{"poster":"GCP001","timestamp":"1720360740.0","content":"D. Use exponential backoff as the subscription retry policy, and configure dead lettering to a different topic with maximum delivery attempts set to 10\n\nBest suitable options for graceful retry and storing failed messages","comment_id":"1115989","upvote_count":"3"},{"upvote_count":"2","poster":"scaenruy","timestamp":"1720080900.0","content":"Selected Answer: D\nD. Use exponential backoff as the subscription retry policy, and configure dead lettering to a different topic with maximum delivery attempts set to 10.","comments":[{"upvote_count":"2","timestamp":"1720363920.0","comment_id":"1116023","poster":"Smakyel79","content":"Exponential backoff will help in managing the load on the consumer app by gradually increasing the delay between retries. Configuring dead lettering to a different topic after a maximum of 10 delivery attempts ensures that undeliverable messages are stored separately, preventing them from being retried endlessly and cluttering the main message flow."}],"comment_id":"1113524"}],"answer_description":"","answer":"D","timestamp":"2024-01-04 11:15:00","choices":{"D":"Use exponential backoff as the subscription retry policy, and configure dead lettering to a different topic with maximum delivery attempts set to 10.","B":"Use immediate redelivery as the subscription retry policy, and configure dead lettering to a different topic with maximum delivery attempts set to 10.","C":"Use exponential backoff as the subscription retry policy, and configure dead lettering to the same source topic with maximum delivery attempts set to 10.","A":"Increase the acknowledgement deadline to 10 minutes."},"answer_images":[],"isMC":true,"exam_id":11,"url":"https://www.examtopics.com/discussions/google/view/130293-exam-professional-data-engineer-topic-1-question-290/","question_images":[],"unix_timestamp":1704363300,"question_id":213,"topic":"1","answer_ET":"D","question_text":"You are designing a messaging system by using Pub/Sub to process clickstream data with an event-driven consumer app that relies on a push subscription. You need to configure the messaging system that is reliable enough to handle temporary downtime of the consumer app. You also need the messaging system to store the input messages that cannot be consumed by the subscriber. The system needs to retry failed messages gradually, avoiding overloading the consumer app, and store the failed messages after a maximum of 10 retries in a topic. How should you configure the Pub/Sub subscription?","answers_community":["D (100%)"]},{"id":"IMkxzOfr6SQIztYqREtz","url":"https://www.examtopics.com/discussions/google/view/130296-exam-professional-data-engineer-topic-1-question-291/","question_images":[],"exam_id":11,"answer":"A","answer_ET":"A","answers_community":["A (100%)"],"unix_timestamp":1704363720,"isMC":true,"question_id":214,"discussion":[{"poster":"raaad","content":"Selected Answer: A\nAnalytics Hub offers a centralized platform for managing data sharing and access within the organization. This simplifies access control management.","timestamp":"1704845880.0","comments":[{"timestamp":"1732830720.0","comment_id":"1319469","comments":[{"content":"I assume \"low-maintenance\" is the main problem on B","comment_id":"1345497","upvote_count":"2","timestamp":"1737647460.0","poster":"Ryannn23"}],"poster":"cloud_rider","content":"What is wrong with the option B?","upvote_count":"1"}],"upvote_count":"7","comment_id":"1117960"},{"timestamp":"1721581560.0","comment_id":"1252614","content":"Selected Answer: A\nA. is the answer I select","poster":"987af6b","upvote_count":"1"},{"timestamp":"1708533840.0","comment_id":"1155710","poster":"JyoGCP","upvote_count":"1","content":"Selected Answer: A\nAnalytics Hub"},{"content":"Selected Answer: A\nDefinitely A","upvote_count":"1","comment_id":"1121906","poster":"Matt_108","timestamp":"1705166760.0"},{"timestamp":"1704363720.0","upvote_count":"1","poster":"scaenruy","content":"Selected Answer: A\nA. Create an Analytics Hub private exchange, and publish the sales dataset.","comment_id":"1113535"}],"choices":{"A":"Create an Analytics Hub private exchange, and publish the sales dataset.","B":"Enable the other business units’ projects to access the authorized views of the sales dataset.","C":"Create and share views with the users in the other business units.","D":"Use the BigQuery Data Transfer Service to create a schedule that copies the sales dataset to the other business units’ projects."},"question_text":"You designed a data warehouse in BigQuery to analyze sales data. You want a self-serving, low-maintenance, and cost- effective solution to share the sales dataset to other business units in your organization. What should you do?","answer_description":"","timestamp":"2024-01-04 11:22:00","answer_images":[],"topic":"1"},{"id":"3K10ifBqkHKaZMzhxwFX","answer_images":[],"url":"https://www.examtopics.com/discussions/google/view/130298-exam-professional-data-engineer-topic-1-question-292/","answer_ET":"C","question_id":215,"question_text":"You have terabytes of customer behavioral data streaming from Google Analytics into BigQuery daily. Your customers’ information, such as their preferences, is hosted on a Cloud SQL for MySQL database. Your CRM database is hosted on a Cloud SQL for PostgreSQL instance. The marketing team wants to use your customers’ information from the two databases and the customer behavioral data to create marketing campaigns for yearly active customers. You need to ensure that the marketing team can run the campaigns over 100 times a day on typical days and up to 300 during sales. At the same time, you want to keep the load on the Cloud SQL databases to a minimum. What should you do?","isMC":true,"choices":{"C":"Create streams in Datastream to replicate the required tables from both Cloud SQL databases to BigQuery for these queries.","A":"Create BigQuery connections to both Cloud SQL databases. Use BigQuery federated queries on the two databases and the Google Analytics data on BigQuery to run these queries.","B":"Create a job on Apache Spark with Dataproc Serverless to query both Cloud SQL databases and the Google Analytics data on BigQuery for these queries.","D":"Create a Dataproc cluster with Trino to establish connections to both Cloud SQL databases and BigQuery, to execute the queries."},"discussion":[{"timestamp":"1704974520.0","content":"Selected Answer: C\n- Datastream: It's a fully managed, serverless service for real-time data replication. It allows to stream data from various sources, including Cloud SQL, into BigQuery.\n- Reduced Load on Cloud SQL: By replicating the required tables from both Cloud SQL databases into BigQuery, you minimize the load on the Cloud SQL instances. The marketing team's queries will be run against BigQuery, which is designed to handle high-volume analytics workloads.\n- Frequency of Queries: BigQuery can easily handle the high frequency of queries (100 times daily, up to 300 during sales events) due to its powerful data processing capabilities.\n- Combining Data Sources: Once the data is in BigQuery, you can efficiently combine it with the Google Analytics data for comprehensive analysis and campaign planning.","comment_id":"1119679","poster":"raaad","upvote_count":"11","comments":[{"comment_id":"1178437","content":"Why not A ? Federrated queries will downgrade Cloud SQL perf?","poster":"SanjeevRoy91","upvote_count":"1","timestamp":"1710948060.0"}]},{"comment_id":"1382931","content":"Selected Answer: C\nTo Replication data, use datastream","upvote_count":"1","poster":"Blackstile","timestamp":"1741619640.0"},{"poster":"987af6b","comment_id":"1252616","content":"Selected Answer: C\nInitially I said A, but this question was how I learned about Datastream, which I think would be the better solution in this scenario. So my answer is C","upvote_count":"3","timestamp":"1721581860.0"},{"timestamp":"1717597980.0","poster":"AlizCert","comment_id":"1224774","content":"Selected Answer: C\nC, noting that federated queries on read replicas would be the ideal solution","upvote_count":"1"},{"upvote_count":"1","timestamp":"1712818980.0","content":"Its option C.\n\n\"Performance. A federated query is likely to not be as fast as querying only BigQuery storage. BigQuery needs to wait for the source database to execute the external query and temporarily move data from the external data source to BigQuery. Also, the source database might not be optimized for complex analytical queries.\"\n\nSo, it will load the Cloud SQL external sources with the queries, impacting performance on those.\n\nLink: https://cloud.google.com/bigquery/docs/federated-queries-intro","comment_id":"1193510","poster":"joao_01"},{"comment_id":"1170867","content":"Selected Answer: C\nC is make sense","timestamp":"1710142680.0","poster":"datasmg","upvote_count":"1"},{"content":"Selected Answer: C\nOption C","upvote_count":"1","poster":"JyoGCP","timestamp":"1708534260.0","comment_id":"1155713"},{"comment_id":"1113544","comments":[{"upvote_count":"3","poster":"Smakyel79","timestamp":"1704646620.0","content":"Datastream is a serverless, easy-to-use change data capture (CDC) and replication service. By replicating the necessary tables from the Cloud SQL databases to BigQuery, you can offload the query load from the Cloud SQL databases. The marketing team can then run their queries directly on BigQuery, which is designed for large-scale data analytics. This approach seems to balance both efficiency and performance, minimizing load on the Cloud SQL instances.","comment_id":"1116026"}],"poster":"scaenruy","upvote_count":"3","timestamp":"1704364380.0","content":"Selected Answer: C\nC. Create streams in Datastream to replicate the required tables from both Cloud SQL databases to BigQuery for these queries."}],"answers_community":["C (100%)"],"unix_timestamp":1704364380,"exam_id":11,"topic":"1","question_images":[],"answer":"C","answer_description":"","timestamp":"2024-01-04 11:33:00"}],"exam":{"name":"Professional Data Engineer","lastUpdated":"11 Apr 2025","isMCOnly":true,"provider":"Google","isBeta":false,"id":11,"numberOfQuestions":319,"isImplemented":true},"currentPage":43},"__N_SSP":true}