{"pageProps":{"questions":[{"id":"dIGdXjZHmq4Af4lNwP3m","answers_community":["A (92%)","8%"],"topic":"1","question_text":"You have been tasked with planning the migration of your company's application from on-premises to Google Cloud. Your company's monolithic application is an ecommerce website. The application will be migrated to microservices deployed on Google Cloud in stages. The majority of your company's revenue is generated through online sales, so it is important to minimize risk during the migration. You need to prioritize features and select the first functionality to migrate. What should you do?","timestamp":"2022-01-09 16:24:00","discussion":[{"timestamp":"1645921920.0","comment_id":"557085","poster":"GCPCloudArchitectUser","upvote_count":"5","content":"Selected Answer: A\nI agree with Option A, as the question states “first one”"},{"comments":[{"content":"Why other options are less ideal:\n\nB. Payment Processing: Migrating payment processing first carries a high risk of disrupting revenue generation. It involves multiple integrations and dependencies, making it more complex and prone to errors.\nC. Order Fulfillment: Similar to payment processing, order fulfillment is a critical revenue-generating process. Migrating it first would introduce significant risk and potential disruption to customer orders.\nD. Shopping Cart: The shopping cart is a complex feature with multiple integrations, including payment processing and inventory. Migrating it first would be challenging and risky, potentially impacting customer checkout experiences.","comment_id":"1252844","poster":"thewalker","upvote_count":"1","timestamp":"1721627160.0"}],"poster":"thewalker","comment_id":"1252843","timestamp":"1721627160.0","upvote_count":"1","content":"Selected Answer: A\nMinimal Risk: Migrating the product catalog first minimizes risk because it's a foundational component of your ecommerce website. It doesn't directly impact the core revenue-generating processes like payment or order fulfillment.\nIndependent Functionality: The product catalog is relatively independent, with integrations primarily to the frontend and product database. This makes it easier to isolate and migrate without disrupting other critical parts of the application.\nEarly Validation: Migrating the product catalog allows you to validate your migration process, test your infrastructure, and gain experience with Google Cloud before moving on to more complex functionalities.\nFoundation for Future Migrations: A successful product catalog migration sets the stage for future migrations of more complex features. It provides a solid foundation for building out your microservices architecture on Google Cloud."},{"comment_id":"1013119","timestamp":"1695303360.0","upvote_count":"1","content":"Selected Answer: A\nI will go with A as it has less dependencies.","poster":"__rajan__"},{"content":"Selected Answer: A\nA should be the first MVP item in the list.\nKey is to avoid risks in the initial stages of transition.","timestamp":"1691236920.0","comment_id":"972981","upvote_count":"1","poster":"purushi"},{"upvote_count":"1","poster":"omermahgoub","comments":[{"content":"Migrating the product catalog first may be a good option if the product catalog is a separate service that doesn't rely on other services and can be deployed independently. However, if it is closely tied to other services such as the frontend or product database, migrating it first may introduce complexity and increase the risk of the migration, as the other dependent services would need to be migrated or integrated with the new product catalog service in parallel.","poster":"omermahgoub","comment_id":"772186","upvote_count":"2","timestamp":"1673422740.0"}],"timestamp":"1673422740.0","content":"Selected Answer: D\nhttps://cloud.google.com/architecture/migrating-a-monolithic-app-to-microservices-gke#example_migrating_a_shopping_cart\n\nBased on the guide referenced, the answer would be D. Migrate the Shopping cart, which has integrations to the frontend, cart database, inventory system, and payment processing system. The guide recommends migrating functionality with the least dependencies and level of complexity first, which the shopping cart functionality has fewer dependencies and less complexity than the other options presented. This will minimize risk while still providing value to the business and allowing further migration of more complex functionality.","comment_id":"772185"},{"timestamp":"1671460020.0","poster":"zellck","content":"Selected Answer: A\nA is the answer.\n\nhttps://cloud.google.com/architecture/migrating-a-monolithic-app-to-microservices-gke#choosing_an_initial_migration_effort","comment_id":"749914","upvote_count":"1"},{"poster":"TNT87","content":"https://cloud.google.com/architecture/migrating-a-monolithic-app-to-microservices-gke#example_migrating_a_shopping_cart\nAnswer A","upvote_count":"2","timestamp":"1669033500.0","comment_id":"723465"},{"upvote_count":"2","poster":"[Removed]","content":"I don't agree with option A. Google docs says:\n\n\"When you plan your migration, it's tempting to start with features that are trivial to migrate. This might represent a quick win, but might not be the best learning experience for your team. Instead of going straight to the migration, you should spend time evaluating all of the features and create plans for their migration.\"\n\n\"According to this evaluation framework, the ideal candidate for the initial migration effort should be challenging enough to be meaningful, but simple enough to minimize the risk of failure. The initial migration process should also:\n\nRequire little refactoring, considering both the feature itself and the related business processes.\nBe stateless—that is, have no external data requirements.\nHave few or no dependencies.\"\n\nI think it's between options B & C since the third-party vendors already have a microservices architecture going on.\n\nhttps://cloud.google.com/architecture/migrating-a-monolithic-app-to-microservices-gke#:~:text=When%20you%20plan,for%20their%20migration.","comments":[{"poster":"ajipeggy","content":"as it says in your link:\nA migration plan example\n\nThe following list shows an example of a migration order:\n\nPlatform frontend; that is, the user interface\nStateless features, such as a currency-conversion service\nFeatures with independent datasets (datasets that have no dependencies on other datasets), such as a service to list your brick-and-mortar stores\nFeatures with shared datasets—the business logic of the ecommerce platform\n\n\nso the first one should be the user interface = product catalogue","upvote_count":"3","comment_id":"712269","timestamp":"1667735880.0"}],"comment_id":"675785","timestamp":"1663828020.0"},{"content":"Selected Answer: A\nA is correct","poster":"tomato123","upvote_count":"2","comment_id":"649293","timestamp":"1660975980.0"},{"content":"A is correct.","poster":"szl0144","timestamp":"1652833980.0","upvote_count":"1","comment_id":"603094"},{"comment_id":"581296","timestamp":"1649166660.0","content":"I will vote C. It is the only service where a temporary disruption will not impact all sales on the website (because it is not embedded in the frontend).","poster":"BackendBoi","upvote_count":"3"},{"timestamp":"1642336800.0","comment_id":"524941","poster":"Blueocean","content":"Agree Option A , in order to keep the disruption as minimum as possible by migrating minimum features","upvote_count":"2"},{"poster":"scaenruy","content":"Yes, I vote A","timestamp":"1641741840.0","comment_id":"520291","upvote_count":"3"}],"question_id":26,"answer":"A","choices":{"D":"Migrate the Shopping cart, which has integrations to the frontend, cart database, inventory system, and payment processing system.","A":"Migrate the Product catalog, which has integrations to the frontend and product database.","B":"Migrate Payment processing, which has integrations to the frontend, order database, and third-party payment vendor.","C":"Migrate Order fulfillment, which has integrations to the order database, inventory system, and third-party shipping vendor."},"unix_timestamp":1641741840,"isMC":true,"answer_images":[],"url":"https://www.examtopics.com/discussions/google/view/69758-exam-professional-cloud-developer-topic-1-question-121/","answer_ET":"A","exam_id":7,"question_images":[],"answer_description":""},{"id":"WcI6wbsDbtB76pxc44YH","unix_timestamp":1641742860,"topic":"1","isMC":true,"exam_id":7,"question_text":"Your team develops services that run on Google Kubernetes Engine. Your team's code is stored in Cloud Source Repositories. You need to quickly identify bugs in the code before it is deployed to production. You want to invest in automation to improve developer feedback and make the process as efficient as possible.\nWhat should you do?","timestamp":"2022-01-09 16:41:00","discussion":[{"content":"Selected Answer: B\nB is correct.","timestamp":"1726926000.0","poster":"__rajan__","comment_id":"1013123","upvote_count":"1"},{"comment_id":"972987","content":"Selected Answer: B\nWe need to have the following steps in Cloud Build to identify bugs\"\n1) Static code analysis\n2) Code Vulnerability scanning\n3) Docker Image vulnerability scanning\nUsing Grype is one such example.","poster":"purushi","timestamp":"1722859680.0","upvote_count":"1"},{"content":"Selected Answer: D\nI say D.\n\nBoth B and D could work. However why not use traditional git workflows and keep separate branches for separate tasks. This way each image can be tested independently.","poster":"eddoasso","comment_id":"941803","upvote_count":"1","timestamp":"1720008000.0"},{"poster":"omermahgoub","comments":[{"timestamp":"1704958860.0","upvote_count":"1","content":"Option C also uses Spinnaker, and is similar to A, Spinnaker can automate deploying container images to the production environment, but it's not specific to building and identifying bugs before deploying, so it might not be the best fit for this use case.\n\nOption D uses Cloud Build, but it's not specific to building images based on git tags, it's more general and focuses on building images based on forked versions, which might not be needed in this case.","comment_id":"772189","poster":"omermahgoub"}],"comment_id":"772188","timestamp":"1704958860.0","upvote_count":"1","content":"Selected Answer: B\nOption B is appropriate because it uses Cloud Build, a service that can automatically build container images from code stored in Cloud Source Repositories based on Git tags. This allows developers to quickly identify bugs in their code before it is deployed to production, by automating the building process and improving developer feedback.\n\nOption A uses Spinnaker, which is a multi-cloud continuous delivery platform that can automate building, testing, and deploying container images. However, it does not specifically mention using git tags to trigger builds, thus for this particular use case it might not be the best fit."},{"content":"Selected Answer: B\nB is the answer.","comment_id":"749910","timestamp":"1702995780.0","upvote_count":"1","poster":"zellck"},{"content":"D ) You need to quickly identify bugs in the code before it is deployed to production. So it's for developer to fork the code and test the build. Later they can push the changes using PR to the master repo/branch.","comment_id":"717923","timestamp":"1699963320.0","upvote_count":"2","poster":"GCP001"},{"comment_id":"668838","upvote_count":"2","poster":"[Removed]","content":"Selected Answer: B\ncloud build is the google service so it stands to reason to use that.","timestamp":"1694684100.0"},{"poster":"tomato123","content":"Selected Answer: B\nI think b is correct","timestamp":"1692511980.0","upvote_count":"3","comment_id":"649294"},{"timestamp":"1680715200.0","upvote_count":"1","comment_id":"581375","poster":"hitmax87","content":"Selected Answer: D\nI vote D. Because every developer before merge to the master should test build in his branch. It will expose bugs. Once branch merged to the master, master build pipeline comes up."},{"content":"Selected Answer: B\nI would disagree with A as Spinnaker is for deployment not for building images \n\nSo either B or C : C is stating to deploy to production but the question is to give feedback to developer before it goes to production \n\nSo the only close answer is B but it is half answer \n\nPerhaps choice A was poorly written instead deploy build then it could be A","comment_id":"557102","upvote_count":"4","comments":[{"upvote_count":"1","comment_id":"557103","poster":"GCPCloudArchitectUser","timestamp":"1677464940.0","content":"I mean instead of deploy it was typed incorrect as build for A"}],"timestamp":"1677464880.0","poster":"GCPCloudArchitectUser"},{"upvote_count":"3","timestamp":"1673278860.0","content":"I vote B","poster":"scaenruy","comment_id":"520296"}],"question_id":27,"question_images":[],"choices":{"D":"Use Cloud Build to automate building container images from code based on forked versions.","C":"Use Spinnaker to automate deploying container images to the production environment.","A":"Use Spinnaker to automate building container images from code based on Git tags.","B":"Use Cloud Build to automate building container images from code based on Git tags."},"url":"https://www.examtopics.com/discussions/google/view/69760-exam-professional-cloud-developer-topic-1-question-122/","answer_images":[],"answer_description":"","answers_community":["B (87%)","13%"],"answer":"B","answer_ET":"B"},{"id":"IOZvpqIaUwZULinDsLe9","unix_timestamp":1641742800,"isMC":true,"exam_id":7,"timestamp":"2022-01-09 16:40:00","discussion":[{"content":"Selected Answer: A\nA is correct.","poster":"__rajan__","comment_id":"1013132","timestamp":"1726926120.0","upvote_count":"1"},{"upvote_count":"1","poster":"purushi","comment_id":"972992","content":"Selected Answer: A\nGranting IAM at resource level is enough.\nIf project level permission is given then user will be having publisher and subscriber roles for all the pub-sub topics created within the project. So this should be avoided according to the question asked.","timestamp":"1722859920.0"},{"upvote_count":"1","timestamp":"1709040600.0","comment_id":"823730","poster":"Pime13","content":"Selected Answer: A\nA -> resource level"},{"comment_id":"772191","content":"Selected Answer: A\nA. Bind the user identity to the pubsub.publisher and pubsub.subscriber roles at the resource level.\n\nBy binding the user identity to the pubsub.publisher and pubsub.subscriber roles at the resource level, you can ensure that each user can only publish and subscribe to their specific Pub/Sub topic and subscription. This allows for granular permissions management and ensures that each user can only access the resources they are authorized to.\n\nThe other options are not suitable in this case because,","upvote_count":"2","comments":[{"timestamp":"1704958980.0","comments":[{"timestamp":"1706946780.0","comments":[{"poster":"TNT87","timestamp":"1706946840.0","comment_id":"796851","upvote_count":"1","content":"believe"}],"comment_id":"796850","content":"why do you write all these compositions , you write unneccesary paragraphs always, as if we dnto have documents and often times you will be giving wrong explanations. i beleve just pasting a link to supoort your answer is enough as well have access to the documentation","upvote_count":"2","poster":"TNT87"}],"poster":"omermahgoub","comment_id":"772192","content":"B. Granting the user identity the pubsub.publisher and pubsub.subscriber roles at the project level would give the user access to all topics and subscriptions within the project and not specific to a user.\n\nC. Granting the user identity a custom role that contains the pubsub.topics.create and pubsub.subscriptions.create permissions would allow user to create topics and subscriptions but not access to their specific topic or subscription.\n\nD. Configuring the application to run as a service account that has the pubsub.publisher and pubsub.subscriber roles would not provide granular permissions management for the user.","upvote_count":"2"}],"timestamp":"1704958980.0","poster":"omermahgoub"},{"upvote_count":"1","poster":"zellck","timestamp":"1702995540.0","content":"Selected Answer: A\nA is the answer.","comment_id":"749907"},{"poster":"tomato123","comment_id":"649295","upvote_count":"2","timestamp":"1692512040.0","content":"Selected Answer: A\nA is correct"},{"upvote_count":"2","timestamp":"1691305740.0","poster":"akshaychavan7","comment_id":"643230","content":"Selected Answer: A\nI think it should be option A since the authorization should be at the user level for a specific resource."},{"upvote_count":"2","timestamp":"1682662560.0","poster":"nqthien041292","content":"Selected Answer: A\nVote A","comment_id":"593579"},{"content":"I would choose D","poster":"hitmax87","comment_id":"581377","upvote_count":"2","timestamp":"1680715380.0"},{"content":"I vote A","poster":"scaenruy","comments":[{"timestamp":"1674360300.0","content":"Agree with Option A","poster":"Blueocean","upvote_count":"4","comment_id":"529587"}],"upvote_count":"3","timestamp":"1673278800.0","comment_id":"520295"}],"url":"https://www.examtopics.com/discussions/google/view/69759-exam-professional-cloud-developer-topic-1-question-123/","answer":"A","question_images":["https://www.examtopics.com/assets/media/exam-media/04137/0008100001.jpg"],"choices":{"C":"Grant the user identity a custom role that contains the pubsub.topics.create and pubsub.subscriptions.create permissions.","A":"Bind the user identity to the pubsub.publisher and pubsub.subscriber roles at the resource level.","B":"Grant the user identity the pubsub.publisher and pubsub.subscriber roles at the project level.","D":"Configure the application to run as a service account that has the pubsub.publisher and pubsub.subscriber roles."},"answers_community":["A (100%)"],"answer_description":"","topic":"1","question_text":"Your team is developing an application in Google Cloud that executes with user identities maintained by Cloud Identity. Each of your application's users will have an associated Pub/Sub topic to which messages are published, and a Pub/Sub subscription where the same user will retrieve published messages. You need to ensure that only authorized users can publish and subscribe to their own specific Pub/Sub topic and subscription. What should you do?\n//IMG//","question_id":28,"answer_ET":"A","answer_images":[]},{"id":"cqi0IYZerpknhhounyAL","unix_timestamp":1642304640,"isMC":true,"answers_community":["A (100%)"],"topic":"1","answer":"A","url":"https://www.examtopics.com/discussions/google/view/70094-exam-professional-cloud-developer-topic-1-question-124/","question_text":"You are evaluating developer tools to help drive Google Kubernetes Engine adoption and integration with your development environment, which includes VS Code and IntelliJ. What should you do?","exam_id":7,"question_id":29,"answer_ET":"A","question_images":[],"choices":{"B":"Use the Cloud Shell integrated Code Editor to edit code and configuration files.","D":"Use Cloud Shell to manage your infrastructure and applications from the command line.","C":"Use a Cloud Notebook instance to ingest and process data and deploy models.","A":"Use Cloud Code to develop applications."},"answer_images":[],"discussion":[{"timestamp":"1721628540.0","upvote_count":"1","content":"Selected Answer: A\nDirect Integration with IDEs: Cloud Code is specifically designed to integrate with popular IDEs like VS Code and IntelliJ. This provides a seamless development experience within your familiar environment.\nKubernetes-Focused Features: Cloud Code offers features tailored for Kubernetes development, including:\nBuild and Deployment: Automate container image building, deployment to GKE, and integration with CI/CD tools like Cloud Build.\nDebugging and Monitoring: Debug applications running on Kubernetes clusters directly from your IDE, and monitor their performance and logs.\nYAML Editing: Provides assistance for editing Kubernetes YAML files, including validation, linting, and auto-completion.\nStreamlined Workflow: Cloud Code helps streamline your workflow by bringing all the necessary tools and services for Kubernetes development into your IDE, reducing context switching and improving productivity.","comment_id":"1252855","poster":"thewalker","comments":[{"upvote_count":"1","poster":"thewalker","timestamp":"1721628600.0","content":"Why other options are less ideal:\n\nB. Cloud Shell Integrated Code Editor: While Cloud Shell is a useful tool for managing infrastructure and running commands, its integrated code editor is not as feature-rich or integrated with Kubernetes development as Cloud Code.\nC. Cloud Notebook Instance: Cloud Notebooks are excellent for data science and machine learning tasks, but they are not the primary tool for developing and deploying applications on Kubernetes.\nD. Cloud Shell for Command Line Management: Cloud Shell is great for managing infrastructure and running commands, but it doesn't provide the same level of IDE integration and Kubernetes-specific features as Cloud Code.","comment_id":"1252856"}]},{"upvote_count":"1","content":"Selected Answer: A\nA is correct.","comment_id":"1013134","timestamp":"1695303900.0","poster":"__rajan__"},{"comment_id":"973004","content":"Selected Answer: A\nGoogle Cloud code plugin can be installed on Intellij and VS code IDEs.\nThis provides very flexibility for developer to work with GKE platform.","upvote_count":"2","poster":"purushi","timestamp":"1691238420.0"},{"poster":"Oleksii_ki","timestamp":"1688476680.0","comment_id":"942796","content":"Selected Answer: A\nCloud Code is a set of plugins for VS Code and IntelliJ that provides an integrated development experience for working with Kubernetes and Google Cloud","upvote_count":"1"},{"content":"Selected Answer: A\nA. Use Cloud Code to develop applications.\n\nCloud Code is a set of plugins for VS Code and IntelliJ that provides an integrated development experience for working with Kubernetes and Google Cloud. The plugins include features such as interactive cluster and resource management, one-click Kubernetes cluster creation, and built-in debugging and diagnostics. It also supports to quickly deploy and debug applications using the Kubernetes and Google Cloud SDKs, Also, it allows developers to easily perform tasks like deploying and debugging applications, managing resources, and running local development environments. Cloud Code is a great tool for teams looking to streamline their development process for Kubernetes and Google Cloud.","comments":[{"upvote_count":"1","content":"The Cloud Shell integrated Code Editor is a command-line text editor that you can use to edit code and configuration files within the Cloud Shell environment. While it can be useful for small changes or quick tests, it may not provide the same level of functionality or convenience as a dedicated development environment such as VS Code or IntelliJ. Additionally, Cloud Shell is primarily intended for managing infrastructure and applications from the command line, and may not offer the best workflow or experience for developing applications. For these reasons, it may be more beneficial to use a more robust development environment like VS Code or IntelliJ to develop and manage your applications on Google Kubernetes Engine.","poster":"omermahgoub","timestamp":"1673423100.0","comment_id":"772194"}],"upvote_count":"1","comment_id":"772193","poster":"omermahgoub","timestamp":"1673423100.0"},{"comment_id":"749905","poster":"zellck","timestamp":"1671459420.0","content":"Selected Answer: A\nA is the answer.\n\nhttps://cloud.google.com/code/docs\nCloud Code provides IDE support for the full development cycle of Kubernetes and Cloud Run applications, from creating and customizing a new application from sample templates to running your finished application. Cloud Code supports you along the way with run-ready samples, out-of-the-box configuration snippets, and a tailored debugging experience — making developing with Kubernetes and Cloud Run a whole lot easier!","upvote_count":"1"},{"upvote_count":"3","poster":"tomato123","comment_id":"649296","timestamp":"1660976040.0","content":"Selected Answer: A\nA is correct"},{"poster":"GCPCloudArchitectUser","content":"Selected Answer: A\nAgreed with Option A … referred link","upvote_count":"3","timestamp":"1645929300.0","comment_id":"557105"},{"timestamp":"1642304640.0","comment_id":"524601","upvote_count":"3","poster":"Blueocean","content":"Agree with Option A"}],"timestamp":"2022-01-16 04:44:00","answer_description":""},{"id":"MEyfnQ2RWKF0Nyu6d73U","choices":{"A":"Your Memorystore for Redis instance was deployed without a public IP address.","B":"You configured your Serverless VPC Access connector in a different region than your App Engine instance.","C":"The firewall rule allowing a connection between App Engine and Memorystore was removed during an infrastructure update by the DevOps team.","D":"You configured your application to use a Serverless VPC Access connector on a different subnet in a different availability zone than your App Engine instance."},"question_text":"You are developing an ecommerce web application that uses App Engine standard environment and Memorystore for Redis. When a user logs into the app, the application caches the user's information (e.g., session, name, address, preferences), which is stored for quick retrieval during checkout.\nWhile testing your application in a browser, you get a 502 Bad Gateway error. You have determined that the application is not connecting to Memorystore. What is the reason for this error?","answer":"B","url":"https://www.examtopics.com/discussions/google/view/69761-exam-professional-cloud-developer-topic-1-question-125/","timestamp":"2022-01-09 16:49:00","answer_ET":"B","answers_community":["B (68%)","C (18%)","14%"],"question_images":[],"discussion":[{"comment_id":"523344","content":"Selected Answer: B\nB is the correct answer in this case, A is wrong because according to the best practice and security purpose gcp doesn't allow public ip for redis server.","timestamp":"1642134600.0","poster":"ParagSanyashiv","upvote_count":"6"},{"timestamp":"1721629560.0","poster":"thewalker","comment_id":"1252861","comments":[{"upvote_count":"1","timestamp":"1721629560.0","comment_id":"1252862","content":"Let's analyze why the other options are less likely:\n\nA. Memorystore without a Public IP: While Memorystore instances can be deployed without a public IP, this wouldn't prevent your App Engine application from connecting. Serverless VPC Access allows communication through private IPs.\nC. Firewall Rule Removal: While a firewall rule could prevent access, it's less likely to be the primary cause. If the firewall rule was removed, you'd likely see a different error message, not a 502 Bad Gateway.\nD. Different Subnet and Availability Zone: While using a different subnet or availability zone within the same region might introduce latency, it wouldn't completely prevent connectivity. The primary issue is the region mismatch between the connector and App Engine.","poster":"thewalker"}],"upvote_count":"1","content":"Selected Answer: B\nThe most likely reason for the 502 Bad Gateway error and the inability to connect to Memorystore is B. You configured your Serverless VPC Access connector in a different region than your App Engine instance.\n\nHere's why:\n\nServerless VPC Access and Regions: App Engine standard environment applications can only communicate with services outside of their environment (like Memorystore) through Serverless VPC Access connectors. These connectors act as a bridge between your App Engine application and your VPC network, where Memorystore resides. Crucially, the connector and the App Engine instance must be in the same region ."},{"upvote_count":"1","poster":"alpha_canary","content":"Selected Answer: B\nB: If you configured your Serverless VPC Access connector in a different region than your App Engine instance, this could cause connectivity issues. Serverless VPC Access connectors and the resources they connect to must be in the same region.","comment_id":"1196973","timestamp":"1713326820.0"},{"content":"C. The firewall rule allowing a connection between App Engine and Memorystore was removed during an infrastructure update by the DevOps team.\n\nHere's why this scenario aligns with the error:\n\n502 Bad Gateway: This error typically indicates that a server (in this case, App Engine) is unable to communicate with an upstream server (Memorystore for Redis) due to a configuration issue.\nFirewall Rule Removal: If a firewall rule previously allowed App Engine to connect to Memorystore, removing it would block communication and cause the connection failure.","comment_id":"1179917","timestamp":"1711091700.0","poster":"theshant","upvote_count":"1"},{"timestamp":"1695498600.0","content":"Selected Answer: B\nhttps://cloud.google.com/vpc/docs/configure-serverless-vpc-access\nIn the Region field, select a region for your connector. This must match the region of your serverless service.\nIf your service or job is in the region us-central or europe-west, use us-central1 or europe-west1.","upvote_count":"1","comment_id":"1015297","poster":"kldn"},{"comment_id":"1013137","poster":"__rajan__","content":"Selected Answer: C\n1\n\n1\nThe most likely reason for the 502 Bad Gateway error is that the firewall rule allowing a connection between App Engine and Memorystore was removed during an infrastructure update by the DevOps team.\n\nThis is because App Engine needs to be able to connect to Memorystore in order to retrieve the cached user information. If the firewall rule is removed, App Engine will not be able to connect to Memorystore and the application will fail.","upvote_count":"2","timestamp":"1695304140.0"},{"comment_id":"973018","poster":"purushi","upvote_count":"1","content":"Selected Answer: D\n502 Bad gateway issue is common more in App Engine Flexible environments than Std due to memory issues. Here I go with option D since pointing connector to a different subnet than App engine instance could cause Bad Gateway issue. A is not correct, because even with the different region with the same subnet, App engine instance do not get issues while connecting to Memeorystore.","timestamp":"1691239200.0"},{"content":"Selected Answer: C\nC.\nA: No. The public IP is not mandatory.\nB: No. App Engine instance region can be different with Serverless VPC Access connector. \nLink here: https://support.google.com/a/answer/10620692?hl=en . \n\"We support VPC access connectors in 6 regions (us-central, us-west1, us-east1, asia-southeast1, asia-east1, and europe-west1). .... Note: Support for additional regions is coming soon.\" Although the document didn't mention directly, what if an app in App Engine in southamerica-east1-a would like to connect to Cloud SQL in us region? Note that the diagram here is REALLY mis-leading:\nhttps://cloud.google.com/vpc/docs/serverless-vpc-access#example_2\nC: Yes. This is the only possible answer.\nD: No. Serverless VPC Access connector shall be configured with a different subnet. See:\nhttps://cloud.google.com/vpc/docs/configure-serverless-vpc-access#console\n\"Every connector requires its own /28 subnet to place connector instances on. A subnet cannot be used by other resources such as VMs, Private Service Connect, or load balancers.\"","poster":"zanhsieh","upvote_count":"2","comment_id":"926317","timestamp":"1687042440.0"},{"timestamp":"1673615280.0","poster":"telp","upvote_count":"2","content":"Selected Answer: B\nA is not correct because Cloud Run connects to Memorystore via the Serverless VPC Connector. Connections are over private networks. Public addresses are not required.\nB is correct. All of the components must be in the same region.\nC is not correct because for connectivity between Cloud Run and Memorystore all that is required is a Serverless VPN Connector.\nD is not correct. The Serverless VPC Connector is configured with a non-overlapping subnet that is not associated with the VPC.","comment_id":"774510"},{"upvote_count":"2","timestamp":"1673424300.0","poster":"omermahgoub","comment_id":"772209","content":"Selected Answer: D\nWhile both B and D refer to the configuration of the Serverless VPC Access connector and could potentially cause issues with the application's ability to connect to Memorystore, they are slightly different.\n\nFor B:\nHaving the connector in a different region than the App Engine instance could result in increased latency and potential connectivity issues, but it would not necessarily prevent the App Engine instance from connecting to Memorystore.\n\nFor D:\nThis option is more specific and is indicating that if the connector is on different subnet or availability zone from App Engine instance it could cause issues with the application's ability to connect to Memorystore, it is less likely for this situation to cause latency or performance issues, but it will affect the connectivity of the App Engine to Memorystore.\n\nBoth B and D refer to misconfiguration of the Serverless VPC Access connector, but option D is more specific and directly relates to connectivity issue and is more likely to be the root cause of the 502 Bad Gateway error encountered."},{"content":"Selected Answer: B\nB is the answer.\n\nhttps://cloud.google.com/vpc/docs/serverless-vpc-access#how_it_works\nServerless VPC Access is based on a resource called a connector. A connector handles traffic between your serverless environment and your VPC network. When you create a connector in your Google Cloud project, you attach it to a specific VPC network and region. You can then configure your serverless services to use the connector for outbound network traffic.","upvote_count":"1","timestamp":"1671459300.0","comment_id":"749902","poster":"zellck"},{"timestamp":"1660976040.0","poster":"tomato123","comment_id":"649297","upvote_count":"2","content":"Selected Answer: B\nB is correct"},{"upvote_count":"1","timestamp":"1659770100.0","poster":"akshaychavan7","content":"Selected Answer: B\nYes! This should be B","comment_id":"643231"},{"comment_id":"520304","content":"I vote B\nhttps://cloud.google.com/vpc/docs/configure-serverless-vpc-access","upvote_count":"4","timestamp":"1641743340.0","poster":"scaenruy"}],"exam_id":7,"answer_description":"","answer_images":[],"topic":"1","unix_timestamp":1641743340,"question_id":30,"isMC":true}],"exam":{"lastUpdated":"11 Apr 2025","isImplemented":true,"numberOfQuestions":338,"isMCOnly":false,"isBeta":false,"name":"Professional Cloud Developer","id":7,"provider":"Google"},"currentPage":6},"__N_SSP":true}