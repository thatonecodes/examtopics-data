{"pageProps":{"questions":[{"id":"w5UH8VSRdhencQP85KR8","question_text":"A security architect is implementing a web application that uses a database back end. Prior to production, the architect is concerned about the possibility of XSS attacks and wants to identify security controls that could be put in place to prevent these attacks. Which of the following sources could the architect consult to address this security concern?","answer_images":[],"discussion":[{"comment_id":"843439","timestamp":"1710823800.0","poster":"Cock","content":"Selected Answer: D\nD. OWASP (Open Web Application Security Project) is a popular resource for web application security information and provides a detailed list of the most common web application vulnerabilities, including XSS. It also provides recommendations for security controls that can be implemented to prevent or mitigate these vulnerabilities. Therefore, the security architect could consult OWASP to obtain guidance on how to prevent XSS attacks.","upvote_count":"5"},{"timestamp":"1722210660.0","poster":"imather","upvote_count":"3","content":"Selected Answer: D\nRepeat of 62.","comment_id":"965928"},{"timestamp":"1710870300.0","upvote_count":"4","content":"D - OWASP","comment_id":"844061","poster":"unBREAKable_Fs4"}],"question_id":166,"question_images":[],"exam_id":343,"answer_ET":"D","answers_community":["D (100%)"],"url":"https://www.examtopics.com/discussions/comptia/view/103172-exam-cas-004-topic-1-question-248-discussion/","topic":"1","answer":"D","unix_timestamp":1679201400,"answer_description":"","choices":{"D":"OWASP","A":"SDLC","C":"IEEE","B":"OVAL"},"timestamp":"2023-03-19 05:50:00","isMC":true},{"id":"QlizbDyypEBi9RYInByG","answer_images":[],"choices":{"B":"Passive scanning","A":"Authenticated scanning","C":"Unauthenticated scanning","D":"Agent-based scanning"},"answer_ET":"D","discussion":[{"poster":"Cock","timestamp":"1679201520.0","content":"Selected Answer: C\nC. Unauthenticated scanning would be the BEST option for the customer's needs. Unauthenticated scanning is fast, signature-based, and has a low impact on servers when performing a scan. It also has the least false positives possible when compared to authenticated scanning, which requires credentials to be entered to perform deeper scans. Additionally, unauthenticated scanning can be used across subnets, VLANs, and branch offices since it doesn't require a connection to the network devices to perform the scan .","comment_id":"843442","upvote_count":"9"},{"poster":"Networknovice","upvote_count":"6","comment_id":"893457","timestamp":"1683669300.0","content":"Selected Answer: D\nAgent-based compared to Unauthenticated in regards to the requirements: the need for accuracy and minimizing false positives would outweigh the slightly higher impact on the server. P1s3c mentions that unauthenticated scanning may produce more false positives. If the question stated \"the lowest impact on servers\" then I would have gone with C. Although, in this case, it seems to prioritize the \"least false positives possible\". Agent-based has the least false positives"},{"content":"Selected Answer: B\nPassive Scanning is the best choice. Here's the breakdown of why Passive Scanning is the best choice for the given requirements:\nFast scanning: Passive scanning doesn't actively probe the systems. Instead, it listens to network traffic to detect vulnerabilities.\nLeast false positives: Passive scanning has a lower likelihood of generating false positives because it analyzes existing network traffic, which can be more accurate in detecting actual vulnerabilities compared to active scanning methods that may trigger security measures.\nSignature-based: Passive scanners often use signature-based detection to match patterns of known vulnerabilities and exploits within the network traffic.\nLow impact on servers: Since passive scanning doesn't initiate any scans or actively interact with the servers, it has minimal impact on server performance.\nScreened subnets, VLANs, and branch offices: Passive scanning can be ideal in complex network environments with multiple subnets and remote offices, as it doesn't require direct access to each network segment.","poster":"Bright07","comment_id":"1321128","upvote_count":"1","timestamp":"1733178960.0"},{"upvote_count":"1","comment_id":"1288466","poster":"claumagagnotti","timestamp":"1727164620.0","content":"Selected Answer: C\nPassive scanning is a technique where the system monitors network traffic and identifies vulnerabilities without actively probing or scanning the network. This method has low impact on servers, avoids false positives to a large extent (as it doesn’t rely on active probes that can sometimes misidentify issues), and is fast since it doesn’t require interacting with systems in a way that might slow them down. It also aligns well with environments that have screened subnets, VLANs, and branch offices, as passive scanners can listen to traffic from various network segments without direct interaction."},{"content":"Selected Answer: D\nFast scanning: Agent-based scanners can perform scans quickly because they are installed directly on the endpoints and can operate continuously in the background.\nLeast false positives: Agents have direct access to the systems they are monitoring, which can help reduce false positives compared to network-based scanning methods.\nSignature-based: Agent-based solutions often include signature-based detection capabilities to identify known vulnerabilities.\nLow impact on servers: Because agents operate locally, they typically have a lower impact on network bandwidth and can be configured to use minimal system resources during scans.","comments":[{"content":"Unauthenticated scanning: This type of scanning can be faster and have a lower impact on servers, but it tends to produce more false positives and misses vulnerabilities that authenticated or agent-based scans would detec","upvote_count":"2","poster":"23169fd","comment_id":"1248331","timestamp":"1721046360.0"}],"upvote_count":"1","comment_id":"1248329","poster":"23169fd","timestamp":"1721046300.0"},{"upvote_count":"4","timestamp":"1704652980.0","content":"Selected Answer: D\nUltimately, the choice between unauthenticated scanning, agent-based scanning, or other methods depends on the specific requirements, constraints, and priorities of the organization. If minimizing the impact on servers is a critical factor, agent-based scanning could be a suitable option.","comment_id":"1116096","poster":"abrub"},{"poster":"Anarckii","upvote_count":"3","comment_id":"1105574","timestamp":"1703544660.0","content":"Selected Answer: D\nGiven the specific requirements of fast scanning, the least false positives, signature-based, and low impact on servers, the more appropriate choice is:\n\nD. Agent-based scanning\n\nAgent-based solutions often provide accurate results with fewer false positives, as they have direct access to system information and can tailor scans based on the specifics of each system. \n\nSource:ChatGPT"},{"timestamp":"1696272360.0","upvote_count":"3","content":"Selected Answer: A\nTo meet the customer's requirements for fast scanning, minimal false positives, signature-based scanning, and low impact on servers, the best choice would be authenticated scanning.\n\nHere's why authenticated scanning aligns with the specified requirements:\n\n Fast Scanning: Authenticated scanning typically tends to be faster because it has access to the target systems and can collect detailed information more efficiently.\n\n Least False Positives: Authenticated scanning can provide accurate and detailed information about the target systems, reducing false positives compared to unauthenticated scans.\n\n Signature-Based: Authenticated scanning can use signatures and authenticated checks to identify vulnerabilities, making it signature-based.\n\n Low Impact on Servers: Since authenticated scans have access to the target systems, they can gather data in a less intrusive manner, resulting in a lower impact on servers compared to some unauthenticated scans.","comment_id":"1023390","poster":"Ariel235788"},{"poster":"Johnxyzzzz","content":"Selected Answer: D\nAgent-based scanning. \"Agent-based scanning is suitable for organizations with a geographically diverse workforce, particularly if the organization includes remote workers.\" Agent-based scanning runs on the device and doesn't connect back to a server. Agent-based scanning is on the device and requires credentials, so it is more accurate that unauthenticated scanning.\n\nSource: https://www.beyondsecurity.com/blog/agent-based-vs-agent-less-scanning","upvote_count":"3","timestamp":"1695492540.0","comment_id":"1015189"},{"comment_id":"1006915","content":"Selected Answer: C\nUnauthenticated Scanning: Unauthenticated scanning involves scanning a network or system without using specific credentials or authentication. It's typically faster because it doesn't require the scanner to log in or provide credentials, and it's signature-based, which means it uses known patterns or signatures to identify vulnerabilities. It's also less likely to generate false positives since it's scanning from an external perspective. This type of scanning is suitable for quickly assessing the security posture of servers and systems in diverse network environments, including screened subnets, VLANs, and branch offices.","upvote_count":"2","timestamp":"1694630220.0","poster":"CoinUmbrella"},{"upvote_count":"3","timestamp":"1692297240.0","poster":"Sam1289","content":"Selected Answer: D\nD. Agent-based scanning\nAgent-based scanning involves installing lightweight software agents on the target systems to be scanned. These agents collect data and perform scans locally, which reduces the impact on servers during scanning. They can also provide more accurate results since they interact directly with the local environment and applications.","comment_id":"983920"},{"content":"Selected Answer: C\nOption C: Unauthenticated scanning would be the BEST solution for the customer's needs. It is a fast, signature-based scanning technique that requires no credentials to perform a scan. Since it does not require any credentials, it is a low-impact scanning method on servers, which meets the requirement. However, unauthenticated scanning may produce more false positives than authenticated scanning. It is best suited for external vulnerability scanning and would be useful in identifying vulnerabilities in screened subnets, VLANs, and branch offices.","upvote_count":"2","poster":"p1s3c","comment_id":"892065","comments":[{"timestamp":"1683710940.0","comment_id":"893787","upvote_count":"5","content":"changed my option to D. \"least false positives\" guide here. although agent-based scanning would require software to be installed on each target system, which could be impractical for large environments without a central management solution. have this issue at my current job","poster":"p1s3c"}],"timestamp":"1683544680.0"},{"comment_id":"856548","poster":"Amin4799","upvote_count":"3","content":"Selected Answer: C\nUnauthenticated scanning is fast, has a lower impact on servers, and generates fewer false positives","timestamp":"1680229320.0"},{"comment_id":"844287","timestamp":"1679263500.0","content":"Selected Answer: D\nAgree with agent-based with less impacts on the server","poster":"Serliop378","upvote_count":"6"}],"exam_id":343,"url":"https://www.examtopics.com/discussions/comptia/view/103173-exam-cas-004-topic-1-question-249-discussion/","topic":"1","answer_description":"","timestamp":"2023-03-19 05:52:00","answer":"D","question_id":167,"question_text":"A security architect is working with a new customer to find a vulnerability assessment solution that meets the following requirements:\n\n• Fast scanning\n• The least false positives possible\n• Signature-based\n• A low impact on servers when performing a scan\n\nIn addition, the customer has several screened subnets, VLANs, and branch offices. Which of the following will BEST meet the customer's needs?","question_images":[],"answers_community":["D (55%)","C (36%)","6%"],"unix_timestamp":1679201520,"isMC":true},{"id":"C8juPQaR85fwEYX57hoc","exam_id":343,"topic":"1","isMC":true,"answer_description":"","unix_timestamp":1644648120,"answer_images":[],"question_id":168,"answer":"A","choices":{"A":"A vulnerability","B":"A threat","C":"A breach","D":"A risk"},"question_images":[],"question_text":"An IT administrator is reviewing all the servers in an organization and notices that a server is missing crucial practice against a recent exploit that could gain root access.\nWhich of the following describes the administrator's discovery?","answer_ET":"A","timestamp":"2022-02-12 07:42:00","answers_community":["A (100%)"],"discussion":[{"comment_id":"545685","upvote_count":"6","timestamp":"1644648120.0","content":"Selected Answer: A\nA is correct. This is a vulnerability.","poster":"zapato"},{"content":"Selected Answer: A\nVulnerability is something that COULD happen. Thus the keyword in this question. \nVulnerability = Exposed\nThreat = An event that leverages a Vulnerability\nBreach = Is after the event is successful\nRisk = While the vulnerability is a risk, Risk is an interpretation by the company itself of vulnerabilities that they feel are important. (you can never patch ALL vulnerabilities; otherwise, there would never be breaches.)\nSource:\nVerifying each answer against Chat GPT, my experience, other test banks, a written book, and weighing in the discussion from all users to create a 100% accurate guide for myself before I take the exam. (It isn't easy because of the time needed, but it is doing my diligence)","timestamp":"1689636660.0","upvote_count":"4","poster":"BiteSize","comment_id":"954703"},{"comment_id":"790793","timestamp":"1674922740.0","comments":[{"comment_id":"1241066","content":"A breach would indicate that someone was able to exploit the vulnerability. Since this question just states that there is a potential issue, no breach is implied. If it said \"... that someone used to gain root access.\" then it would be a breach.","upvote_count":"1","timestamp":"1719960960.0","poster":"SallySausage"}],"poster":"milkyzzz","content":"why not C?","upvote_count":"1"},{"poster":"ukuwai","upvote_count":"3","content":"Selected Answer: A\nvulnerability refers to a weakness in your system while the risk is related to the potential for lost, damaged, or destroyed assets","timestamp":"1662141180.0","comment_id":"657681"}],"url":"https://www.examtopics.com/discussions/comptia/view/71333-exam-cas-004-topic-1-question-25-discussion/"},{"id":"u3KghvkTkqFMRhN6j44M","choices":{"A":"have non-deterministic behavior and are not deployed with encryption.","D":"have deterministic behavior and are not deployed with encryption.","B":"have non-deterministic behavior and are deployed with encryption.","C":"have deterministic behavior and are deployed with encryption."},"exam_id":343,"isMC":true,"timestamp":"2023-03-19 05:59:00","answers_community":["D (84%)","C (16%)"],"question_images":[],"discussion":[{"upvote_count":"7","comment_id":"852349","timestamp":"1679939760.0","content":"Selected Answer: D\nFor safety-critical systems, CAN is the most widely used communication protocol and does not have a built-in encryption mechanism. This prioritizes low latency and deterministic response times over encryption.\n\nhttps://www.ncbi.nlm.nih.gov/pmc/articles/PMC7219335/","poster":"FoxTrotDG","comments":[{"poster":"CraZee","comment_id":"1130841","content":"FoxTrotDG - from the article you linked:\n\nThe CAN protocol uses a shared broadcast network without a built-in encryption mechanism. This allows an adversary to eavesdrop all the nodes and understand the communication. To prevent this data breach, a light-weight encryption system should be implemented. \n\nThat points me to C.","upvote_count":"1","timestamp":"1706112180.0"},{"content":"btw...I HATE the question wording...\"most often use\"...that could lend itself to D as the nature of the CAN does not have built-in encryption (as your link indicates)...","comment_id":"1130848","poster":"CraZee","timestamp":"1706112420.0","upvote_count":"1"}]},{"content":"In real-time, safety-critical systems, the primary concern is ensuring that the system behaves in a predictable and reliable manner to meet safety requirements. Given this focus, the correct choice from the options provided is D. Have deterministic behavior and are not deployed with encryption.\nHere’s why: Deterministic Behavior: Real-time systems require deterministic behavior to ensure that data is transmitted and processed within strict time constraints. This predictability is crucial for maintaining the safety and reliability of the system.\nEncryption: While encryption is important for security and protecting data from unauthorized access, it is not typically the primary concern for real-time, safety-critical systems when compared to the need for deterministic behavior. These systems often focus on the reliability and timing of data transfer rather than encryption.\nTherefore, for real-time, safety-critical systems, deterministic behavior is paramount, and encryption is not always a requirement or priority in these contexts.","comment_id":"1273534","timestamp":"1724771880.0","poster":"Bright07","upvote_count":"2"},{"timestamp":"1721046420.0","comment_id":"1248334","upvote_count":"1","poster":"23169fd","content":"Selected Answer: D\nDeterministic Behavior: Safety-critical systems require predictable and reliable communication to ensure that tasks are executed within strict time constraints. Deterministic behavior in serial busses ensures that data transmission occurs in a predictable manner, which is essential for the correct functioning of real-time systems.\n\nEncryption: While encryption is crucial for securing data, it can introduce latency and overhead that might be unacceptable in real-time, safety-critical environments. In these contexts, the focus is often on ensuring that data is transmitted accurately and timely rather than encrypted, to maintain the system's performance and reliability."},{"timestamp":"1704677700.0","content":"Selected Answer: D\nIt's a serial bus, not a networked server. How much encryption is going on in the serial bus of the computer you're on right now? How much encryption happens between any two hardlinked components or machines? I'm not even sure modern laptops have any serial I/Os in them, but the point is that you don't need to encrypt non-networked pieces of your infrastructure. encryption would be overkill and generally counterproductive in a single-bit-at-a-time hardlined proprietary-safety-message-sendy-machine.","comment_id":"1116305","upvote_count":"1","poster":"Trap_D0_r"},{"upvote_count":"1","timestamp":"1702572060.0","poster":"Anarckii","comment_id":"1096657","content":"Selected Answer: C\nsafety critical systems without encryption is insane. You would consider a different system and topology for a SAFETY CRITICAL system than using a CAN."},{"timestamp":"1690588920.0","poster":"imather","content":"Selected Answer: D\nDeterministic means it contains a field that has info regarding message priority. Can bus is one such serial bus, and by default does not have encryption, although it can have.","comment_id":"965935","upvote_count":"1"},{"content":"Option D. Deploying encryption on serial busses may introduce additional processing overhead and introduce delays, which can adversely affect the timing and predictability of the critical systems. Therefore, safety-critical systems that use serial busses typically do not use encryption, as the need for predictable, deterministic behavior takes priority over data confidentiality.","upvote_count":"2","timestamp":"1681780020.0","comment_id":"873220","poster":"BreakOff874"},{"timestamp":"1680229440.0","comment_id":"856551","poster":"Amin4799","content":"Selected Answer: C\nDeterministic behavior is critical for these systems, as it ensures that tasks are executed in a predictable and reliable manner","upvote_count":"1"},{"comment_id":"856203","upvote_count":"3","content":"Selected Answer: D\nfrom what I read online, the CAN bus is a broadcast network and isn't designed with encryption in mind. I was trying to tie CAN busses to safety critical systems and found 1 or 2 articles mentioning it. I was originally thinking C because encryption seems like a no brainer for mission critical applications or use cases, but apparently, no encryption (yet) on CAN busses","timestamp":"1680206880.0","poster":"Geofab"},{"timestamp":"1679202720.0","poster":"Cock","upvote_count":"1","comment_id":"843452","content":"Selected Answer: C\nc. i apologize. The answer is C"},{"comments":[{"upvote_count":"6","poster":"Cosmic_robot","comment_id":"880681","timestamp":"1682443320.0","content":"Make up your mind Cock"}],"upvote_count":"3","comment_id":"843447","content":"Selected Answer: D\neal-time safety-critical systems require deterministic behavior to ensure that specific tasks are carried out within a defined timeframe. Serial busses that have deterministic behavior can guarantee that messages are sent and received at a predictable rate, which is essential for these systems to operate as intended. Additionally, security is also critical for safety-critical systems, and deploying serial busses with encryption provides an added layer of protection against unauthorized access, tampering, or data breaches.","timestamp":"1679201940.0","poster":"Cock"}],"url":"https://www.examtopics.com/discussions/comptia/view/103174-exam-cas-004-topic-1-question-250-discussion/","answer_description":"","topic":"1","answer_ET":"D","answer_images":[],"answer":"D","question_id":169,"unix_timestamp":1679201940,"question_text":"Real-time, safety-critical systems MOST often use serial busses that:"},{"id":"6r9f8UUD02WNhZTzXseu","answer":"AC","answer_images":[],"timestamp":"2023-03-19 05:42:00","question_images":[],"exam_id":343,"unix_timestamp":1679200920,"discussion":[{"poster":"YUYUY","timestamp":"1706025480.0","content":"Selected Answer: AC\nThis one took some thought, but then it became clear. The only problem stated in the question was the plain text passwords in code. So how do you remove passwords from APIs? API Keys to replace the passwords! A and C are the only options that make sense and they both can be applied at the same time. \nB. This may help us detect misuse, but why wait for an issue to happen when you can mitigate the risk with API keys?\nD. This one is just irrelevant.\nE. This answer would be perfect if it said SAST or IAST instead of DAST. DAST's don't scan source code.\nF. MFA only secures the computers, the clear text passwords are within an API so they are still going across the network.","comment_id":"1129748","upvote_count":"6"},{"timestamp":"1720625460.0","upvote_count":"5","content":"Selected Answer: AE\nThe company can address the finding by choosing the following two options:\nA. Implement complex, key-length API key management. API key management involves generating, distributing, and revoking API keys. By implementing complex, key-length API key management, the company can ensure that only authorized entities have access to the APIs. This can help prevent unauthorized access and reduce the risk of sensitive information, such as passwords, being embedded in the code.\nE. Incorporate a DAST (Dynamic Application Security Testing) into the DevSecOps process to identify the exposure of secrets. DAST is a testing process that involves inspecting an application in its running state for security vulnerabilities. By incorporating DAST into the DevSecOps process, the company can identify instances where secrets, such as passwords, are being exposed in the code. This can help the company address these issues before the application is deployed.","poster":"AGUDLP","comment_id":"1245561"},{"comment_id":"1324802","timestamp":"1733880780.0","upvote_count":"2","comments":[{"comment_id":"1324803","upvote_count":"1","timestamp":"1733880840.0","poster":"deeden","content":"C. Implement time-based API key management:\nTime-based keys can be a good secondary control, but without addressing the core issue (embedded passwords), this alone is insufficient to solve the problem.\n\nD. Use SOAP instead of restful services:\nSwitching to SOAP is not a direct solution for securing credentials. SOAP can still suffer from the same issue if credentials are embedded in the code.\n\nF. Enforce MFA on the developers’ workstations and production systems:\nMFA enhances access control for developers, but it does not address the problem of hardcoded passwords in the application code."}],"content":"Selected Answer: AE\nDAST cannot directly scan source code to identify hardcoded secrets. This is beyond its scope as it analyzes the application as a black-box system. It is better at detecting the symptoms of embedded secrets (e.g., weak or static authentication) rather than the root cause. For direct detection of embedded keys or passwords, a Static Application Security Testing (SAST) tool is more appropriate.","poster":"deeden"},{"poster":"Bright07","upvote_count":"2","comment_id":"1321129","content":"Selected Answer: AE\nA. Implement complex, key-length API key management. API keys are often used for authentication in APIs. By managing API keys securely (e.g., using complex, long keys), the company can reduce the risk of exposed secrets. This could include implementing key rotation, encryption, and storing keys in secure vaults rather than hardcoding them in source code. Properly managing API keys can prevent attackers from easily accessing sensitive systems in case a key is compromised.\nE. Incorporate a DAST into the DevSecOps process to identify the exposure of secrets.\nDynamic Application Security Testing (DAST) tools can automatically scan running applications and APIs for vulnerabilities, including exposed secrets (like passwords). This would allow the company to identify unencrypted passwords in the code during development or testing before the application is deployed to production. DAST tools can be integrated into the DevSecOps process to continuously monitor for such security issues.","timestamp":"1733179980.0"},{"comment_id":"1248336","poster":"23169fd","timestamp":"1721046540.0","upvote_count":"3","content":"Selected Answer: AE\nA. Implement complex, key-length API key management: This ensures that API keys are strong and secure, making it harder for attackers to guess or brute-force them. Complex and sufficiently long keys reduce the risk of unauthorized access.\n\nE. Incorporate a DAST into the DevSecOps process to identify the exposure of secrets: Dynamic Application Security Testing (DAST) tools can scan running applications to detect vulnerabilities, including the exposure of sensitive information such as unencrypted passwords. Integrating DAST into the DevSecOps pipeline helps in identifying and addressing these security issues early in the development process."},{"comments":[{"comment_id":"1244505","poster":"isaphiltrick","upvote_count":"2","content":"Here's why I don't think it's A. Implement complex, key-length API key management:\nWhile strong and complex API keys are important for security, they do not directly mitigate the risk of embedding unencrypted passwords in code. This answer choice focuses more on the strength and complexity of keys rather than addressing the specific issue of unencrypted passwords.","timestamp":"1720462020.0"}],"upvote_count":"1","comment_id":"1244504","timestamp":"1720461960.0","poster":"isaphiltrick","content":"Selected Answer: CE\nI believe C & E are the best answers for these reasons:\nC. Implement time-based API key management: Time-based API key management involves issuing API keys that have a limited validity period. This approach reduces the risk associated with compromised or leaked keys because they automatically expire after a certain timeframe. It's a practical approach to mitigating the impact of potential exposure of API keys, including unencrypted passwords embedded in code.\n\nE. Incorporate a DAST into the DevSecOps process to identify the exposure of secrets: Dynamic Application Security Testing (DAST) tools are crucial for identifying vulnerabilities in deployed applications and APIs. While they don't directly inspect source code, they perform black-box testing to simulate attacks and identify potential security weaknesses, including exposed secrets like unencrypted passwords in APIs."},{"upvote_count":"2","timestamp":"1705350540.0","comment_id":"1123646","content":"MFA makes no sense here. It does nothing for hardcoded secrets in code.","poster":"hb0011"},{"upvote_count":"2","content":"Lol, I may not know everything but I know this question has NOTHING to do with MFA at all. \"Developers are doing bad coding so... make sure they use authy to log into their laptop??? What???\"\nE. DAST is what they're already doing--thats how they discovered the security issue. Keep doing it to make sure the developers don't do something else stupid.\nC. There's OBVIOUSLY no key management going on here. The Developers are just writing passwords into the source code, which will break the API when they keys change. In order to fix the problem, use a time-based key management strategy (sometimes called SECRET ROTATION if you're using SECRETS MANAGER). This will cause the keys to cycle every X amount of time, which means if the developers keep trying to hard code passwords, those passwords will require regular update in the source code, and before long they'll realize it's easier just to source the key directly from the secrets manager than to keep updating their source code. This solution forces the developers to do their job correctly, and is in alignment with industry best practices.","timestamp":"1704678120.0","poster":"Trap_D0_r","comment_id":"1116312"},{"poster":"abrub","comment_id":"1116097","content":"Selected Answer: CE\nTo address the finding of unencrypted passwords embedded in the code for API management, the company can take the following actions:\n\n Implement time-based API key management (Option C): Time-based API key management involves regularly rotating or changing the API keys, reducing the impact of compromise if keys are exposed. This is especially important if developers are embedding unencrypted passwords in the code.\n\n Incorporate a DAST into the DevSecOps process to identify the exposure of secrets (Option E): Dynamic Application Security Testing (DAST) involves scanning applications during runtime to identify security vulnerabilities, including the exposure of secrets. By incorporating DAST into the DevSecOps process, the company can regularly scan the APIs for security issues, including the presence of unencrypted passwords.\n\nOptions A, B, D, and F are not directly addressing the issue of unencrypted passwords in the code","timestamp":"1704653100.0","upvote_count":"1"},{"timestamp":"1702573560.0","comments":[{"content":"Changing to E and F for these reasons:\n\nE. Incorporate a DAST into the DevSecOps process to identify the exposure of secrets:\n\nDynamic Application Security Testing (DAST) tools can identify vulnerabilities, including the exposure of secrets, during runtime. They simulate attacks on a running application to discover security issues. In this context, DAST can help identify instances where passwords are exposed.\nF. Enforce MFA on the developers’ workstations and production systems:\n\nMulti-Factor Authentication (MFA) adds an extra layer of security to access control. Enforcing MFA on developer workstations and production systems can help mitigate the risk of unauthorized access, especially if passwords are compromised. While MFA doesn't directly prevent embedding passwords, it enhances overall access security.","comment_id":"1106279","poster":"Anarckii","timestamp":"1703614200.0","comments":[{"content":"I know a Chat GPT response when I see one. lol I think your first answer was right though. AC","upvote_count":"4","timestamp":"1706025900.0","comment_id":"1129753","poster":"YUYUY"}],"upvote_count":"1"}],"content":"Selected Answer: AC\nafter multiple run throughs and question, DAST would not be correct because Dynamic analysis and testing will not look at the source code for embedded information. So E is out of the question. In consideration we can look at the Application Programming Interface though and implement key management for passwords. This way there is encryption and integrity. \nB - Session logs wouldn't help the situation\nC - Key management is already being worked on why not enhance it even more since its resolving the current issues identified \nD - SOAP is just a joke in this situation\nE - already discussed\nF - Another great form of security but focuses on the workstation and not the application. If it directed towards MFA with the application it would be correct","upvote_count":"4","poster":"Anarckii","comment_id":"1096683"},{"upvote_count":"3","poster":"ThatGuyOverThere","timestamp":"1698621960.0","comment_id":"1057188","content":"Selected Answer: AC\nI'm going with A and C. I don't see how the others are relevant to the question's specifics. DAST doesn't look at source code so you'd need SAST."},{"upvote_count":"2","poster":"p1s3c","comment_id":"892849","timestamp":"1683614940.0","content":"Selected Answer: EF\nBased on the given scenario, the two BEST solutions to address the finding of unencrypted passwords embedded in code are:\n\nE. Incorporate a DAST into the DevSecOps process to identify the exposure of secrets: Dynamic Application Security Testing (DAST) can help detect vulnerabilities in an application's API security, including issues with password management. By incorporating DAST into the DevSecOps process, the company can identify the exposure of secrets and other vulnerabilities early in the development cycle.\n\nF. Enforce MFA on the developers’ workstations and production systems: Multi-Factor Authentication (MFA) can help prevent unauthorized access to systems and applications. By enforcing MFA on the developers’ workstations and production systems, the company can reduce the risk of attackers gaining access to sensitive information and passwords."},{"timestamp":"1680241200.0","content":"Selected Answer: EF\nE. Incorporate a DAST (Dynamic Application Security Testing) into the DevSecOps process to identify the exposure of secrets. This will help the company to identify the potential vulnerabilities in the API codes and take necessary measures to address them.\n\nF. Enforce MFA (Multi-Factor Authentication) on the developers’ workstations and production systems. This will ensure that the authentication process is more secure and reduce the chances of unencrypted passwords being embedded in the code.","poster":"Amin4799","comment_id":"856641","upvote_count":"4"},{"content":"Selected Answer: CE\nfor sure E is part of the answer (DAST). I think the next part of the answer is C because it would eliminate the need to hard code unencrypted passwords in code. maybe the devs are doing that because they have to in order for the API to work.","upvote_count":"3","timestamp":"1680206640.0","comment_id":"856197","poster":"Geofab"},{"poster":"Cock","content":"Selected Answer: BE\nThe options that can address the finding of unencrypted passwords in the code are:\n\nB. Implement user session logging: This option is useful for tracking the activities of users and developers. It can help identify which users are accessing the API and monitor their session activities.\n\nE. Incorporate a DAST into the DevSecOps process to identify the exposure of secrets: This option is useful for identifying potential security vulnerabilities in the API code. By using a dynamic application security testing (DAST) tool, developers can scan the API code to detect any exposed secrets or unencrypted passwords.","comment_id":"843434","timestamp":"1679200920.0","upvote_count":"1"}],"question_text":"A company wants to securely manage the APIs that were developed for its in-house applications. Previous penetration tests revealed that developers were embedding unencrypted passwords in the code. Which of the following can the company do to address this finding? (Choose two.)","choices":{"B":"Implement user session logging.","A":"Implement complex, key-length API key management.","F":"Enforce MFA on the developers’ workstations and production systems.","C":"Implement time-based API key management.","D":"Use SOAP instead of restful services.","E":"Incorporate a DAST into the DevSecOps process to identify the exposure of secrets."},"isMC":true,"question_id":170,"answer_description":"","answer_ET":"AC","url":"https://www.examtopics.com/discussions/comptia/view/103170-exam-cas-004-topic-1-question-251-discussion/","answers_community":["AC (35%)","AE (32%)","EF (16%)","Other"],"topic":"1"}],"exam":{"isBeta":false,"id":343,"name":"CAS-004","lastUpdated":"12 Apr 2025","numberOfQuestions":642,"provider":"Comptia","isMCOnly":false,"isImplemented":true},"currentPage":34},"__N_SSP":true}