{"pageProps":{"questions":[{"id":"6a9pdBzRyVmZKhGbSvy6","question_images":[],"question_text":"Which of the following technologies provides load balancing, encryption, and observability in containerized environments?","topic":"1","unix_timestamp":1671886320,"isMC":true,"timestamp":"2022-12-24 13:52:00","exam_id":371,"url":"https://www.examtopics.com/discussions/comptia/view/92632-exam-xk0-005-topic-1-question-108-discussion/","answers_community":["D (100%)"],"question_id":11,"discussion":[{"upvote_count":"2","content":"Selected Answer: D\nThe answer is D. Service mesh.","poster":"Alizadeh","comment_id":"982882","timestamp":"1723833540.0"},{"timestamp":"1707857820.0","comment_id":"807803","content":"Selected Answer: D\nA service mesh is a dedicated infrastructure layer that provides communication management between microservices in a containerized environment. Service meshes provide a range of features including load balancing, service discovery, traffic routing, encryption, and observability. The most popular service mesh frameworks are Istio, Linkerd, and Consul.\n\nThe other options provided are:\n\nA. Virtual private network (VPN) - A VPN is a secure connection between two networks over the internet, which is primarily used to ensure secure remote access to a private network.\n\nB. Sidecar pod - A sidecar pod is a design pattern in Kubernetes that allows for two containers to run within the same pod.\n\nC. Overlay network - An overlay network is a virtual network that is built on top of an existing physical network, providing additional network management features, but does not inherently provide the features mentioned in the question.","upvote_count":"2","poster":"linux_admin"},{"timestamp":"1703422320.0","comment_id":"754866","upvote_count":"1","content":"Selected Answer: D\nAnswer is D\n\"A service mesh controls the delivery of service requests in an application. Common features provided by a service mesh include service discovery, load balancing, encryption and failure recovery.\"\n\nhttps://www.techtarget.com/searchitoperations/definition/service-mesh","poster":"Ckl22"}],"answer_description":"","answer":"D","answer_ET":"D","answer_images":[],"choices":{"D":"Service mesh","B":"Sidecar pod","C":"Overlay network","A":"Virtual private network"}},{"id":"UpfLSpFw7gnzBlX2nROr","answer_ET":"C","answer":"C","question_text":"A development team asks an engineer to guarantee the persistency of journal log files across system reboots. Which of the following commands would accomplish this task?","answer_description":"","exam_id":371,"url":"https://www.examtopics.com/discussions/comptia/view/87035-exam-xk0-005-topic-1-question-109-discussion/","question_id":12,"question_images":[],"timestamp":"2022-11-06 00:35:00","isMC":true,"discussion":[{"content":"Selected Answer: C\nThe correct answer is C :)","comment_id":"1125813","poster":"tegami","timestamp":"1721297760.0","upvote_count":"2"},{"upvote_count":"1","content":"Selected Answer: A\nTEST KO sed -i 's/auto/persistent/g' /etc/systemd/journald.conf && sed -i 'persistent/s/ˆ#//q' /etc/systemd/journald.conf \n\nTEST OK sed -i 's/auto/persistent/g' /etc/systemd/journald.conf && sed -i '/persistent/s/ˆ#//' /etc/systemd/journald.conf\n\nAnother method\nTEST OK sed -i 's/auto/persistent/g' /etc/systemd/journald.conf && sed -i '/^#Storage/s/^#//' /etc/systemd/journald.conf","comment_id":"1028938","timestamp":"1712667240.0","poster":"Damon54"},{"poster":"Damon54","upvote_count":"1","timestamp":"1710243360.0","comment_id":"1005589","content":"Selected Answer: A\nthe correct syntax for the answer c should be\nsed -i 's/auto/persistent/g' /etc/systemd/journald.conf && sed -i '/^#persistent/s/^#//' /etc/systemd/journald.conf\nAt this point I would vote for answer A"},{"content":"Selected Answer: C\nThe supported values are “volatile”, “persistent”, “auto” and “none”\nDefault storage type is configured as “auto”\nIf “volatile“, journal log data will be stored only in memory, i.e. below the /run/log/journal hierarchy (which is created if needed)\nIf “persistent“, data will be stored preferably on disk, i.e. below the /var/log/journal hierarchy, with a fallback to /run/log/journal during early boot stage and if the disk is not writable\nThe “auto” value will configure journald to store journal log data in the /var/log/journal/ directory. However, the directory must already exist and have the proper permissions set. If it does not exist, then journal data is stored in the volatile /run/log/journal/ directory, and the data is erased when the system shuts down.\n“none” turns off all storage, all log data received will be dropped.","comment_id":"971839","timestamp":"1707042780.0","upvote_count":"1","poster":"Damon54"},{"content":"C. sed -i 's/auto/persistent/g' /etc/systemd/journald.conf && sed -i '/persistent/s/^#//' /etc/systemd/journald.conf\n\nExplanation:\n\nThe first part of the command, sed -i 's/auto/persistent/g' /etc/systemd/journald.conf, replaces all occurrences of \"auto\" with \"persistent\" in the /etc/systemd/journald.conf file. This ensures that the journal log files are set to be persistent.\n\nThe second part of the command, sed -i '/persistent/s/^#//' /etc/systemd/journald.conf, removes the comment character '#' from the line that contains \"persistent\" in the /etc/systemd/journald.conf file. This activates the persistence configuration.\n\nBy combining these two sed commands, the configuration file is modified to enable the persistence of journal log files across system reboots.","poster":"LKRISB","upvote_count":"4","timestamp":"1700390700.0","comment_id":"901774"},{"timestamp":"1692897600.0","comment_id":"820860","upvote_count":"1","poster":"nixonbii","content":"Just asking a question, what guarantees that those changes in answer C will survive a system restart? Doesn't the file need to be saved and reloaded to become persistent?"},{"comments":[{"upvote_count":"2","timestamp":"1691955060.0","content":"The command sed -i 'persistent/s/^#//q' /etc/systemd/journald.conf attempts to remove a comment symbol # before the word \"persistent\" in the /etc/systemd/journald.conf file.\n\nsed: a command-line utility for processing text\n-i: a command-line option that instructs sed to edit the file in place, rather than outputting the edited text to the console\n'persistent/s/^#//q': the sed command to be executed. This command consists of three parts:\npersistent: the search pattern to look for in the file\n/: a delimiter that separates the search pattern from the replacement pattern\n^#//q: the replacement pattern and a command to quit after the first match is found. The ^# means \"replace the first occurrence of a comment symbol at the beginning of the line with nothing,\" and the q means \"quit immediately after the replacement is made.\" Note that the persistent search pattern and the # comment symbol are separated by a caret (^) character, which is a regular expression metacharacter that matches the start of a line.","comment_id":"807817","poster":"linux_admin"}],"upvote_count":"2","content":"Selected Answer: C\nThe command sed -i 's/auto/persistent/g' /etc/systemd/journald.conf && sed -i 'persistent/s/^#//q' /etc/systemd/journald.conf attempts to modify the /etc/systemd/journald.conf file to enable persistent journal storage.\n\nHere is a breakdown of the command:\n\nsed: a command-line utility for processing text\n-i: a command-line option that instructs sed to edit the file in place, rather than outputting the edited text to the console\n's/auto/persistent/g': the sed command to be executed. This command consists of three parts:\ns: a command to substitute (replace) text\nauto: the search pattern to look for in the file\npersistent: the replacement pattern to replace the search pattern\ng: a global option that means to replace all occurrences of the search pattern in the file, not just the first occurrence.","poster":"linux_admin","comment_id":"807813","timestamp":"1691954280.0"},{"comment_id":"807376","timestamp":"1691922420.0","poster":"KnifeClown1","content":"Selected Answer: C\nC for real","upvote_count":"2"},{"content":"C. sed -i 's/auto/persistent/g' /etc/systemd/journald.conf && sed -i 'persistent/s/ˆ#//q' /etc/systemd/journald.conf","comment_id":"803189","timestamp":"1691575800.0","poster":"KnifeClown1","upvote_count":"2"},{"timestamp":"1688793540.0","poster":"Pinnubhai","content":"Selected Answer: C\nReplace storage type with Storage=persistent\n\n# sed -i 's/#Storage.*/Storage=persistent/' /etc/systemd/journald.conf\n\nNext you can restart systemd-journald service\n\n# systemctl restart systemd-journald.service","upvote_count":"1","comment_id":"769164"},{"poster":"Ckl22","upvote_count":"1","content":"Selected Answer: C\nC does appear to be the only one that would make the logs persistent","comment_id":"754865","timestamp":"1687603740.0"},{"content":"I don't see any correct answer, but C is the closest. A is not correct because command one searches for the pattern \"auto\" in the file /etc/systemd/journald.conf, ignoring case. It will find it, thereby causing command two to execute. Restarting the journald service doesn't help if you made no changes to the .conf file!. Answer C searches for the pattern \"auto\", globally in the same file, but replaces it with the pattern \"persistent\", in the file (that is the -i option). That's great, but I tested it with command two and get an error. I suggest command two be the restart of the journald service.","timestamp":"1683322500.0","comments":[{"poster":"Nvoid","comment_id":"726342","content":"Good work MissAllen, (C) seems correct 1st command & (A) 2nd Command.\nHeya wanna turn that Miss into Mrs.Allen? email: mrs.allen@blackhat.io <3 you can come live on this paradise island wit me :)","upvote_count":"4","timestamp":"1684973400.0"}],"comment_id":"712070","upvote_count":"4","poster":"MissAllen"}],"unix_timestamp":1667691300,"answer_images":[],"answers_community":["C (82%)","A (18%)"],"choices":{"D":"journalctl --list-boots && systemctl restart systemd-journald.service","B":"cat /etc/systemd/journald.conf | awk '(print $1,$3)'","C":"sed -i 's/auto/persistent/g' /etc/systemd/journald.conf && sed -i 'persistent/s/ˆ#//q' /etc/systemd/journald.conf","A":"grep -i auto /etc/systemd/journald.conf && systemctl restart systemd-journald.service"},"topic":"1"},{"id":"ilruIzBvBjxlTxWmz5M4","isMC":true,"answer_images":[],"answer_description":"","question_text":"A Linux administrator was asked to run a container with the httpd server inside. This container should be exposed at port 443 of a Linux host machine while it internally listens on port 8443. Which of the following commands will accomplish this task?","topic":"1","question_id":13,"answer_ET":"A","url":"https://www.examtopics.com/discussions/comptia/view/98689-exam-xk0-005-topic-1-question-11-discussion/","answers_community":["A (57%)","B (43%)"],"choices":{"C":"podman run –d -e 443:8443 httpd","B":"podman run -d -p 8443:443 httpd","D":"podman exec -p 8443:443 httpd","A":"podman run -d -p 443:8443 httpd"},"question_images":[],"timestamp":"2023-02-10 14:05:00","exam_id":371,"discussion":[{"content":"Selected Answer: A\nA. HOST:CONTAINER, 443 on the host and 8443 443:8443","comment_id":"1328114","timestamp":"1734463980.0","upvote_count":"1","poster":"JRS99"},{"upvote_count":"2","timestamp":"1724689140.0","comment_id":"1272894","content":"A. -p HOST:CONTAINER. (Maps Port) \nB Invalid as that is syntaxed as CONTAINER:HOST\nC Invalid as it uses the -e option (ENV VARIABLE) which is not used\nD Invalid for CONTAINER:HOST among other things.","poster":"Mike313"},{"upvote_count":"2","content":"A. If you’re using docker compose the pattern is HOST:CONTAINER, i.e. 443 on the host and 8443 on the container would be 443:8443","poster":"rfc_1918","timestamp":"1706058600.0","comment_id":"1130131"},{"timestamp":"1703025780.0","comment_id":"1101047","poster":"BryanSME","upvote_count":"2","content":"https://www.howtoforge.com/getting-started-with-podman-manage-images-container-and-volumes/ \nwhich is mentioned by Rob74613 also indicates host:container so A is correct\nManage Containers\n\nAt this stage, we learned about container image management. And the next step, we will learn how to create and manage containers with Podman.\n\nTo create a new container, we can use 'podman run' command as below.\n\npodman run -d -p 8000:80 --name hakase-nginx docker.io/library/nginx\n\nThe command will create a new container named 'hakase-nginx' based on the nginx image and will expose the port 8000 on the host machine.\n\nDetails command options:\n\n-d - keep the container running in the background and just print the container ID as a result.\n-p 8000:80 - port mapping for container and the host system. Port 8000 on the host machine, and port 80 on the container.\n--name hakase-nginx - specify the container name with 'hakase-nginx'.\n\nNow display all running containers on the system."},{"timestamp":"1703025300.0","poster":"BryanSME","content":"This is a useful article: \nhttps://docs.podman.io/en/latest/markdown/podman-run.1.html\n-p=[[ip:][hostPort]:]containerPort[/protocol]\nthis would make \"A\" the correct answer","comment_id":"1101044","upvote_count":"1"},{"poster":"nabalauski","comment_id":"1100071","upvote_count":"1","content":"Selected Answer: B\nanswer is B.\n\nThe exposed port of an application can be mapped to a host port using the -p flag. For example, an httpd port 80 can be mapped to the host port 8080 using the following:\n\n$ podman run -p 8080:80 -d -i -t fedora/httpd","timestamp":"1702937280.0"},{"comment_id":"1091397","content":"A should be correct","timestamp":"1702087320.0","poster":"[Removed]","upvote_count":"1"},{"upvote_count":"1","poster":"DRVision","timestamp":"1701973620.0","content":"Selected Answer: B\nTo create a new container, we can use 'podman run' command as below.\n\npodman run -d -p 8000:80 --name hakase-nginx docker.io/library/nginx\nThe command will create a new container named 'hakase-nginx' based on the nginx image and will expose the port 8000 on the host machine.\n\nDetails command options:\n\n-d - keep the container running in the background and just print the container ID as a result.\n-p 8000:80 - port mapping for container and the host system. Port 8000 on the host machine, and port 80 on the container.\n--name hakase-nginx - specify the container name with 'hakase-nginx'.\n\nNow display all running containers on the system.","comment_id":"1090523"},{"poster":"funax","timestamp":"1700471580.0","content":"Selected Answer: A\n<host_port>:<container_port>.","upvote_count":"2","comment_id":"1075282"},{"comment_id":"957674","timestamp":"1689862080.0","content":"Selected Answer: B\nconcur with rob","upvote_count":"1","poster":"clean_it_up_janny"},{"comment_id":"935140","upvote_count":"3","poster":"Rob74613","content":"Answer is B\nSource: https://www.howtoforge.com/getting-started-with-podman-manage-images-container-and-volumes/\n\nlook at section 3: Manage Contatiners","timestamp":"1687853700.0"},{"poster":"mrtwister76","comment_id":"907357","timestamp":"1685104800.0","content":"Definitely A","upvote_count":"1"},{"content":"Selected Answer: A\nI checked the documentation and first is host port and then the container port, so option A should be the right one. since you are exposing the port 443 on the host to the port 8443 on the container","upvote_count":"2","poster":"tutita","comment_id":"906485","timestamp":"1684999980.0"},{"content":"Selected Answer: B\nB is correct\n-p 8443:443: This option specifies the port mapping. It maps port 8443 of the host machine to port 443 of the container.","timestamp":"1684568160.0","upvote_count":"1","poster":"Rob74613","comment_id":"902409"},{"content":"Selected Answer: A\nAns is A.","timestamp":"1680093660.0","upvote_count":"1","comment_id":"854410","poster":"Aamm033"},{"upvote_count":"1","content":"bbbbbbbbb","timestamp":"1678283820.0","comment_id":"833025","poster":"kloug"},{"content":"According to the Podman documentation, the host machine port is the first parameter in the command when used with the -p option: \n\n -p=[[ip:][hostPort]:]containerPort[/protocol]\n\nUnder this construction, answer A would be correct. I know that Podman can be seamlessly aliased to Docker in Ubuntu but I am not sure if Docker uses a different construction. I also think that the fact that Podman is a daemonless application influences how it interfaces with the O/S ports and protocols.","poster":"nixonbii","timestamp":"1677361860.0","upvote_count":"2","comment_id":"821854"},{"comment_id":"808778","poster":"Lwarder1","upvote_count":"2","timestamp":"1676404080.0","content":"Selected Answer: A\nthe answer is A, Host machine first (443) then the container (8443), the wording can be tricky. so podman run -d -p 443:8443 httpd"},{"content":"the answer is A, Host machine first (443) then the container (8443), the wording can be tricky. so podman run -d -p 443:8443 httpd","poster":"Lwarder1","upvote_count":"1","timestamp":"1676404020.0","comment_id":"808777"},{"poster":"linux_admin","comment_id":"806685","comments":[{"poster":"linux_admin","timestamp":"1676227800.0","upvote_count":"1","content":"o accomplish this task, the administrator should run the following command:\n\npodman run -d -p 8443:443 httpd\n\nThis command maps port 443 on the host machine to port 8443 inside the container, and starts the container with the httpd server running in the background.","comment_id":"806686"}],"upvote_count":"4","timestamp":"1676227800.0","content":"B. podman run -d -p 8443:443 httpd\n\nThe podman run command is used to run a new container, and the -d option is used to run the container in the background. The -p option is used to specify port mapping, where the first number is the port on the host machine, and the second number is the port inside the container.\n\nIn this case, the container should be exposed at port 443 of the host machine, while it internally listens on port 8443."},{"comment_id":"804323","upvote_count":"2","poster":"KnifeClown1","timestamp":"1676034300.0","content":"Selected Answer: B\nThe correct answer is B. podman run -d -p 8443:443 httpd\n\nThe podman run command is used to run a new container, and the -p option maps a port from the host machine to a port in the container. The syntax is -p host_port:container_port. In this case, the administrator wants to expose port 443 of the host machine and map it to port 8443 inside the container, so the correct command is podman run -d -p 8443:443 httpd","comments":[{"content":"just dont mind, i am wrgond","timestamp":"1676034420.0","upvote_count":"1","comment_id":"804326","poster":"KnifeClown1"}]}],"unix_timestamp":1676034300,"answer":"A"},{"id":"TZST6NzouepZwOGJUCmz","isMC":true,"answer_images":[],"answer_ET":"B","unix_timestamp":1671885840,"url":"https://www.examtopics.com/discussions/comptia/view/92631-exam-xk0-005-topic-1-question-110-discussion/","question_id":14,"answer_description":"","question_text":"A systems administrator is receiving tickets from users who cannot reach the application app that should be listening on port 9443/tcp on a Linux server.\nTo troubleshoot the issue, the systems administrator runs netstat and receives the following output:\n//IMG//\n\nBased on the information above, which of the following is causing the issue?","question_images":["https://img.examtopics.com/xk0-005/image62.png"],"exam_id":371,"topic":"1","choices":{"D":"The application is not running.","A":"The IP address 0.0.0.0 is not valid.","B":"The application is listening on the loopback interface.","C":"The application is listening on port 1234."},"answer":"B","timestamp":"2022-12-24 13:44:00","answers_community":["B (100%)"],"discussion":[{"comments":[{"upvote_count":"1","poster":"ajna_","content":"lol...","timestamp":"1730937420.0","comment_id":"1064349"}],"poster":"tony12345","timestamp":"1726406700.0","upvote_count":"7","comment_id":"1008484","content":"B because longest answer"},{"poster":"linux_admin","comment_id":"807820","timestamp":"1707860100.0","upvote_count":"3","content":"Selected Answer: B\nBased on the output of netstat, the issue is that the application is listening on the loopback interface (127.0.0.1) rather than on a publicly accessible IP address.\n\nThe netstat output shows that the application is bound to the IP address 127.0.0.1 on port 9443, which means that it is only accessible from the same system (localhost). The 0.0.0.0:* field in the output indicates that the application is listening on all available network interfaces, but the IP address 0.0.0.0 does not actually represent a valid IP address.\n\nTo resolve the issue, the application needs to be reconfigured to listen on a publicly accessible IP address, such as the IP address of the system's network interface that is reachable from the users' network."},{"upvote_count":"2","timestamp":"1703421840.0","content":"Selected Answer: B\nAnswer is B.\nThe server is in a \"Listen\" state on port 9943 using its loopback address. The \"1234\" is a process-id","comment_id":"754862","poster":"Ckl22"}]},{"id":"uJm6XUTjFVWGcdqbP9xP","timestamp":"2022-11-01 15:58:00","question_id":15,"isMC":true,"exam_id":371,"answer_description":"","topic":"1","answer_images":[],"question_text":"A systems administrator is troubleshooting a connectivity issue pertaining to access to a system named db.example.com. The system IP address should be 192.168.20.88. The administrator issues the dig command and receives the following output:\n//IMG//\n\nThe administrator runs grep db.example.com /etc/hosts and receives the following output:\n//IMG//\n\nGiven this scenario, which of the following should the administrator do to address this issue?","answers_community":["D (100%)"],"discussion":[{"comment_id":"709226","upvote_count":"9","content":"Selected Answer: D\nWhy not D?","poster":"ryanzou","timestamp":"1667314680.0","comments":[{"comment_id":"724878","poster":"Veteran903","upvote_count":"8","content":"D is the right answer","timestamp":"1669176840.0"}]},{"timestamp":"1669342980.0","upvote_count":"5","poster":"Nvoid","comment_id":"726346","content":"Selected Answer: D\nD is correct."},{"comment_id":"1172625","upvote_count":"1","content":"None of the solutions provide a fix for the fact that remote systems are seeing the wrong ip address. The /etc/hosts file has no bearing on remote access. There is nothing that will fix this locally. The other systems need their /etc/hosts files fixed or DNS needs to be fixed.","comments":[{"timestamp":"1732274760.0","content":"the better answer is to remove everything from /etc/hosts, except the local hosts info and rely on dns. static entries for name resolution aren’t optimal.","upvote_count":"1","comment_id":"1316253","poster":"97155f3"},{"upvote_count":"1","timestamp":"1732274580.0","poster":"97155f3","comment_id":"1316252","content":"cat /etc/nsswitch.conf\nhosts: files dns"}],"poster":"bc1235813","timestamp":"1710339300.0"},{"upvote_count":"2","content":"Selected Answer: D\nD obviously","timestamp":"1675778400.0","comment_id":"800970","poster":"KnifeClown1"}],"answer_ET":"D","answer":"D","question_images":["https://img.examtopics.com/xk0-005/image63.png","https://img.examtopics.com/xk0-005/image64.png"],"url":"https://www.examtopics.com/discussions/comptia/view/86800-exam-xk0-005-topic-1-question-111-discussion/","choices":{"D":"Modify the /etc/hosts file and change the db.example.com entry to 192.168.20.88.","A":"Modify the /etc/hosts file and change the db.example.com entry to 192.168.20.89.","B":"Modify the /etc/network file and change the db.example.com entry to 192.168.20.88.","C":"Modify the /etc/network file and change the db.example.com entry to 192.168.20.89."},"unix_timestamp":1667314680}],"exam":{"isMCOnly":false,"provider":"Comptia","id":371,"lastUpdated":"12 Apr 2025","numberOfQuestions":266,"isBeta":false,"name":"XK0-005","isImplemented":true},"currentPage":3},"__N_SSP":true}