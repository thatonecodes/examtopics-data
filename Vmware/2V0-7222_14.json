{"pageProps":{"questions":[{"id":"P1Px9yP4k4ZaYvPfuSp6","unix_timestamp":1679549040,"answer":"BE","choices":{"B":"@SpringBootTest or @SpringJUnitConfig can be used for creating an ApplicationContext.","D":"The spring-test dependency provides annotations such as @Mock and @MockBean.","A":"EasyMock is supported out of the box.","C":"Mockito spy is not supported in Spring Boot testing by default.","E":"Integration and slice testing are both supported."},"timestamp":"2023-03-23 06:24:00","question_text":"Which two statements are true regarding Spring and Spring Boot Testing? (Choose two.)","answers_community":["BE (57%)","BC (29%)","14%"],"exam_id":252,"topic":"1","question_images":[],"url":"https://www.examtopics.com/discussions/vmware/view/103635-exam-2v0-7222-topic-1-question-7-discussion/","discussion":[{"timestamp":"1719754800.0","comment_id":"1239664","comments":[{"upvote_count":"1","poster":"stefumies","content":"WebMvc is an example of a SliceTest as it is merely testing the web controller layer","comment_id":"1300804","timestamp":"1729495800.0"}],"upvote_count":"1","poster":"2211094","content":"BD is most accurate and correct answer. Because of E does not elaborate clearly how slice and integration tests differs in spring and spring boot."},{"upvote_count":"2","content":"Correct answer is B and E","poster":"2211094","comment_id":"1228486","timestamp":"1718114340.0"},{"comment_id":"981398","timestamp":"1692085680.0","content":"Selected Answer: BC\nI have reviewed this question over again and it seems that B and C are the most likely of answers due by process of illumination. \nA is incorrect for obvious reasons\nB is correct because @SpringBootTest *OR* @SpringJUnitConfig can be used. I had to wrong in my comment below. That OR makes a big difference. \nC is correct as Mockito Spy is not supported (only by Spring Framework), but Mockito SpyBean is supported by default.\nD is incorrect for the same reason as specified in my comment below.\nE is incorrect for the same reason as specified in my comment below.","upvote_count":"2","poster":"Azuni"},{"upvote_count":"1","comment_id":"968854","timestamp":"1690876320.0","poster":"Azuni","content":"Selected Answer: C\nIt seems that C . It is a very tricky question. The Spring AND Spring Boot is where the trick lies. \nA) INCORRECT: Of course EasyBox is a dependency that is not out of the box.\nB) INCORRECT: If you consider Spring AND Spring Boot. @SpringBootTest and @SpringJUnitConfig both work in a Spring Boot application, but you cannot use @SpringBootTest in a plain Spring application.\nC) CORRECT: Mockito spy does come with Spring Boot, but it isn't supported by defualt.\nD) INCORRECT: spring-boot-starter-test does in fact provide annotations for @Mock and @MockBean, but spring-test by itself doesn't.\nE) INCORRECT: Only integration testing are supported by both. Slice testing is only a concept in Spring Boot, not in plain Spring."},{"content":"Selected Answer: BE\nD - it is not chosen because @Mock is commonly associated with other mocking frameworks like Mockito.","poster":"qqoo","comment_id":"944921","upvote_count":"4","comments":[{"timestamp":"1691042760.0","content":"E is not correct \nWhile integration testing and slice testing are both supported in Spring and Spring Boot, they are not both supported by default using a single testing annotation.\n\nIntegration Testing: Integration testing with Spring is supported using @SpringBootTest or @SpringJUnitConfig.\n\nSlice Testing: Slice testing is performed using specialized annotations like @WebMvcTest, @DataJpaTest, etc. These annotations load only a part of the application context to focus","comment_id":"970783","poster":"Tolo01","upvote_count":"1"}],"timestamp":"1688667600.0"},{"poster":"rhuanca","timestamp":"1680057660.0","comment_id":"853924","content":"B and D \nmockito is supported","upvote_count":"3"}],"isMC":true,"answer_description":"","answer_images":[],"question_id":66,"answer_ET":"BE"},{"id":"HFewtwFaSBkVId8q5h3O","timestamp":"2024-06-17 19:03:00","question_id":67,"question_images":[],"url":"https://www.examtopics.com/discussions/vmware/view/142651-exam-2v0-7222-topic-1-question-71-discussion/","isMC":true,"topic":"1","exam_id":252,"answer":"CE","choices":{"A":"The \"fat\" JAR contains both the class files and the source files for your project.","B":"The \"fat\" JAR requires an external Servlet container.","E":"The \"fat\" JAR is created by the Spring Boot Maven plugin or Gradle plugin.","C":"The \"fat\" JAR contains compiled classes and dependencies that your code needs to run.","D":"The \"fat\" JAR can contain multiple embedded application servers."},"answer_images":[],"unix_timestamp":1718643780,"answers_community":[],"discussion":[{"poster":"2211094","content":"CE is correct.","timestamp":"1718643780.0","comment_id":"1232035","upvote_count":"1"}],"answer_ET":"CE","answer_description":"","question_text":"Which two statements are true regarding a Spring Boot \"fat\" JAR? (Choose two.)"},{"id":"J8ponmhbzsdxn40YdzHu","answer_ET":"DE","timestamp":"2024-08-14 15:05:00","answer":"DE","topic":"1","exam_id":252,"choices":{"E":"The Java configuration can be profile specific by adding a @Profile annotation.","A":"The clientService bean declared will have prototype scope by default.","C":"The clientService bean will be lazy initialized the first time accessed.","D":"The bean is of type clientService and by default will be a Singleton.","B":"The name of the clientService() method is invalid and will throw an error."},"answer_images":[],"question_images":["https://img.examtopics.com/2v0-72-22/image28.png"],"answer_description":"","unix_timestamp":1723640700,"answers_community":["DE (100%)"],"isMC":true,"question_id":68,"question_text":"Refer to the exhibit.\n\n//IMG//\n\n\nAppConfig is a Java configuration class. Which two statements are true? (Choose two.)","url":"https://www.examtopics.com/discussions/vmware/view/145764-exam-2v0-7222-topic-1-question-79-discussion/","discussion":[{"comment_id":"1265773","timestamp":"1723640700.0","content":"Selected Answer: DE\nThe type of the Bean schould be written with 'C'","poster":"Evoila_TrainingMaterial","upvote_count":"3"}]},{"id":"YsUO74QIhBqO1fRsPWcp","isMC":true,"answer":"D","exam_id":252,"answer_images":[],"answer_description":"","question_id":69,"topic":"1","unix_timestamp":1679591040,"answers_community":["D (86%)","14%"],"question_images":["https://img.examtopics.com/2v0-72-22/image3.png"],"choices":{"C":"There is only one transaction because REQUIRES_NEW will use an active transaction if one already exists.","A":"There are 2 transactions because REQUIRES_NEW always runs in a new transaction.","B":"An exception is thrown as another transaction cannot be started within an existing transaction.","D":"There is only one transaction initiated by update1() because the call to update2() does not go through the proxy."},"timestamp":"2023-03-23 18:04:00","answer_ET":"D","question_text":"Refer to the exhibit.\n//IMG//\n\nAssume that the application is using Spring transaction management which uses Spring AOP internally.\nChoose the statement that describes what is happening when the update1 method is called? (Choose the best answer.)","url":"https://www.examtopics.com/discussions/vmware/view/103681-exam-2v0-7222-topic-1-question-8-discussion/","discussion":[{"timestamp":"1729499820.0","poster":"stefumies","upvote_count":"1","content":"This is a poor set of avaiable answers:\n\nupdate() (there is no update1() method) will create a new transaction when executed, however update2() is REQUIRES_NEW which will suspend that transaction and create a new one,\nuntil it has completed, and then return to the suspended transaction begun by update(), thus:\n\nA is the most correct as there wuill be 2 transactions (even though one is suspended) \nB this is false, new transactions can be started within existing ones\nC is incorrect as it never uses an existing transaction (it suspends it)\nD is incorrect because update 2 does begin a new transaction and is within a proxy\n\nTherefore A is the most accurate in this context","comments":[{"content":"However a closer look at the call stack of the transactions, update2() is called within the scope (and thus the proxy) of update() and therefore, despite REQUIRES_NEW starting a new transaction and suspending the initial one, it is none the less in the same Proxy created by update(), and in this context D is most accurate!","poster":"stefumies","timestamp":"1729500180.0","upvote_count":"1","comment_id":"1300848"}],"comment_id":"1300844"},{"upvote_count":"2","comment_id":"1255639","content":"Selected Answer: D\nn Spring, transaction management relies on Spring AOP (Aspect-Oriented Programming), which means transactions are managed through proxies. For a new transaction (like one specified with REQUIRES_NEW) to be started within an existing transaction, the method must be called through a Spring proxy.\n\nIn the code provided, update1 calls update2 directly. This means the call does not go through the Spring proxy, and hence, the REQUIRES_NEW propagation on update2 is not recognized. As a result, there is only one transaction, which is the one initiated by update1.\n\nIf update2 were to be called in a way that went through the proxy, such as through another Spring-managed bean, a new transaction would indeed be started because of the REQUIRES_NEW propagation. However, the direct call prevents this from happening, leading to only one transaction.","timestamp":"1721989200.0","poster":"Evoila_TrainingMaterial"},{"poster":"2211094","comment_id":"1239666","content":"A is correct","upvote_count":"1","timestamp":"1719755280.0"},{"content":"Selected Answer: D\nAnswer is D. \n\nBased on the lecture video from Vmware's training course (Spring framework essentials> Module 9 > Configure Transaction Propagation): \nThe first update method will create a transaction and run in a proxy, and when the second update method is called, it will be executed within the same transaction in the same proxy.","comment_id":"976300","comments":[{"comments":[{"poster":"Azuni","timestamp":"1692085980.0","content":"Same here. Luckily the instructor in the video did mention this and illustrated this in his slides 3:42 minutes into the video. Took me a while to filter though all the stuff.","comment_id":"981401","upvote_count":"1"}],"comment_id":"976301","content":"Now you might be asking, why would it execute within the same transaction if the propagation is REQUIRES_NEW? Wouldn't it create a new transaction? \n\nNormally yes, however, In this case, the update2() method is being called in the same class as the first update(), making it an internal call. \n\nWhen the first update method was called the @Transactional annotation passed the method execution to the interceptor, which created a proxy for the transaction (Spring AOP). When the Internal call to the second update2() method was executed, it couldn't be intercepted by a new interceptor, therefore, it couldn't create its own transactional proxy, which means it cannot create a new transaction. \n\nIf you don't understand this concept right away, don't worry. I had to review the video several times and I'm still trying to wrap my head around it.","upvote_count":"1","timestamp":"1691560980.0","poster":"Ancient1"}],"poster":"Ancient1","upvote_count":"4","timestamp":"1691560980.0"},{"comments":[{"content":"UPDATE: I went though the VMWare Spring Framework Essentials lecture video where they used this exact example. The answer is indeed D. Feel to stupid for my original post. Apologies for the confusion.","timestamp":"1690871760.0","poster":"Azuni","upvote_count":"4","comment_id":"968787"}],"comment_id":"968147","content":"Selected Answer: A\nThe answer should be A. There should be two transactions. The first one will be suspended when the second one is called and once the second transaction is done, the first one will become active again.\n\nPlease refer to the Spring Docs on the topic of Transaction propagation: https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/tx-propagation.html","upvote_count":"1","timestamp":"1690809960.0","poster":"Azuni"},{"content":"The option D is correct due to this article, where this case resolved -\nhttps://www.marcobehler.com/guides/spring-transaction-management-transactional-in-depth","timestamp":"1681108740.0","comment_id":"866047","poster":"Verixas","upvote_count":"2"},{"content":"I think is A correct answer\n\nOption B is incorrect because an exception is not thrown when using REQUIRES_NEW propagation. \nOption C is incorrect because REQUIRES_NEW will always create a new transaction even if an active transaction is present. \nOption D is also incorrect because the call to update2() does go through the proxy and the transactional behavior will be applied.","comment_id":"848473","poster":"rhuanca","timestamp":"1679591040.0","upvote_count":"1"}]},{"id":"JT30sEWmTauAOtAIzsYe","exam_id":252,"url":"https://www.examtopics.com/discussions/vmware/view/142672-exam-2v0-7222-topic-1-question-80-discussion/","timestamp":"2024-06-18 14:57:00","answers_community":[],"discussion":[{"comment_id":"1232434","poster":"2211094","content":"Sorry CD is not correct but rather AD, why because\n\n@WebMvcTest\nis specifically designed for testing Spring MVC components without starting a full application server","upvote_count":"2","timestamp":"1718715600.0"},{"poster":"2211094","upvote_count":"1","comment_id":"1232430","timestamp":"1718715420.0","content":"CD is correct answer."}],"answer_ET":"AD","unix_timestamp":1718715420,"answer":"AD","question_text":"Which two statements are true regarding @WebMvcTest? (Choose two.)","answer_description":"","topic":"1","isMC":true,"answer_images":[],"choices":{"E":"It is typically used with @ExtendWith(MockitoExtension.class) in JUnit 5.","B":"It will only scan for @Controller beans in the source code.","D":"Typically it is used in combination with @MockBean when there is a dependency bean to be mocked.","A":"It auto-configures a MockMvc.","C":"It is used for testing Spring MVC components such as @Controller with a running server."},"question_id":70,"question_images":[]}],"exam":{"isImplemented":true,"provider":"Vmware","numberOfQuestions":77,"id":252,"isBeta":false,"name":"2V0-72.22","isMCOnly":true,"lastUpdated":"12 Apr 2025"},"currentPage":14},"__N_SSP":true}