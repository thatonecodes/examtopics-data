{"pageProps":{"questions":[{"id":"h7X7jVcjAH8uedMo1MSS","question_images":[],"answer_description":"","url":"https://www.examtopics.com/discussions/vmware/view/87227-exam-2v0-7222-topic-1-question-23-discussion/","answer":"BCD","topic":"1","isMC":true,"discussion":[{"timestamp":"1727678640.0","upvote_count":"3","content":"Correct answer: B C D","comment_id":"1021295","poster":"NAZER123"},{"upvote_count":"4","comment_id":"970249","poster":"james2033","comments":[{"timestamp":"1723720440.0","poster":"Azuni","upvote_count":"1","content":"Very good explanation. The very same was presented in the VMWare Spring Boot course.","comment_id":"981566"}],"timestamp":"1722606720.0","content":"Selected Answer: BCD\nThe spring-boot-starter-test “Starter” (in the test scope) contains the following provided libraries:\n\nJUnit 5: The de-facto standard for unit testing Java applications.\n\nSpring Test & Spring Boot Test: Utilities and integration test support for Spring Boot applications.\n\nAssertJ: A fluent assertion library.\n\nHamcrest: A library of matcher objects (also known as constraints or predicates).\n\nMockito: A Java mocking framework.\n\nJSONassert: An assertion library for JSON.\n\nJsonPath: XPath for JSON.\n\nat https://docs.spring.io/spring-boot/docs/3.2.x/reference/htmlsingle/#features.testing.test-scope-dependencies\n\nCorrect answer: B C D"},{"poster":"qqoo","upvote_count":"2","comment_id":"944957","content":"Selected Answer: BCD\nThese are correct","timestamp":"1720293660.0"},{"comment_id":"837292","timestamp":"1710268440.0","content":"Selected Answer: BCD\nThese are correct","upvote_count":"2","poster":"zakupower"},{"content":"Selected Answer: BCD\nhttps://docs.spring.io/spring-boot/docs/1.5.7.RELEASE/reference/html/boot-features-testing.html\nTest scope dependencies\nIf you use the spring-boot-starter-test ‘Starter’ (in the test scope), you will find the following provided libraries:\n\nJUnit — The de-facto standard for unit testing Java applications.\nSpring Test & Spring Boot Test — Utilities and integration test support for Spring Boot applications.\nAssertJ — A fluent assertion library.\nHamcrest — A library of matcher objects (also known as constraints or predicates).\nMockito — A Java mocking framework.\nJSONassert — An assertion library for JSON.\nJsonPath — XPath for JSON.","poster":"ridasys","timestamp":"1699592520.0","upvote_count":"3","comment_id":"714927"}],"question_id":16,"timestamp":"2022-11-10 06:02:00","choices":{"C":"spring-test","F":"PowerMock","A":"Cucumber","E":"EasyMock","B":"Hamcrest","D":"Junit"},"unix_timestamp":1668056520,"answer_images":[],"answer_ET":"BCD","question_text":"Which three dependencies are provided by the spring-boot-starter-test? (Choose three.)","answers_community":["BCD (100%)"],"exam_id":252},{"id":"kGr68qYcOTnkCeyTWaPa","answer_images":[],"question_images":[],"topic":"1","answers_community":["AB (100%)"],"unix_timestamp":1680454140,"choices":{"D":"Enable component scanning within auto-configuration classes to find necessary components.","B":"Disable specific auto-configuration classes by using the exclude attribute on the @EnableAutoConfiguation annotation.","E":"Control the order of auto-configuration classes applied with @AutoConfigureOrder.","A":"Use the @AutoConfigureAfter or @AutoConfigureBefore annotations to apply configuration in a specific order.","C":"Provide customized auto-configuration by subclassing the provided Spring Boot auto-configuration classes."},"answer":"AB","discussion":[{"poster":"Azuni","comments":[{"comment_id":"1327337","timestamp":"1734352200.0","poster":"quakquak3","content":"I don't see why E is not also correct. I would have voted ABE if it was possible.\n\n\nIf your configuration needs to be applied in a specific order, you can use the before, beforeName, after and afterName attributes on the @AutoConfiguration annotation or the dedicated @AutoConfigureBefore and @AutoConfigureAfter annotations. For example, if you provide web-specific configuration, your class may need to be applied after WebMvcAutoConfiguration.\n\nhttps://docs.spring.io/spring-boot/docs/3.0.0/reference/html/features.html#features.developing-auto-configuration.locating-auto-configuration-candidates mentions both A and E:\n\"If you want to order certain auto-configurations that should not have any direct knowledge of each other, you can also use @AutoConfigureOrder. That annotation has the same semantic as the regular @Order annotation but provides a dedicated order for auto-configuration classes.\"","upvote_count":"1"}],"content":"Selected Answer: AB\nI believe A and B is correct. \nThe statement in A is exactly extracted from here: https://docs.spring.io/spring-boot/docs/3.0.0/reference/html/features.html#features.developing-auto-configuration.locating-auto-configuration-candidates\nB is correct as it is stated as one of the many ways to customize your auto-configuration.\nC is not correct as you can't just create a subclass of the auto-configuration class and expect it to work. You need to import that parent auto-configuration into a configuration of your own.\nD is incorrect as component scanning has nothing to do with this.\nE is actually also correct.\n\nWe have to chose only 2, I looked at which statement between A and E were exactly the same as in the Spring Docs. A was exactly the same as in the documentation.\n\nThis is a very peculiar question as it's answers are not really in the studying material, except for answer B.","timestamp":"1723727400.0","comment_id":"981695","upvote_count":"3"},{"timestamp":"1712076540.0","poster":"rhuanca","comment_id":"859104","upvote_count":"2","content":"B and C . \n\n A. The @AutoConfigureAfter, @AutoConfigureBefore, and @AutoConfigureOrder annotations are used to control the order in which auto-configuration classes are applied, not to apply configuration in a specific order","comments":[{"upvote_count":"1","poster":"Azuni","timestamp":"1723723140.0","comment_id":"981612","content":"It can't be C. It is not enough to simply subclass an auto-configuration class. It needs to be the same type of BEAN as the auto-configured bean. Not just the class."}]}],"answer_ET":"AB","exam_id":252,"timestamp":"2023-04-02 18:49:00","url":"https://www.examtopics.com/discussions/vmware/view/104893-exam-2v0-7222-topic-1-question-24-discussion/","question_id":17,"answer_description":"","isMC":true,"question_text":"Which two statements are correct regarding Spring Boot auto-configuration customization? (Choose two.)"},{"id":"iQ0BR25qHD0geTO6zLVB","isMC":true,"question_text":"Which two statements about the @Autowired annotation are true? (Choose two.)","answer_description":"","question_images":[],"answer_images":[],"answer":"BC","topic":"1","discussion":[{"timestamp":"1722517080.0","content":"Selected Answer: BC\nB is of course correct, but the reason why C is correct is because the default required setting of Autowired is 'true'. If no bean is found, a org.springframework.beans.factory.NoSuchBeanDefinitionException is thrown, which is a RuntimeException.","comment_id":"969082","poster":"Azuni","comments":[{"poster":"Azuni","timestamp":"1723728420.0","upvote_count":"1","comment_id":"981705","content":"A is not correct as the Fields are injected right after construction of a bean, before any config methods are invoked.\nD is incorrect as you can't annotate a class.\nE is incorrect as Autowired is not supported in BeanPostProcessor or BeanFactoryPostProcessor, so you can't inject a reference in them using Autowired.\n\nHere is my reference: https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html"}],"upvote_count":"6"},{"upvote_count":"2","comment_id":"965530","poster":"Tolo01","content":"Selected Answer: BC\nB and C","timestamp":"1722166380.0"},{"poster":"qqoo","content":"Selected Answer: AB\nThe others seem wrong","timestamp":"1720294320.0","comment_id":"944968","upvote_count":"1"},{"poster":"rhuanca","upvote_count":"1","content":"B and C","timestamp":"1712370900.0","comment_id":"862649"},{"comments":[{"content":"Not sure about A, because @Autowired fields are injected before any config methods (@Bean, @Component, @Configuration, etc..) are invoked.","comment_id":"857627","poster":"rhuanca","timestamp":"1711952160.0","upvote_count":"1"}],"upvote_count":"1","poster":"qulyt","comment_id":"772404","content":"A and B, per Autowired documentation.\n\nAutowired Fields\nFields are injected right after construction of a bean, before any config methods are invoked. Such a config field does not have to be public.\n\nAutowired Methods\nConfig methods may have an arbitrary name and any number of arguments; each of those arguments will be autowired with a matching bean in the Spring container. Bean property setter methods are effectively just a special case of such a general config method. Such config methods do not have to be public.","timestamp":"1704970080.0"},{"content":"E is not correct\nNote that actual injection is performed through a BeanPostProcessor which in turn means that you cannot use @Autowired to inject references into BeanPostProcessor or BeanFactoryPostProcessor types. Please consult the javadoc for the AutowiredAnnotationBeanPostProcessor class (which, by default, checks for the presence of this annotation).\nhttps://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html","timestamp":"1702452600.0","poster":"faciorys","upvote_count":"2","comment_id":"743707"}],"unix_timestamp":1670916600,"question_id":18,"choices":{"C":"By default, if a dependency cannot be satisfied with @Autowired, Spring throws a RuntimeException.","D":"If @Autowired is used on a class, field injection is automatically performed for all dependencies.","A":"@Autowired fields are injected after any config methods are invoked.","B":"Multiple arguments can be injected into a single method using @Autowired.","E":"@Autowired can be used to inject references into BeanPostProcessor and BeanFactoryPostProcessor."},"answer_ET":"BC","timestamp":"2022-12-13 08:30:00","exam_id":252,"answers_community":["BC (89%)","11%"],"url":"https://www.examtopics.com/discussions/vmware/view/91327-exam-2v0-7222-topic-1-question-25-discussion/"},{"id":"jrN49BCDb2uLpVByyxZE","answer":"AB","unix_timestamp":1670917560,"question_images":[],"answer_description":"","question_text":"Which two statements are correct regarding the @EnableAutoConfiguration annotation? (Choose two.)","answers_community":["AB (100%)"],"question_id":19,"answer_images":[],"timestamp":"2022-12-13 08:46:00","exam_id":252,"discussion":[{"upvote_count":"7","timestamp":"1718257560.0","comment_id":"743721","poster":"faciorys","content":"Selected Answer: AB\nEnable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need\nhttps://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/EnableAutoConfiguration.html"}],"topic":"1","choices":{"D":"It has the same effect regardless of the package of the class that is annotated with it.","E":"It ensures auto-configuration is applied before user-defined beans have been registered.","A":"It is a meta-annotation on the @SpringBootApplication composed annotation.","B":"It enables auto-configuration of the ApplicationContext by attempting to guess necessary beans.","C":"It is meta-annotation on the @SpringBootConfiguration composed annotation."},"answer_ET":"AB","isMC":true,"url":"https://www.examtopics.com/discussions/vmware/view/91334-exam-2v0-7222-topic-1-question-26-discussion/"},{"id":"eybYyj0jyRpDTF3lUri2","topic":"1","answer_images":[],"answer_description":"","choices":{"A":"BeanPostProcessors are called before the dependencies have been injected.","B":"Custom BeanPostProcessrs can be implemented for Spring applications.","C":"BeanPostProcessors are called before the BeanFactoryPostProcessors.","D":"BeanPostProcessors are called during the initialization phase of a bean life cycle.","E":"BeanPostProcessors cannot be ordered in a Spring Boot application."},"timestamp":"2023-08-28 11:29:00","isMC":true,"answers_community":["BD (100%)"],"discussion":[{"upvote_count":"3","poster":"saJAva","content":"Selected Answer: BD\ncorrect","timestamp":"1733874540.0","comment_id":"1228129"}],"answer":"BD","unix_timestamp":1693214940,"question_id":20,"url":"https://www.examtopics.com/discussions/vmware/view/119215-exam-2v0-7222-topic-1-question-27-discussion/","exam_id":252,"answer_ET":"BD","question_images":[],"question_text":"Which two statements are true concerning the BeanPostProcessor Extension point? (Choose two.)"}],"exam":{"provider":"Vmware","isMCOnly":true,"lastUpdated":"12 Apr 2025","id":252,"isBeta":false,"numberOfQuestions":77,"isImplemented":true,"name":"2V0-72.22"},"currentPage":4},"__N_SSP":true}